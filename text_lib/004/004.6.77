И.И. Семенова
РАЗРАБОТКА КЛИЕНТ-СЕРВЕРНЫХ
ПРИЛОЖЕНИЙ
С ИСПОЛЬЗОВАНИЕМ ТЕХНОЛОГИЙ
ORACLE
Учебно-методическое пособие
Омск • 2008
Федеральное агентство по образованию
Сибирская государственная автомобильно-дорожная академия
(СибАДИ)
И.И. Семенова
РАЗРАБОТКА КЛИЕНТ-СЕРВЕРНЫХ
ПРИЛОЖЕНИЙ
С ИСПОЛЬЗОВАНИЕМ ТЕХНОЛОГИЙ
ORACLE
Учебно-методическое пособие
Омск
Издательство СибАДИ
2008
УДК 004.6
ББК 32.973.2-018
С 30
Рецензенты:
канд. техн. наук, доцент кафедры АСОИУ, В.Н. Цыганенко, ОмГТУ
канд. техн. наук, доцент кафедры СС иИБ, В.Г. Осипов, ОмГТУ
Работа одобрена редакционно-издательским советом академии в качестве
учебно-методического пособия для специальностей 230102 «Автоматизированные системы обработки информации и управления», 080801 «Прикладная информатика в экономике», 090105 «Комплексное обеспечение информационной
безопасности автоматизированных систем».
Семенова И.И.
С 30 Разработка клиент-серверных приложений с использованием технологий Oracle: Учебно-методическое пособие.– Омск: Изд-во СибАДИ,2008.–121 с.
ISBN 978–5–93204–420–9
Основной целью создания данного учебно-методического пособия стала
необходимость закрепления навыков работы в одной из современных СУБД с
целью создания приложений для различных предметных областей у студентов
высших учебных заведений, изучающих дисциплину “Системы управления базами данных”.
Учебно-методическое пособие по курсу «Системы управления базами данных» предназначено для студентов, обучающихся по специальностям 230102,
080801, 090105.
Табл. 17 Ил. 24 Библиогр.: 7 назв.
ISBN 978–5–93204–420–9
© И.И. Семенова, 2008
ОБЩИЕ ПОЛОЖЕНИЯ
В процессе выполнения лабораторных работ по дисциплине «Системы
управления базами данных» студенты должны выработать навыки физического проектирования баз данных, а также навыки разработки клиентских
приложений для работы с базами данных, расположенных на сервере.
Изучение этих вопросов предусмотрено действующим государственным образовательным стандартом и в данном учебно-методическом пособии базируется на решении задач, актуальных для студентов специальности «Автоматизированные системы обработки информации и управления»
(АСОИУ), «Прикладная информатика в экономике» (ПИЭ), «Комплексное
обеспечение информационной безопасности автоматизированных систем»
(КОИБАС).
В серии лабораторных работ используются Oracle 9i, Borland Delphi 7.
Важной составной частью работ является освоение SQL стандарта. Чтобы
приступить к выполнению этих работ, студенту уже нужно иметь минимальные навыки обращения с используемыми в них программными средствами. Эти необходимые навыки даются студентам на установочных занятиях в начале семестра вместе с выдачей заданий и электронных материалов.
Результаты выполнения работ рекомендуется сохранять в личных папках, так как лабораторные работы взаимоувязаны.
3
Лабораторная работа No1
СОЗДАНИЕ ОБЪЕКТОВ БАЗЫ ДАННЫХ (БД) В ORACLE 9i
Цель работы – с помощью операторов языка PL/SQL научиться создавать
пользователя, который будет управлять всеми объектами создаваемой базы
данных, схему, табличное пространство для хранения объектов базы данных и совокупность связанных таблиц, принадлежащих указанной базе
данных в конкретной схеме.
Содержание работы:
1. Познакомиться с набором утилит, входящих в состав Oracle 9i.
2. Познакомиться с работой утилит Enterprise MANAGER Console и
SQL *Plus Worksheet.
3. Создать с помощью приведенных операторов пример базы данных
«Книжное дело».
4. По выданным вариантам создать персональную базу данных с набором связанных таблиц.
Пояснения к выполнению работы
В качестве примера базы данных, которая будет создана программно с
помощью операторов языка PL/SQL, выберем БД «Книжное дело» (рис.
1.1). Структура таблиц данной БД представлена в табл. 1.1-1.5.
Purchases
Code_book
Date_order
Code_delivery
Type_purchase
Cost
Amount
Code_purchase
Books
Code_book
Title_book
Code_author
Pages
Code_publish
Deliveries
Code_delivery
Name_delivery
Name_company
Address
Phone
INN
Authors
Code_author
Name_author
Birthday
Publishing_house
Code_publish
Publish
City
Рис. 1.1. Фрагмент базы данных «Книжное дело»
4
Таблица 1.1
Покупки (название таблицы Purchases)
Название поля Тип поля
            Code_book Number (5)
Date_order Date
Code_delivery Number (4)
Type_purchase Char (1)
Cost Number (10,2)
Amount Number (4)
Code_purchase Number (5)
Описание поля
Код закупаемой книги, внешний ключ
на таблицу Books
Дата заказа книги
Код поставщика, внешний ключ на таблицу Deliveries
Тип закупки (опт/ розница)
Стоимость единицы товара
Количество экземпляров
Код покупки, ключевое поле типа
PRIMARY
Таблица 1.2
Справочник книг (название таблицы Books)
Название поля Тип поля
            Code_book Number (5)
Title_book Code_author VarChar2
                      (100)
                     Number (3)
Pages Number (4)
Code_publish Number (4)
Описание поля
Код книги, ключевое поле
PRIMARY
Название книги
типа
Код автора, внешний ключ на таблицу
Authors
Количество страниц
Код издательства, внешний ключ на
таблицу Publishing_house
Таблица 1.3
Справочник авторов (название таблицы Authors)
Название поля Тип поля
            Code_author Number (3)
Name_author Char (30)
Birthday Date
Описание поля
Код автора, ключевое поле
PRIMARY
Фамилия, имя, отчество автора
Дата рождения
типа
Таблица 1.4
Справочник поставщиков (название таблицы Deliveries)
Название поля Тип поля
            Code_delivery Number(4)
Name_delivery Char (35)
Name_company Char (30)
Address VarChar2 (100)
Phone Char (11)
INN Char (13)
Описание поля
Код поставщика, ключевое поле типа
PRIMARY
Фамилия, и., о. ответственного лица
Название компании-поставщика
Юридический адрес
Телефон контактный
ИНН
5
Таблица 1.5
Справочник издательств (название таблицы Publishing_house)
Название поля Тип поля
            Code_publish Number(4)
Publish Char (30)
City Char (15)
Описание поля
Код издательства, ключевое поле типа
PRIMARY
Издательство
Город
Прежде чем создавать таблицы БД, необходимо создать схему (она будет создана автоматически при создании пользователя) и соответствующее
табличное пространство, в котором будут храниться объекты БД.
Это можно сделать программно и интерактивно.
Интерактивный способ создания реализуется через утилиту Enterprise
Manager Console. Для соединения с экемпляром БД Oracle при первом соединении выберите режим Launch standalone, далее в появившемся окне
дважды щелкните по экземпляру БД и воспользуйтесь учетной записью
System с паролем по умолчанию manager и уровнем доступа SYSDBA
(рис. 1.2).
Рис. 1.2. Аутентификация пользователя
6
Перед созданием табличного пространства необходимо создать пользователя, который будет играть роль администратора создаваемой БД.
Для этого выполните действие, как показано на рис. 1.3.
Рис. 1.3. Пример создания пользователя
Процесс создания пользователя в интерактивном режиме выглядит следующим образом (рис. 1.4):
Рис. 1.4. Настройка привилегий пользователя
7
Теперь необходимо переподключиться к экземпляру БД под созданной
учетной записью (рис. 1.5).
Рис. 1.5. Смена соединения
Затем приступаем к созданию табличного пространства (рис. 1.6).
Рис. 1.6. Пример создания табличного пространства
Введем параметры, как показано на рис. 1.7.
8
Рис. 1.7. Настройка свойств табличного пространства
Теперь
переопределяем
ранее
созданного
пользователя
ADMIN_BOOKS на работу только в этом табличном пространстве (рис.
1.8).
Рис. 1.8. Изменение свойств существующего пользователя
9
Затем можно приступать к созданию таблиц БД в табличном пространстве, как показано на рис. 1.9.
Рис. 1.9. Пример создания таблицы
Поочередно создаем таблицы, структура которых представлена в табл.
1.1 – 1.5, по примеру, показанному ниже на рис. 1.10.
Рис. 1.10. Настройка структуры таблицы
10
Рис. 1.11. Создание ключевого поля в таблице
Кроме того, при создании новой таблицы на вкладке Constraints Storage
в качестве табличного пространства для хранения индекса выбираем
DB_BOOKS (рис. 1.11).
Те же самые операции можно выполнить программно, используя операторы SQL стандарта, реализованные в Oracle как операторы встроенного
языка PL/SQL.
Для выполнения операторов можно запустить утилуту SQL *Plus
Worksheet через меню Windows или через утилиту Enterprise Manager
Console, выбрав на левой панели соответствующую пиктограмму, как показано на рис. 1.12.
11
Рис. 1.12. Пример запуска утилиты SQL * Plus Worksheet
При запуске SQL *Plus Worksheet подключиться к серверу с помощью
пользователя System с паролем по умолчанию manager и уровнем доступа
SYSDBA, в качестве SERVICE ввести имя экземпляра БД, в данном примере это ORCL.
Вводим набор операторов для создания администратора создаваемой
БД.
CREATE USER "ADMIN_BOOKS"
PROFILE "DEFAULT"
IDENTIFIED BY "worlds"
DEFAULT TABLESPACE "USERS"
TEMPORARY TABLESPACE "TEMP"
ACCOUNT UNLOCK;
GRANT "CONNECT" TO "ADMIN_BOOKS" WITH ADMIN OPTION;
GRANT "DBA" TO "ADMIN_BOOKS" WITH ADMIN OPTION;
GRANT "EXP_FULL_DATABASE" TO "ADMIN_BOOKS" WITH
ADMIN OPTION;
Пример ввода программного кода показан на рис. 1.13.
Для запуска операторов на исполнение выделяем группу операторов
мышкой и нажимаем F5. Если нет ошибок, то на каждый оператор система
в нижней половине экрана выдаст сообщения: «Пользователь создан»,
«Привилегии предоставлены».
Теперь необходимо переподключиться к экземпляру БД под созданной
учетной записью, для этого выберите значок «Электрическая вилка» и вве12
дите в появившемся окне данные для подключения под новым пользователем.
Рис. 1.13. Пример работы утилиты SQL * Plus Worksheet
Приступаем к созданию табличного пространства программно (знак ; в
конце оператора обязателен).
CREATE TABLESPACE "DB_BOOKS"
LOGGING
DATAFILE 'C:\ORACLE\ORADATA\ORCL\DB_BOOKS.dbf' SIZE 5M
EXTENT
MANAGEMENT LOCAL;
Для запуска оператора на исполнение выделяем его мышкой и нажимаем F5. Если нет ошибок, то на оператор система в нижней половине экрана
выдаст сообщение: «Раздел создан».
Теперь
переопределяем
ранее
созданного
пользователя
ADMIN_BOOKS на работу только в табличном пространстве DB_BOOKS.
ALTER USER "ADMIN_BOOKS" DEFAULT TABLESPACE
"DB_BOOKS";
Для запуска оператора на исполнение выделяем его мышкой и нажимаем F5. Если нет ошибок, то на оператор система в нижней половине экрана
выдаст сообщение: «Пользователь изменен».
Создаем таблицы, структура которых представлена в табл. 1.1 – 1.5, по
примеру представленного кода в утилите SQL *Plus Worksheet:
CREATE TABLE "ADMIN_BOOKS"."AUTHORS" ("CODE_AUTHOR"
NUMBER(3) NOT NULL, "NAME_AUTHOR" CHAR(30), "BIRTHDAY" DATE,
13
CONSTRAINT "ID_AUTHOR" PRIMARY KEY("CODE_AUTHOR") USING
INDEX TABLESPACE "DB_BOOKS") TABLESPACE "DB_BOOKS";
CREATE TABLE "ADMIN_BOOKS"."DELIVERIES" ("CODE_DELIVERY"
NUMBER(4) NOT NULL, "NAME_DELIVERY" CHAR(35), "NAME_COMPANY"
CHAR(30) NOT NULL, "ADDRESS" VARCHAR2(100), "PHONE" CHAR(11)
NOT NULL, "INN" CHAR(13), CONSTRAINT "ID_DELIVERY" PRIMARY
KEY("CODE_DELIVERY") USING INDEX TABLESPACE "DB_BOOKS")
TABLESPACE "DB_BOOKS";
CREATE TABLE "ADMIN_BOOKS"."PUBLISHING_HOUSE"
("CODE_PUBLISH" NUMBER(4) NOT NULL, "PUBLISH" CHAR(30) NOT
NULL, "CITY" CHAR(15), CONSTRAINT "ID_PUBLISH" PRIMARY
KEY("CODE_PUBLISH") USING INDEX TABLESPACE "DB_BOOKS")
TABLESPACE "DB_BOOKS";
CREATE TABLE "ADMIN_BOOKS"."BOOKS" ("CODE_BOOK"
NUMBER(5) NOT NULL, "TITLE_BOOK" VARCHAR2(100) NOT NULL,
"CODE_AUTHOR" NUMBER(3) NOT NULL, "PAGES" NUMBER(4),
"CODE_PUBLISH" NUMBER(4) NOT NULL, CONSTRAINT "ID_BOOK_FK"
PRIMARY KEY("CODE_BOOK") USING INDEX TABLESPACE "DB_BOOKS",
CONSTRAINT "ID_AUTHOR_FK" FOREIGN KEY("CODE_AUTHOR")
REFERENCES "ADMIN_BOOKS"."AUTHORS"("CODE_AUTHOR") ON
DELETE CASCADE, CONSTRAINT "ID_PUBLISH_FK" FOREIGN
KEY("CODE_PUBLISH") REFERENCES
"ADMIN_BOOKS"."PUBLISHING_HOUSE"("CODE_PUBLISH") ON DELETE
CASCADE) TABLESPACE "DB_BOOKS";
CREATE TABLE "ADMIN_BOOKS"."PURCHASES" ("CODE_BOOK"
NUMBER(5) NOT NULL, "DATE_ORDER" DATE NOT NULL,
"CODE_DELIVERY" NUMBER(4) NOT NULL, "TYPE_PURCHASE" CHAR(1)
NOT NULL, "COST" NUMBER(10,2) NOT NULL, "AMOUNT" NUMBER(4) NOT
NULL, "CODE_PURCHASE" NUMBER(5) NOT NULL, CONSTRAINT
"ID_PURCHASE" PRIMARY KEY("CODE_PURCHASE") USING INDEX
TABLESPACE "DB_BOOKS", CONSTRAINT "ID_BOOK_FK2" FOREIGN
KEY("CODE_BOOK") REFERENCES
"ADMIN_BOOKS"."BOOKS"("CODE_BOOK"), CONSTRAINT
"ID_DELIVERY_FK" FOREIGN KEY("CODE_DELIVERY") REFERENCES
"ADMIN_BOOKS"."DELIVERIES"("CODE_DELIVERY")) TABLESPACE
"DB_BOOKS";
Не забывайте: сначала создаются справочники, в которых есть только
ключевые поля типа PRIMARY, а затем другие таблицы, в которых создаются внешние ключи типа FOREIGN KEY.
14
Использованные операторы:
PRIMARY KEY – признак создания ключевого поля.
FOREIGN KEY...REFERENCES... – признак создания поля связи с
другой таблицей.
CREATE TABLE – команда создания таблицы в текущей БД.
В табл. 1.6 описаны типы данных при создании таблиц БД, особенность которых заключается в том, что поведение некоторых типов данных
и одноименных типов переменных в PL/SQL отличаются, на что необходимо обратить внимание. Типы переменных PL/SQL и их особенности
описаны в лабораторной работе No4.
Таблица 1.6
Типы данных в объектах Oracle
Тип данных
1 МаксиCHAR мальный
           размер
                2
               255
VARCHAR2 4000
NCHAR 2000
NVARCHA
R2
LONG 2 Гб
NUMBER Точность
              от 1 до 38;
                 Масштаб
                       от -84 до
                          128
Описание Способы объявления
3 4
Символьная строка фик- 
                   сированной длины, без 
                                     указания размера ее дли- 
                                                         на равна 1 
                                                                С помощью этого типа 
                                                                                 данных резервируется 
                                                                                                    необходимое простран- 
                                                                                                                       ство, характерно только 
                                                                                                                                           для Oracle 
                                                                                                                                              Строка фиксированной 
                                                                                                                                                                 длины в режиме 
                                                                                                                                                                             UNICODE для поддерж- 
                                                                                                                                                                                       ки национальных коди- 
                                                                                                                                                                                                         ровок 
                                                                                                                                                                                                              Строка переменной дли- 
                                                                                                                                                                                                                                 ны в режиме UNICODE 
                                                                                                                                                                                                                                          для поддержки нацио- 
                                                                                                                                                                                                                                                           нальных кодировок 
                                                                                                                                                                                                                                                                           Большая строка пере- 
                                                                                                                                                                                                                                                                                            менной длины, если дли- 
                                                                                                                                                                                                                                                                                                              на не указана, то полага- 
                                                                                                                                                                                                                                                                                                                                 ется длина, равная 2 Мб 
                                                                                                                                                                                                                                                                                                                                                  Число с заданной точно- 
                                                                                                                                                                                                                                                                                                                                                                     стью только для Oracle, 
                                                                                                                                                                                                                                                                                                                                                                                  если значение параметра 
                                                                                                                                                                                                                                                                                                                                                                                                       точность не указано, то 
                                                                                                                                                                                                                                                                                                                                                                                                                          полагается равным 38 
15
CHAR(длина);
CHARACTER(длина)
VARCHAR2(длина)
NCHAR(длина)
NVARCHAR2(длина)
LONG(длина)
NUMBER(точность, масштаб);
Например, NUMBER (7,-3) –
округление до тысяч;
NUMBER (7, 3) – округление
количества знаков после запятой до трех
Окончание табл. 1.6
1
LONG RAW
2
2Гб
FLOAT
RAW 255 байт
DATE 01.01.4712
    до нэ
       01.01.4712
      нэ
ROWID
UROWID
BLOB
CLOB
BFILE
3
Большие битовые строки
переменной длины
Число с одинарной плавающей точкой
Битовые строки переменной длины, только
для Oracle. Отличие от
Char и Varchar2 в автоматическом преобразовании данных при передаче
между клиентом и сервером
Дата и время. Для присвоения даты используется функция
TO_DATE(‘символьная
дата’, ‘формат даты’)
Физическая ссылка определяет строку в таблице,
логическая ссылка определяет строку в таблице,
организованной в виде
индексной структуры.
Тип ROWID может хранить только физические
ссылки на строки таблицы. Тип UROWID (универсальная ссылка) может хранить физические,
логические ссылки на
строки таблицы и внешние ссылки на строки
типа non-Oracle
Большие двоичные объекты, используются для
хранения рисунков и
прочего
Большие строковые объекты
Указатели на большие
внешние объекты
16
4
LONG RAW(длина в байтах)
RAW(длина в байтах)
Пример присвоения:
PEREM1:=TO_DATE('21-дек1980', 'dd-mon-yyyy');
PEREM2:=TO_DATE('21-121980', 'dd-mm-yyyy')
Варианты заданий к лабораторной работе No1
Общие положения
В утилите Enterprise Manager Console создайте пример базы данных,
как показано по ходу работы.
По индивидуальному варианту исходные таблицы привести к максимальной форме нормализации, для каждой таблицы определить название,
типы полей, определить ключевые поля и при необходимости поля связи
(внешние ключи), определить имя табличного пространства, в котором вы
будете создавать объекты БД по всему комплексу лабораторных работ, а
также определить имя пользователя и пароль.
В утилите Enterprise Manager Console создать вашего пользователя,
табличное пространство и таблицы БД. Перед созданием очередного объекта (т.е. до нажатия клавиши Create) скопируйте SQL код создаваемого
объекта, который можно увидеть, нажав клавишу Show SQL.
Сохранить последовательно операторы в файле программы с названием ФамилияСтудента_ЛАб_1_Noварианта. Данные операторы потребуются для переноса БД с одного сервера БД на другой.
Вариант 1. БД «Учет выданных подарков несовершеннолетним детям сотрудников
предприятия».
Код сотрудника
Код сотрудника
Код ребенка
Фамилия
Имя ребенка
Стоимость подарка
Имя
Дата рождения
Дата выдачи подарка
Отчество
Код ребенка
Код выдачи
Должность
Подразделение
Дата приема на работу
Вариант 2. БД «Учет выполненных ремонтных работ».
Код прибора в ремонте
Код прибора
Название прибора
Код мастера
Тип прибора
ФИО владельца прибора
Дата производства
Дата приема в ремонт
Вид поломки
Стоимость ремонта
Код ремонта
Вариант 3. БД «Продажа цветов».
Код цветка
Код цветка
Название цветка
Дата продажи
Сорт цветка
Цена продажи
Средняя высота
Код продавца
Тип листа
Код продажи
Цветущий
Дополнительные сведения
17
Код мастера
Фамилия мастера
Имя мастера
Отчество мастера
Разряд мастера
Дата приема на работу
Код продавца
Фамилия
Имя
Отчество
Разряд
Оклад
Дата приема на работу
Вариант 4. БД «Поступление лекарственных средств».
Код лекарства
Код лекарства
Название лекарства
Код поставщика
Показания к применению
Дата поставки
Единица измерения
Цена за единицу
Количество в упаковке
Количество
Название производителя
Код поступления
Вариант 5. БД «Списание оборудования».
Код оборудования
Код оборудования
Название оборудования
Причина списания
Тип оборудования
Дата списания
Дата поступления
Код сотрудника
ФИО ответственного
Код списания
Место установки
Вариант 6. БД «Поваренная книга».
Код блюда
Код блюда
Тип блюда
Код продукта
Вес блюда
Объем продукта
Порядок приготовления
Количество калорий
Количество углеводов
Вариант 7. БД «Регистрация входящей документации».
Код регистратора
Код документа
Фамилия
Имя
Отчество
Должность
Дата приема на работу
Номер документа
Дата регистрации
Краткое содержание документа
Тип документа
Код организацииотправителя
Код регистратора
Вариант 8. БД «Увольнение сотрудника».
Код сотрудника
Код документа
Фамилия
Номер документа
Имя
Дата регистрации
Отчество
Дата увольнения
Должность
Код статьи увольнения
Подразделение
Дата приема на работу
Код сотрудника
Денежная компенсация
18
Код поставщика
Сокращенное название
Полное название
Юридический адрес
Телефон
ФИО руководителя
Код сотрудника
Фамилия
Имя
Отчество
Должность
Подразделение
Дата приема на работу
Код продукта
Название продукта
Ед. измерения
Код организацииотправителя
Сокращенное название
Полное название
Юридический адрес
Телефон
ФИО руководителя
Код статьи увольнения
Название статьи увольнения
Причина увольнения
Номер статьи увольнения
Номер пункта/ подпункта
увольнения
Вариант 9. БД «Приказ на отпуск».
Код сотрудника
Код документа
Фамилия
Номер документа
Имя
Дата регистрации
Отчество
Дата начала отпуска
Должность
Дата окончания отпуска
Подразделение
Код сотрудника
Дата приема на работу
Код отпуска
Код отпуска
Тип отпуска
Оплата отпуска
Льготы по отпуску
Вариант 10. БД «Регистрация выходящей документации».
Код отправителя
Код документа
Код организацииполучателя
Фамилия
Номер документа
Сокращенное название
Имя
Дата регистрации
Полное название
Отчество
Краткое содержание доЮридический адрес
кумента
Должность
Тип документа
Телефон
Дата приема на работу
Код организацииФИО руководителя
получателя
Код отправителя
Вариант 11. БД «Назначение на должность».
Код сотрудника
Код документа
Фамилия
Номер документа
Имя
Дата регистрации
Отчество
Дата назначения
Дата приема на работу
Код сотрудника
Дата рождения
Код должности
Пол
Вариант 12. БД «Выдача оборудования в прокат».
Код клиента
Код выдачи
Фамилия
Номер документа
Имя
Дата начала проката
Отчество
Дата окончания проката
Адрес
Код оборудования
Телефон
Код клиента
Серия и номер паспорта
Стоимость
Вариант 13. БД «Списание оборудования из проката».
Код оборудования
Код оборудования
Название оборудования
Причина списания
Тип оборудования
Дата списания
Дата поступления в прокат
Код сотрудника
Номер документа
Дата регистрации
Код списания
19
Код должности
Название должности
Льготы по должности
Требования к квалификации
Код оборудования
Название оборудования
Тип оборудования
Дата поступления в прокат
Код сотрудника
Фамилия
Имя
Отчество
Должность
Дата приема на работу
Вариант 14. БД «Прием цветов в магазин».
Код цветка
Код цветка
Название цветка
Дата поступления
Сорт цветка
Цена за единицу
Средняя высота
Код поставщика
Тип листа
Код поступления
Цветущий
Количество
Дополнительные сведения
Код поставщика
Сокращенное название
Полное название
Юридический адрес
Телефон
ФИО руководителя
Вариант 15. БД «Регистрация клиентов гостиницы».
Код номера
Код регистрации
Код клиента
Тип номера
Код номера
Фамилия
Перечень удобств
Дата заезда
Имя
Цена за сутки
Дата выезда
Отчество
Стоимость
Адрес
Код клиента
Телефон
Серия и номер паспорта
Вариант 16. БД «Возврат оборудования в службу проката».
Код клиента
Код возврата
Фамилия
Номер документа
Имя
Дата возврата
Отчество
Состояние оборудования
Адрес
Телефон
Серия и номер паспорта
Код оборудования
Название оборудования
Тип оборудования
Дата поступления в прокат
Код оборудования
Код клиента
Штраф
Вариант 17. БД «Учет материальных ценностей на предприятии».
Код ценности
Место нахождения ценКод материальноности
ответственного лица
Название ценности
Код ценности
Фамилия
Тип ценности
Код материально ответстИмя
венного лица
Закупочная стоимость
Дата постановки на учет
Отчество
Срок гарантии
Код постановки на учет
Должность
Дата начала гарантии
Дата приема на работу
Подразделение
Вариант 18. БД «Состав ремонтных работ».
Код ремонтной работы
Код ремонтной работы
Код этапа работы
Код мастера
Название этапа работы
Стоимость ремонта
Стоимость этапа
Количество дней ремонта
Название ремонтной работы
Код мастера
Фамилия мастера
Имя мастера
Отчество мастера
Разряд мастера
Дата приема на работу
20
Вариант 19. БД «Продажа лекарственных средств».
Код лекарства
Номер чека
Название лекарства
Цена за единицу
Показания к применению
Количество
Единица измерения
Код лекарства
Количество в упаковке
Код записи в чеках
Название производителя
Номер чека
Дата продажи
Сумма
ФИО кассира
Вариант 20. БД «Учет исполнения по входящей документации».
Код исполнителя
Код документа
Код документа
Фамилия
Дата назначения на исНомер документа
полнения
Имя
Срок выполнения в днях
Дата регистрации
Отчество
Тип результата
Краткое содержание документа
Должность
Код исполнителя
Тип документа
Подразделение
Факт исполнения
Организация-отправитель
Дата приема на работу
Код исполнителя
Лабораторная работа No2
ЗАПОЛНЕНИЕ ТАБЛИЦ ORACLE 9i ДАННЫМИ
Цель работы – изучить и освоить все способы заполнения данными таблиц Oracle.
Содержание работы:
1. Создать с помощью приведенных операторов пример базы данных
«Книжное дело», описанный в предыдущей лабораторной работе (если БД
отсутствует на сервере).
2. С помощью утилиты Enterprise Manager Console заполнить таблицы
данными (по 3-5 записей).
3. С помощью операторов Insert создать программу в SQL *Plus Worksheet для заполнения таблиц данными (по 3-5 записей).
4. Научиться создавать последовательности и соединять их с полями
таблиц.
5. Выполнить задания по вариантам.
Пояснения к выполнению работы
На примере созданного табличного пространства, таблиц и пользователя продолжим выполнение работы.
Для заполнения таблиц данными можно воспользоваться несколькими
способами:
1) Заполнение таблиц непосредственно через утилиту Enterprise
Manager Console.
21
2) Заполнение с помощью программного кода через утилиту SQL
*Plus Worksheet.
3) Заполнение данными через интерфейс внешнего приложения или
клиентского приложения, например, создав приложение в MS
Access, Borland Delphi, PHP и т.д.
Рассмотрим каждый пример заполнения.
В первом случае запускаем утилиту Enterprise Manager Console. Для
соединения с экземпляром БД Oracle выберите режим Launch standalone,
далее в появившемся окне дважды щелкните по экземпляру БД и воспользуйтесь учетной записью ADMIN_BOOKS с паролем worlds и уровнем
доступа SYSDBA.
В разделе Schema выбрать объекты типа Table, далее выбрать схему
пользователя ADMIN_BOOKS, далее в правой части экрана на соответствующей таблице в контекстном меню выбрать пункт Table data editor.
Далее можно заполнить таблицу необходимым количеством записей,
для сохранения изменений нажать Apply.
Формат ввода даты по умолчанию для операционной среды с русскими
настройками dd-Mon-yyyy, где Mon пишется первыми тремя буквами названия месяца по-русски.
Пример ввода представлен на рис. 2.1.
Рис. 2.1. Пример заполнения таблицы
В втором случае программного заполнения таблиц запускаем утилиту
SQL *Plus Worksheet. Для соединения с экемпляром БД Oracle выберите
режим Launch standalone, далее в появившемся окне дважды щелкните по
экземпляру БД и воспользуйтесь учетной записью ADMIN_BOOKS с паролем worlds и уровнем доступа SYSDBA.
INSERT INTO "ADMIN_BOOKS"."AUTHORS" ("CODE_AUTHOR",
"NAME_AUTHOR",
"BIRTHDAY")
VALUES
(3,
'Лермонтов',
TO_DATE('12-05-1810') );
Или в случае совпадения заполняемых значений с порядком столбцов в
таблице можно названия столбцов пропустить:
22
INSERT INTO "ADMIN_BOOKS"."AUTHORS"
'Лермонтов', TO_DATE('12-05-1810') );
VALUES
(4,
Последовательно наберите в SQL *Plus Worksheet операторы INSERT,
разделяя их точкой с запятой, а также используйте в конце оператор Commit для фиксации изменений в таблице.
Пример:
INSERT INTO authors VALUES(6, 'Гончаров', TO_DATE('12-031798','dd-mm-yyyy'));
--другие операторы INSERT;
COMMIT;
Для выполнения нажмите F5. Если нет ошибок, то на каждый оператор система в нижней половине экрана выдаст сообщение: «1 строка создана». На оператор Commit система выдаст сообщение: «Фиксация обновлений завершена».
Для просмотра результата заполнения можно воспользоваться оператором SELECT, например
SELECT * FROM "ADMIN_BOOKS"."AUTHORS";
или
SELECT * FROM ADMIN_BOOKS.AUTHORS;
В третьем случае заполнения таблиц через клиентское приложение
создадим соединение с объектами Oracle через ODBC драйвер. Для этого в
операционной среде через ПУСК зайти в Панель управления, далее в
разделе Производительность и обслуживание выбрать подраздел Администрирование, затем выбрать ссылку на утилиту Источники данных
(ODBC). Далее выбрать тип «Системный источник данных» (System Name
или System DSN), добавить новый источник данных, выбрав в появившемся списке драйверов Oracle. В следующем окне в качестве имени источника данных (Data Source Name) написать DB_BooksDSN, в поле TSN
Service Name указать название вашего экземпляра БД, в данном примере
это ORCL, в поле User ID указать ADMIN_BOOKS. Проверить соединение, нажав Test Connection. В случае успешной проверки сохранить результат.
Теперь можно подключаться к БД через любой интерфейс, рассмотрим
пример работы через MS Access.
Создадим новый проект БД в MS Access. В разделе Таблицы в контекстном меню необходимо выбрать Связь с таблицами. В появившемся окне в качестве типа файлов выбрать ODBC Databases. Далее на второй
вкладке Источники данных компьютера (Machine Source Name) выбрать
DB_BooksDSN. Далее в окне Oracle ODBC Driver Connect ввести пароль
23
доступа. При успешном прохождении аутентификации появится окно
Связь с таблицами, в котором необходимо выбрать пять таблиц из схемы
ADMIN_BOOKS. Если все выполено правильно, то результат будет таким,
как показано на рис. 2.2.
Рис. 2.2. Пример связи с таблицами Oracle в Access
Теперь можно создать формы ввода данных и приступить к заполнению таблиц. Например, для таблицы Книги можно создать следующую
форму (рис. 2.3).
24
Рис. 2.3. Пример созданных форм в Access для ввода данных в таблицы Oracle
Для контроля ввода значений в отдельные столбцы таблиц можно использовать специальные объекты Domain и Sequence.
Создание и использование последовательностей
Последовательность (SEQUENCE) – это объект, обеспечивающий генерацию уникальных последовательностей в условиях многопользовательского асинхиронного режима доступа.
Пример создания последовательности:
CREATE
SEQUENCE
"ADMIN_BOOKS"."ID_AUTHOR_SEQ"
INCREMENT BY 1 START WITH 1 MAXVALUE 99999 MINVALUE 1
NOCYCLE CACHE 20 NOORDER;
Для обращения к значениям последовательности используют следующие операторы:
sequence_name.CURRVAL
sequence_name.NEXTVAL
Пример использования последовательности:
INSERT INTO "ADMIN_BOOKS"."AUTHORS" ("CODE_AUTHOR",
"NAME_AUTHOR",
"BIRTHDAY")
VALUES
(ADMIN_BOOKS.ID_AUTHOR_SEQ.NextVal, 'Лермонтов', TO_DATE('1205-1810') );
Варианты заданий к лабораторной работе No2
В утилите SQL *Plus Worksheet по вашим вариантам баз данных, которые были реализованы в лабораторной работе No1, создать для полей типа Primary Key последовательности c помощью оператора CREATE
SEQUENCE.
В утилите SQL *Plus Worksheet создать файл, в котором написать последовательность операторов Insert для заполнения таблиц данными (по
10 операторов на каждую из таблиц).
Сохранить все операторы CREATE SEQUENCE и INSERT в файле
программы с названием ФамилияСтудента_ЛАб_2_Noварианта.
25
Лабораторная работа No3
УПРАВЛЕНИЕ ПРАВАМИ ДОСТУПА И РАЗРЕШЕНИЯМИ
К СОЗДАВАЕМЫМ ОБЪЕКТАМ БД В ORACLE 9i
Цель работы – научиться создавать профили пользователей и ролей для
разграничения прав доступа к объектам создаваемой БД, а также извлекать
системную информацию о пользоватях и объектах для последующего использования в удаленном управлении правми доступа к объектам экземпляра БД.
Содержание работы:
1. Познакомиться с назначением системных таблиц и представлений,
выполнить примеры.
2. С помощью операторов и действий, описанных в лабораторной работе, создать роли и пользователей.
3. Выполнить самостоятельное задание к лабораторной работе по вариантам.
Пояснения к выполнению работы
Инсталляция сервера заканчивается созданием начального экземпляра
БД и набором встроенных ролей и пользователей, из всех пользователей
незаблокированными
являются
SYSTEM
(manager)
и
SYS
(change_in_install), которые могут выполнять административные функции.
Для анализа ролей, системных привилегий и привилегий по доступу к
объектам экземпляра БД, которыми наделены пользователи, необходимо
зайти в утилите Enterprise Manager Console в раздел Security – Users и
дважды щелкнуть по имени пользователя.
Для обеспечения безопасности работы экземпляра БД необходимо после инсталляции программного продукта проверить состав пользователей
и их статус (в утилите Enterprise Manager Console в раздел Security –
Users в правой части экрана колонка Account Status). Если необходимо
заблокировать какого-либо пользователя, то выберите его двойным щелчком, в появившемся окне в разделе Status выбрать режим Locked.
В табличном пространстве SYSTEM в схеме SYS хранятся таблицы, из
которых можно извлечь информацию о правах доступа к системе, а также
о структуре объектов. Такая информация полезна для выполнения функций администрирования удаленно или через внешнее приложение. В табл.
3.1 дан краткий список объектов, которые используются в данной работе.
26
Таблица 3.1
Описание системных таблиц и представлений
Объект схемы SYS
User$
Тип
объекта
Table
Sysauth$
Table
System_privilege_map Table
Table_privilege_map Table
Dba_role_privs View
Dba_sys_privs View
Sys.obj$ Table
ALL_ALL_TABLES View
DBA_USERS View
Назначение
Справочник пользователей, объявленных в экземпляре БД
Список назначенных привилегий пользователям
Справочник системных привилегий, которые
могут быть использованы
Справочник привилегий доступа к объектам,
которые могут быть использованы
Представление привилегий созданных ролей,
которые могут быть использованы
Представление системных привилегий, которые
могут быть использованы
Справочник объектов, существующих в экземпляре БД
Представление c описанием всех таблиц, которые могут быть использованы
Представление со списком пользователей, которые могут быть использованы
Для просмотра информации о пользователе можно воспользоваться
оператором:
SELECT username, user_id, password, account_status, default_tablespace,
temporary_tablespace, profile
FROM dba_users
WHERE username = 'SYSTEM';
Следующий пример позволяет определить список привилегий на работу с объектами:
SELECT sysauth$.*, table_privilege_map.name, user$.name
FROM sysauth$,table_privilege_map, user$
WHERE sysauth$.grantee#=user$.user# and
table_privilege_map.privilege = sysauth$.privilege# and
user$.name='ADMIN_BOOKS';
или, используя представление SYS.dba_sys_privs:
SELECT * FROM sys.dba_sys_privs WHERE grantee='ADMIN_BOOKS';
Следующий пример позволяет определить список системных привилегий введенного пользователя:
SELECT sysauth$.*, system_privilege_map.name, user$.name
FROM sysauth$, system_privilege_map, user$
27
WHERE sysauth$.grantee#=user$.user# and
system_privilege_map.privilege = sysauth$.privilege# and
user$.name='ADMIN_BOOKS';
Следующий пример позволяет определить список присвоенных ролей
введенного пользователя:
SELECT * FROM dba_role_privs WHERE grantee = 'ADMIN_BOOKS';
Результат:
GRANTEE
----------------------ADMIN_BOOKS
ADMIN_BOOKS
ADMIN_BOOKS
GRANTED_ROLE
-----------------------------CONNECT
DBA
EXP_FULL_DATABASE
ADM
--YES
YES
YES
DEF
--YES
YES
YES
Для определения списка таблиц, собственником которых является конкретный пользователь, необходимо выполнить следующий SQL запрос:
SELECT
table_name
FROM
all_all_tables
WHERE
owner
=
'ADMIN_BOOKS';
Результат:
TABLE_NAME
-----------------------------AUTHORS
BOOKS
DELIVERIES
PUBLISHING_HOUSE
PURCHASES
Для прямого получения информации о пользователе можно обратиться
к системной таблице SYS.USER$, например:
SELECT * FROM sys.user$ WHERE name = 'ADMIN_BOOKS';
Например, необходимо определить список всех объектов пользователя,
собственником которых он является, для этого:
Определим код пользователя (колонка USER# в таблице SYS.USER$):
SELECT user#, name FROM sys.user$ WHERE name = 'ADMIN_BOOKS';
Результат:
USER# NAME
---------- -----------------------------67 ADMIN_BOOKS
Далее определим перечень объектов, собственником которых является
пользователь:
SELECT OBJ#, NAME FROM SYS.OBJ$ WHERE OWNER# = 67;
где 67 – идентификатор пользователя ADMIN_BOOKS, определенный по
предыдущему запросу.
28
Результат:
OBJ#
---------32127
32135
32177
32162
32157
32161
32159
32160
32166
32129
32128
32136
32147
32130
32132
32138
32131
32137
32165
32167
NAME
-----------------------------AUTHORS
BOOKS
BOOKS_ALL
CHECKNAME
COUNT_BOOKS
COUNT_BOOKS_ITOGO
COUNT_BOOKS_PAGES
COUNT_BOOKS_TITLE
COUNT_PURCHASES
DELIVERIES
ID_AUTHOR
ID_BOOK1
ID_BOOK_SEQ
ID_DELIVERY
ID_PUBLISH
ID_PURCHASE
PUBLISHING_HOUSE
PURCHASES
UPDATE_PROC
UPDATE_PROC2
20 строк выбрано.
Можно просмотреть состав каждого объекта-таблицы, например таблицы
AUTHORS, используя ее идентификационный номер, который определили
в предыдущем запросе:
SELECT name, type# FROM sys.col$ WHERE obj# = '32127';
Результат:
NAME
TYPE#
------------------------------ ---------CODE_AUTHOR
2
NAME_AUTHOR
96
BIRTHDAY
12
SYS_C00004_07073100:07:39$
1
или, используя имя объекта:
SELECT c.name, c.type# FROM sys.col$ c INNER JOIN sys.obj$ o ON
c.obj#= o.obj# WHERE o.name = 'AUTHORS';
Создание ролей
Для упрощения управления правами доступа в системе создаются роли, которые затем можно назначать группе пользователей.
Создадим для нашего примера роли библиотекаря (LIBRAR) и читателя (READER).
29
Пример создания роли библиотекаря:
CREATE ROLE "LIBRAR" IDENTIFIED BY "LIBRAR";
Пример создания роли читателя:
CREATE ROLE "READER" IDENTIFIED BY "READER";
Библиотекарь должен обладать правами на чтение, удаление, изменение, добавление во все таблицы схемы ADMIN_BOOKS, а также должен
иметь возможность инициировать сессию и запускать на исполнение процедуры и функции схемы ADMIN_BOOKS. Поэтому роли библиотекаря из
системных привилегий назначаем CREATE SESSION, а из привилегий
доступа к объектам назначаем DELETE, INSERT, UPDATE, SELECT, позже в лабораторной работе No5 для созданных процедур и функций добавить EXECUTE.
Читатель должен обладать правами на чтение из таблиц
ADMIN_BOOKS.AUTHORS,
ADMIN_BOOKS.BOOKS,
ADMIN_BOOKS.PUBLISHING_HOUSE, а также должен иметь возможность инициировать сессию и запускать на исполнение процедуры и
функции схемы ADMIN_BOOKS. Поэтому роли читателя из системных
привилегий назначаем CREATE SESSION, а из привилегий доступа к объектам назначаем SELECT, позже в лабораторной работе No5 для созданных процедур и функций добавить EXECUTE.
Оператор представления привилегий
Синтаксис:
GRANT <привилегия>, ...
ON < объект >, ...
TO <имя>
[WITH grant option];
Атрибут with grant option дает право пользователю самому раздавать
права, которые он получил.
С помощью оператора grant для каждого пользователя формируется
список привилегий, привилегии управляют работой сервера данных с точки зрения защиты данных. Выполнению каждой транзакции предшествует
проверка привилегий пользователя, сеанс которого породил транзакцию.
Пример: grant select, update (Sales, num) ON Sales_data TO user1
with grant option;
Пользователь, предоставивший привилегию другому, называется грантор (grantor — предоставитель). Привилегия является предоставляемой,
если право на нее можно предоставить другим пользователям.
30
PUBLIC — имя пользователя, который распространяет привилегии на
все множество зарегистрированных в системе пользователей.
Роль библиотекаря названа LIBRAR с аналогичным паролем LIBRAR.
Операторы назначения прав доступа ниже:
GRANT DELETE, INSERT, UPDATE, SELECT
ON "ADMIN_BOOKS"."BOOKS" TO "LIBRAR";
GRANT DELETE, INSERT, UPDATE, SELECT
ON "ADMIN_BOOKS"."AUTHORS" TO "LIBRAR";
GRANT DELETE, INSERT, UPDATE, SELECT
ON "ADMIN_BOOKS"."DELIVERIES" TO "LIBRAR";
GRANT DELETE, INSERT, UPDATE, SELECT
ON "ADMIN_BOOKS"."PUBLISHING_HOUSE" TO "LIBRAR";
GRANT DELETE, INSERT, UPDATE, SELECT
ON "ADMIN_BOOKS"."PURCHASES" TO "LIBRAR";
GRANT CREATE SESSION TO "LIBRAR";
Commit;
Роль читателя названа READER с аналогичным паролем READER. Операторы назначения прав доступа ниже:
GRANT SELECT ON "ADMIN_BOOKS"."BOOKS" TO "READER";
GRANT SELECT ON "ADMIN_BOOKS"."AUTHORS" TO "READER";
GRANT SELECT ON "ADMIN_BOOKS"."PUBLISHING_HOUSE" TO
"READER";
GRANT CREATE SESSION TO "READER";
Commit;
Создание пользователей с определенной ролью
Пример создания библиотекаря Ivanov_Lib и присвоения роли:
CREATE USER "Ivanov_Lib"
PROFILE "DEFAULT"
IDENTIFIED BY "Ivanov_Lib" DEFAULT TABLESPACE "DB_BOOKS"
TEMPORARY TABLESPACE "TEMP" ACCOUNT UNLOCK;
GRANT "LIBRAR" TO "Ivanov_Lib";
Commit;
Пример создания читателя Petrov_Read и присвоения роли:
CREATE USER "Petrov_Read"
PROFILE "DEFAULT"
IDENTIFIED BY "Petrov_Read"
DEFAULT TABLESPACE "DB_BOOKS"
31
TEMPORARY TABLESPACE "TEMP"
ACCOUNT UNLOCK;
GRANT "READER" TO "Petrov_Read";
Commit;
Управление паролями
Если система управления паролями доступна, то пользователи не могут
изменить пароли командой ALTER USER. Пользователь должен изменять
пароли, используя SQL*Plus или OCIPasswordChange, в которых принимаются в качестве параметров старый и новый пароли.
Оператор отмены привилегий
Синтаксис отмены привилегий:
REVOKE [with grant option]
< привилегии >,...
ON < объект >,...
FROM <имя_пользователя>;
Предложение with grant option сохраняет за пользователем перечисленные привилегии, но отменяет его право передавать их кому-либо другому.
Пример:
REVOKE SELECT ON "ADMIN_BOOKS"."AUTHORS" FROM "READER";
Оператор изымания роли у пользователя:
Revoke <список ролей> from <список пользователей>.
Пример:
REVOKE READER FROM "Petrov_Read";
Варианты заданий к лабораторной работе No3
Общие положения
В утилите SQL *Plus Worksheet выполнить примеры, которые даны по
ходу работы.
По индивидуальному варианту базы данных, которая выполнена в лабораторной работе No1, определить 2-3 должностных лица, которые могут
работать с таблицами БД. Для каждого должностного лица определить набор привилегий, которыми он может пользоваться.
В утилите SQL *Plus Worksheet создать под каждое должностное лицо
соответствующую роль, наделить эту роль определенными привилегиями.
Далее создать по одному пользователю на каждую должность и присвоить
им соответствующие роли.
32
Сохранить последовательно операторы с указанием заданий в файле с
названием ФамилияСтудента_ЛАб_3_Noварианта_общее, результаты
выполнения задания по варианту сохранить в файле ФамилияСтудента_ЛАб_3_результаты. Операторы создания ролей, привилегий и пользователей сохранить в файле с названием ФамилияСтудента_ЛАб_3_Noварианта_роли.
Лабораторная работа No4
ОСВОЕНИЕ ПРОГРАММИРОВАНИЯ С ПОМОЩЬЮ
ВСТРОЕННОГО ЯЗЫКА PL/SQL В ORACLE
Цель работы – знакомство с основными принципами программирования в
ORACLE средствами встроенного языка PL/SQL.
Содержание работы:
1. Знакомство с правилами обозначения синтаксиса команд в справочной системе ORACLE (утилита SQL *Plus WorkSheet).
2. Изучение правил написания программ на PL/SQL.
3. Изучение правил построения идентификаторов, правил объявления
переменных и их типов.
4. Изучение работы с циклами и ветвлениями.
5. Изучение работы с переменными типа Table, Record и Cursor.
6. Проработка всех примеров, анализ результатов их выполнения в
утилите SQL *Plus WorkSheet.
7. Выполнение индивидуальных заданий по вариантам.
Пояснения к выполнению работы
Для освоения программирования используем пример базы данных в
табличном пространстве DB_Books, которая была создана в лабораторной
работе No1. При выполнении примеров и заданий обращайте внимание на
соответствие названий БД, таблиц и других объектов проекта.
Описание языка PL/SQL
Программа на PL/SQL состоит из трех блоков: блок описаний переменных, констант и пользовательские типы данных; исполнительный блок;
блок обработки исключительных ситуаций. Специальные знаки и простейшие операторы языка PL/SQL приведены в табл. 4.1.
Структура программы
SET -- настройки окружения сервера;
DECLARE --объявление переменных;
33
BEGIN
--Операторы или NULL;
EXCEPTION
--Операторы обработки исключительных ситуаций;
END;
Таблица 4.1
Специальные знаки и простейшие операторы в PL/SQL
Знак Назначение Знак
    * Знак умножения ""
- Знак вычитания ‘ ’
** <>
+ REM
= Возведение в степень !<
<= Знак сложения или конкатена- !>
>= ции (объединение двух строк в >
!= одну) <
|| Знак равенства или сравнения .
                            Меньше или равно 
                                          Больше или равно 
                                                        Не равно 
                                                               Оператор конкатенации 
:= Знак присвоения /
-- Однострочный комментарий /* */
                          или комментарий с текущей 
                                                позиции и до конца строки 
Назначение
В них заключают названия объектов, например таблиц, столбцов и т.п.
В них заключают строковые значения
Не равно
Однострочный комментарий, начинающийся после REM
Не менее чем
Не более чем
Больше
Меньше
Разделяет родительские и подчиненные объекты
Знак деления.
При установке в начале строкизнак завершения текста процедуры и команда к интерпретации и
выполнению процедуры в SQL
*Plus
Многострочный комментарий
Идентификаторы
Идентификаторы – это имена объектов, на которые можно ссылаться
в программе, написанной на языке PL/SQL. Первый символ может состоять из букв английского алфавита, внутри может содержать цифры или
“_”, “#”, «$». Имя идентификатора не должно совпадать с зарезервированным словом. Регистр для идентификаторов не важен, длина его не должна
превышать 30 символов.
Примеры правильных идентификаторов:
t2
phone#
credit_limit
34
LastName
oracle$number
Примеры ошибочных идентификаторов:
mine&yours
--не разрешен из-за знака &
debit-amount
--не разрешен из-за знака –
on/off
--не разрешен из-за знака /
user id
--не разрешен из-за пробела
Кавычки и идентификаторы
Если необходимо в идентификаторах использовать специальные символы или пробел, то нужно заключать их в кавычки.
Примеры идентификаторов, которые пишутся в кавычках:
"X+Y"
"last name"
"on/off switch"
"employee(s)"
"*** header info ***"
Объявление переменных и констант
DECLARE – используется для определения начала блока объявления
переменных, констант и пользовательских типов данных, пишется один
раз для всего блока. Типы переменных представлены в табл. 4.2.
CONSTANT – переменная с заданным значением, которое нельзя изменить в теле программы.
Синтаксис для объявления константы:
имя_переменной1 CONSTANT тип_переменной:= значение_переменной1;
Синтаксис для объявления переменных:
имя_переменной1 тип_переменной; ...;
имя_переменнойN тип_переменной;
Если тип переменной предполагает указание длины, то используется
следующий синтаксис для объявления переменных:
имя_переменной1 тип_переменной (длина);
имя_переменнойN тип_переменной(длина);
Пример простейшей программы:
declare
perem1 numeric(10,0);
perem2 varchar(15);
const1 char(10):= 'Привет!';
35
begin
perem1:=12*2;
end;
Использование значений по умолчанию (DEFAULT)
DEFAULT используется для переменных, у которых есть типичное значение. Этот оператор можно использовать для объявления параметров подпрограмм, параметров курсора, а также для значения полей пользовательского типа записи.
Пример:
SET SERVEROUTPUT ON
DECLARE
hours_worked INTEGER DEFAULT 40;
employee_count INTEGER := 0;
BEGIN
DBMS_OUTPUT.PUT_LINE(hours_worked);
DBMS_OUTPUT.PUT_LINE(employee_count);
END;
Присвоение значений переменным и вывод значений на экран
Присвоение значений переменным и константам осуществляется посредством знака :=.
Вывод значения на экран реализуется с помощью системной процедуры
DBMS_OUTPUT.PUT_LINE(имя переменной) при включенной настройке SET SERVEROUTPUT ON.
Все системные процедуры можно увидеть в справочной системе Oracle
в разделе «PL/SQL Packages and Types Reference» по адресу:
http://www.oracle.com/pls/db102/to_toc?pathname=appdev.102%2Fb1425
8%2Ftoc.htm&remark=portal+%28Books%29
или в формате PDF:
http://www.oracle.com/pls/db102/to_pdf?pathname=appdev.102%2Fb1425
8.pdf&remark=portal+%28Books%29
Пример:
SET SERVEROUTPUT ON
declare
perem1 numeric(10,0);
perem2 varchar(15);
const1 char(10):= 'Привет!';
begin
perem1:=12**2;
DBMS_OUTPUT.PUT_LINE(perem1);
end;
36
Передача в строку апострофов
При необходимости в одну строку записать другую в апострофах используют два напечатанных подряд апострофа. Например, комбинация
'а''а' будет принята системой как строка: а'а.
Пример:
SET SERVEROUTPUT ON
BEGIN
DBMS_OUTPUT.PUT_LINE('DELETE FROM Authors ' ||
' WHERE Name_author = ''' || 'Пушкин А.С.' || ''' ');
END;
Таблица 4.2
Типы переменных в PL/SQL
Тип данных
1
BINARY_INT
EGER,
PLS_INTEGE
R
Подтипы
BINARY_INT
EGER:
NATURAL
NATURALN
POSITIVE
POSITIVEN
SIGNTYPE
BOOLEAN
VARCHAR2
NUMBER
Максимальный размер
2
-2147483648
до
2147483647
Описание
3
Длинное целое
Подтипы бинарного целого NATURAL and
POSITIVE позволяют запретить все числа, кроме позитивных. NATURALN and POSITIVEN запрещают
значения типа NULL. SIGNTYPE запрещает все числа, кроме -1, 0, and 1
TRUE, FALSE Логический тип
или NULL
32767
Символьная строка переменной длины, без указания
размера ее длина равна 1
Абсолютное
Число, поддерживающее режимы фиксированной
значение в
точки и плавающей точки. Масштаб, указанный с
диапазоне
минусом, указывает на округление целой части.
(1E-130,
Масштаб со знаком плюс или без него обозначает ок1.0E126)
ругление до указанного количества знаков дробной
части. NUMBER(точность, масштаб)
37
Окончание табл. 4.2
1
Подтипы
NUMBER:
DEC
DECIMAL
DOUBLE
PRECISION
FLOAT
INT
INTEGER
NUMERIC
REAL
SMALLINT
CHAR
CHARACTER
LONG
2
32767 байт
32760 байт
LONG RAW
NCHAR
32767 байта
NVARCHAR2 32767 байта
BFILE до 4ГБ - 1
         байт
BLOB от 8 до 128
CLOB терабайт
NCLOB 
Date 
от 01.01.4712
до н.э.
до 01.01.4712
н.э.
3
DEC, DECIMAL и NUMERIC – типы чисел с фиксированной точкой при максимальной точности до 38
десятичных цифр.
DOUBLE PRECISION и FLOAT – типы чисел с плавающей точкой при максимальной точности до 126
двоичных цифр или округленно до 38 десятичных
цифр.
REAL – тип числа с плавающей точкой при максимальной точности до 63 двоичных цифр или округленно до 18 десятичных цифр.
INTEGER, INT и SMALLINT – целочисленные типы
с максимальной точностью до 38 десятичных цифр
Строка фиксированной длины
LONG может хранить текст, массивы символов или
небольшие по объему документы. Поля с типом
LONG могут участвовать в операциях UPDATE,
INSERT и в большинстве SELECT, кроме выражений
вызываемых параметров функций SQL, а также в таких конструктах SQL, как WHERE, GROUP BY,
и CONNECT BY
В современных приложениях используйте CLOB или
NCLOB вместо LONG, а также BLOB или BFILE
вместо LONG RAW
Статичная символьная строка в формате Unicode,
максимальная длина которой будет равна 32767/2 в
кодировке AL16UTF16 или 32767/3 в кодировке
UTF8
Тип NVARCHAR2 может быть использован для хранения символьных строк переменной длины в формате Unicode. Максимальные размеры строки данного
типа определяются как и у NCHAR
LOB (большой объект) с типами BFILE, BLOB,
CLOB и NCLOB позволяет хранить блоки неструктурированных данных, таких как текст, изображения,
видео клипы и звуки.
Размер типа BFILE зависит от системы, но не может
превышать 4ГБ - 1 байт
Дата и время. Для присвоения даты используется
функция TO_DATE(‘символьная дата’, ‘формат даты’)
Пример использования подтипов длинного целого:
SET SERVEROUTPUT ON
declare
38
i NATURAL; q NATURALN:=9; w POSITIVE:=2;
e POSITIVEN:=8; r SIGNTYPE:=0;
begin
i:=1;
DBMS_OUTPUT.PUT_LINE('i='||i||',q=' || q || ',w=' || w || ',e=' || e || ',r=' || r);
end;
Пример присвоения значений переменной с типом NUMBER:
DECLARE
n NUMBER;
BEGIN
n := -9.999999E-130; -- правильно
n := 9.999E125;
-- правильно
-- n := 10.0E125;
-- неправильно, превышение разрядной сетки
END;
Преобразование типов переменных
В табл. 4.3 представлены основные функции по преобразованию типов
переменных, кроме описанных существуют еще такие функции, как
TO_SINGLE_BYTE,
TO_MULTI_BYTE,
TO_BLOB,
TO_CLOB,
TO_NCLOB, с которыми можно ознакомиться дополнительно.
Таблица 4.3
Краткий обзор функций преобразования типов переменных
Название
функции
1
CHARTOROWID
HEXTORAW
RAWTOHEX
RAWTONHEX
ROWIDTOCHAR
Пояснения и пример использования
2
Функция конвертирует символьную строку с данными, соответствующими ROWID, в тип rowid
SET SERVEROUTPUT ON
DECLARE
n raw(10):='123da12';
BEGIN
DBMS_OUTPUT.PUT_LINE( HEXTORAW(n) );
DBMS_OUTPUT.PUT_LINE( RAWTOHEX(n) );
END;
SET SERVEROUTPUT ON
DECLARE
n ROWID:='123da12sss';
BEGIN
DBMS_OUTPUT.PUT_LINE( ROWIDTOCHAR(n) );
END;
39
Окончание табл. 4.3
1
TO_CHAR
TO_NCHAR
TO_DATE
TO_NUMBER
2
SET SERVEROUTPUT ON
DECLARE
n integer:=1009;
ch char(5);
ch1 nchar(5);
BEGIN
ch:=TO_CHAR(n);
ch1:=TO_NCHAR(n);
DBMS_OUTPUT.PUT_LINE( ch );
DBMS_OUTPUT.PUT_LINE( ch1 );
DBMS_OUTPUT.PUT_LINE(TO_CHAR(SYSDATE,'SSSSS'));
END;
SET SERVEROUTPUT ON
DECLARE
ch char(11):='21-дек-1980';
ch1 char(11):='05-30-1990';
BEGIN
DBMS_OUTPUT.PUT_LINE(TO_DATE(ch, 'dd-mon-yyyy'));
DBMS_OUTPUT.PUT_LINE(TO_DATE(ch1, 'mm-ddyyyy'));
END;
SET SERVEROUTPUT ON
DECLARE
n int:=1029; num number(4,0); num1 number(4,-1);
BEGIN
num:=TO_NUMBER(n); num1:=TO_NUMBER(n);
DBMS_OUTPUT.PUT_LINE(num);
DBMS_OUTPUT.PUT_LINE(num1);
END;
Операторские скобки
BEGIN
/* Операторские скобки должны содержать хотя бы один оператор.
Требуются для конструкций поливариантных ветвлений, условных и циклических конструкций.
*/
END;
Оператор ветвления IF
Синтаксис:
IF условие_1 THEN
Операторы;
ELSIF условие_2 THEN
Операторы;
40
ELSIF условие_3 THEN
...
ELSE
Операторы;
END IF
Пример ветвления:
SET SERVEROUTPUT ON
DECLARE
n NUMBER;
BEGIN
n := DBMS_RANDOM.RANDOM;
IF n<10 THEN
DBMS_OUTPUT.PUT_LINE('n=' || n || '; N<10');
ELSIF n=10 THEN
DBMS_OUTPUT.PUT_LINE('n=' || n || '; N=10');
ELSE
DBMS_OUTPUT.PUT_LINE('n=' || n || '; N>10');
END IF;
END;
Ветвление CASE
Синтаксис:
имя_переменной_метки:=
CASE
WHEN условие1 THEN
значение1
WHEN условие2 THEN
значение2
WHEN условие3 THEN
значение3
...
ELSE
значениеN
END;
или
CASE
WHEN условие1 THEN
операторы;
WHEN условие2 THEN
операторы;
WHEN условие3 THEN
41
операторы;
...
ELSE
операторы;
END CASE;
Пример ветвления:
SET SERVEROUTPUT ON
DECLARE
n NUMBER;
BEGIN
n := DBMS_RANDOM.RANDOM;
CASE
WHEN n<10 THEN
DBMS_OUTPUT.PUT_LINE('n=' || n || '; N<10');
WHEN n=10 THEN
DBMS_OUTPUT.PUT_LINE('n=' || n || '; N=10');
ELSE
DBMS_OUTPUT.PUT_LINE('n=' || n || '; N>10');
END CASE;
END;
Пример ветвления:
SET SERVEROUTPUT ON
DECLARE
n NUMBER;
ch char(15);
BEGIN
ch :=
CASE
WHEN n<10 THEN
'n=' || n || '; N<10'
WHEN n=10 THEN
'n=' || n || '; N=10'
ELSE
'n=' || n || '; N>10'
END;
DBMS_OUTPUT.PUT_LINE(ch);
END;
Цикл WHILE
Синтаксис:
WHILE Условие LOOP
Операторы;
END LOOP;
42
Цикл выполняется до тех пор, пока условие будет истинно. Для выхода
из цикла по дополнительному условию можно использовать EXIT.
Пример цикла WHILE:
SET SERVEROUTPUT ON
DECLARE a INT;
begin
a := 1;
WHILE a <100 loop
IF (a>40) AND (a<50) THEN
exit; --выход и выполнение 1-й команды за циклом
ELSE
a := a+10;
DBMS_OUTPUT.PUT_LINE('в цикле а=' || a);
END IF;
END LOOP;
DBMS_OUTPUT.PUT_LINE('после цикла а=' || a);
end;
Цикл LOOP
Синтаксис:
LOOP
EXIT WHEN условие_станет_истинно;
Операторы;
END LOOP;
Цикл выполняется до тех пор, пока условие не приняло истинного значения. Для выхода из цикла по дополнительному условию можно использовать EXIT.
Пример цикла LOOP:
SET SERVEROUTPUT ON
DECLARE a INT;
begin
a := 1;
LOOP
EXIT WHEN a >100;
IF (a>40) AND (a<50) THEN
exit; --выход и выполнение 1-й команды за циклом
ELSE
a := a+10;
DBMS_OUTPUT.PUT_LINE('в цикле а=' || a);
END IF;
43
END LOOP;
DBMS_OUTPUT.PUT_LINE('после цикла а=' || a);
end;
Цикл FOR
Цикл, управляемым оператором FOR, используется в том случае, когда
точно известно, сколько раз нужно выполнять итерацию цикла.
Синтаксис:
FOR переменная_счетчик IN старт_значение .. конеч_значение LOOP
Операторы;
END LOOP;
Цикл выполняется до тех пор, пока переменная не приняла поочередно
с шагом по умолчанию 1 от стартового значения до конечного значения.
Для выхода из цикла по дополнительному условию можно использовать
EXIT.
Пример цикла FOR:
SET SERVEROUTPUT ON
DECLARE
end_ INT:=20;
begin_ INT:=1;
Factorial NUMBER:=1;
begin
FOR I IN begin_ .. end_ LOOP
Factorial:= Factorial*I;
END LOOP;
DBMS_OUTPUT.PUT_LINE(factorial);
end;
Передача данных из запроса в переменную
Для этого необходимо предварительно объявить переменную, в которую поместим результат запроса, далее в операторе SELECT используем
конструкцию INTO с указанием имени объявленной переменной:
SET SERVEROUTPUT ON
DECLARE
Itogo INT;
begin
SELECT COUNT(Code_author) INTO Itogo FROM
ADMIN_BOOKS.Authors;
DBMS_OUTPUT.PUT_LINE(Itogo);
end;
44
Объявление курсора и работа с ним
Курсором называют переменную, объявляемую в приложении и содержащую отклик на запрос. Курсор является интерфейсом, который передает для пользователя информацию из базы данных.
Синтаксис:
CURSOR имя_курсора IS оператор SELECT;
Курсор, являясь внутренней переменной модуля, должен быть открыт с
помощью оператора:
OPEN имя_курсора;
Курсор, являясь внутренней переменной модуля, должен быть закрыт с
помощью оператора:
CLOSE имя_курсора;
Выборка данных из курсора может быть выполнена в набор переменных подходящих типов или в переменную типа RECORD с помощью оператора:
FETCH имя_курсора INTO переменные_через_запятую;
или
FETCH имя_курсора INTO имя_переменной_типа_RECORD;
При работе с курсором можно воспользоваться предопределенными
атрибутами, которые представлены в табл. 4.4. Кроме того, при работе с
курсором могут потребоваться атрибуты для объявления пользовательской
записи и поля (табл. 4.5).
Таблица 4.4
Список атрибутов, используемых совместно с курсором
Имя атрибута
1
%FOUND
%NOTFOUND
Назначение
2
После открытия курсора, но
до первого использования
оператора FETCH этот атрибут содержит NULL. После любого перемещения по
курсору будет TRUE, если
последний FETCH вернул
запись, FALSE - последний
FETCH не нашел запись в
курсоре
Атрибут, логически противоположный %FOUND
45
Образец фрагмента программы
3
...
OPEN имя_курсора;
FETCH имя_курсора INTO имя_записи;
IF имя_курсора%FOUND THEN
...
ELSE
...
1
%ISOPEN
2
Атрибут возвращает TRUE,
если курсор открыт с помощью оператора OPEN,
иначе FALSE
Окончание табл. 4.4
3
...
IF имя_курсора%ISOPEN =FALSE
THEN
OPEN c1;
END IF;
FETCH имя_курсора INTO имя_записи;
...
CLOSE имя_курсора;
%ROWCOUNT После открытия курсора, но
до первого использования
оператора FETCH этот атрибут содержит 0. По мере
перемещения по курсору на
запись значение атрибута
увеличивается на 1
Таблица 4.5
Атрибуты, используемые при объявлении переменных
Название
Назначение
Пример объявления
атрибута
%ROWTYPE Позволяет DECLARE
создать пе- Row1 ADMIN_BOOKS.AUTHORS%ROWTYPE;
ременную
/*объявлена переменная типа записи таблицы
со всеми
ADMIN_BOOKS.AUTHORS*/
свойсвами begin
NULL;
записи указанной таб- end;
лицы
%TYPE
Позволяет DECLARE
создать пе- COLUMN1
ременную
ADMIN_BOOKS.AUTHORS.NAME_AUTHOR%TYPE;
со всеми
/*объявлена переменная COLUMN1 со свойствами
свойствами столбца NAME_AUTHOR таблицы
столбца
ADMIN_BOOKS.AUTHORS*/
указанной
begin
таблицы
NULL;
end;
Пример объявления курсора по таблице Авторы:
DECLARE
my_id_author NUMBER(3); -- переменная для значения Code_author
my_Name_author CHAR(30); -- переменная для значения Name_author
my_Birthday DATE; -- переменная для значения Birthday
CURSOR c1 IS SELECT * FROM ADMIN_BOOKS.Authors
46
WHERE Code_author > 20;
Пример объявления курсора с выбором автора и одновременным помещением результата в переменную:
DECLARE
my_authors ADMIN_BOOKS.Authors%ROWTYPE;
CURSOR c2 RETURN ADMIN_BOOKS.Authors%ROWTYPE IS
SELECT * FROM ADMIN_BOOKS.Authors WHERE Code_author = 20;
Пример объявления курсора с использованием полей со значениями
по умолчанию:
DECLARE
CURSOR c3 (low NUMBER(3) DEFAULT 0, high NUMBER(3) DEFAULT
105) IS SELECT * FROM ADMIN_BOOKS.Authors WHERE Code_author>
low AND Code_author< high;
Пример работы курсора с циклом LOOP:
SET SERVEROUTPUT ON
DECLARE
CURSOR c1 IS SELECT Publish, Code_publish FROM
ADMIN_BOOKS.Publishing_house WHERE Code_publish<11;
name1 ADMIN_BOOKS.Publishing_house.Publish %TYPE;
code1 ADMIN_BOOKS.Publishing_house.Code_publish%TYPE;
BEGIN
OPEN c1;
LOOP
FETCH c1 INTO name1, code1;
EXIT WHEN c1%NOTFOUND OR c1%NOTFOUND IS NULL;
DBMS_OUTPUT.PUT_LINE(c1%ROWCOUNT || '. ' || name1);
IF c1%ROWCOUNT = 5 THEN
DBMS_OUTPUT.PUT_LINE('--- 5-я запись ---');
END IF;
END LOOP;
CLOSE c1;
END;
Пример работы курсора с циклом WHILE:
SET SERVEROUTPUT ON
DECLARE
name2 ADMIN_BOOKS.Authors.Name_author %TYPE;
CURSOR authors_desc IS SELECT Name_author FROM
ADMIN_BOOKS.Authors ORDER BY Name_author DESC;
BEGIN
47
OPEN authors_desc;
FETCH authors_desc INTO name2;
DBMS_OUTPUT.PUT_LINE(name2);
WHILE authors_desc%found LOOP
FETCH authors_desc INTO name2;
DBMS_OUTPUT.PUT_LINE(name2);
END LOOP;
CLOSE authors_desc;
END;
Пример работы с переменной типа Таблица
с заданным списком значений
SET SERVEROUTPUT ON
DECLARE
TYPE Author_list IS TABLE OF
ADMIN_BOOKS.Authors.code_author%TYPE;
Authors Author_list;
Name_author_ ADMIN_BOOKS.Authors.Name_author%TYPE;
Birthday_ ADMIN_BOOKS.Authors.Birthday%TYPE;
BEGIN
-- в перечне Author_list указываются реальные значения поля в таблице
Authors:= Author_list(1,2);
FOR i IN Authors.FIRST.. Authors.LAST LOOP
SELECT Name_author, Birthday INTO Name_author_, Birthday_ FROM
ADMIN_BOOKS.Authors WHERE ADMIN_BOOKS.Authors.Code_Author =
Authors(i);
DBMS_OUTPUT.PUT_LINE ( TO_CHAR(Authors(i)) || ': ' || Name_author_ ||
', ' || Birthday_ );
END LOOP;
END;
Пример работы с переменной типа Таблица
с перебором записей в заголовке цикла
SET SERVEROUTPUT ON
DECLARE
TYPE EmpTabTyp IS TABLE OF ADMIN_BOOKS.Authors%ROWTYPE;
emp_tab EmpTabTyp;
BEGIN
for emp_tab in (SELECT * FROM ADMIN_BOOKS.Authors) loop
DBMS_OUTPUT.PUT_LINE(emp_tab.code_author ||' '||
emp_tab.name_author ||' '||emp_tab.birthday);
end loop;
END;
48
Пример работы с переменной типа Запись через объявление типа
и через %ROWTYPE
DECLARE
Row1 ADMIN_BOOKS.AUTHORS%ROWTYPE;
TYPE TypeRec IS RECORD (minutes INTEGER, hours INTEGER);
TypeRec1 TypeRec;
/*объявлена переменная типа записи таблицы
ADMIN_BOOKS.AUTHORS*/
begin
row1.code_author:=2;
row1.name_author:='Лермонтов';
row1.birthday:=TO_DATE('21-12-1980', 'dd-mm-yyyy');
insert into ADMIN_BOOKS.AUTHORS values(row1.code_author,
row1.name_author, row1.birthday);
TypeRec1.minutes:=12;
TypeRec1.hours:=15;
end;
Пример передачи запроса в переменную типа Запись
SET SERVEROUTPUT ON
Declare
Someone ADMIN_BOOKS.Authors%rowtype;
BEGIN
FOR someone IN (SELECT * FROM ADMIN_BOOKS.Authors)
LOOP
DBMS_OUTPUT.PUT_LINE('Код автора = ' || someone.code_author ||
', Имя автора = ' || someone.name_author);
END LOOP;
End;
Использование функций для работы со строковыми переменными
В табл. 4.6 описаны основные функции для работы со строками.
Таблица 4.6
Краткий обзор строковых функций
Название функции
1
ASCII(строка)
Действие, выполняемое функцией
2
Возвращает десятичное представление первого символа строки согласно применяемому набору символов
CHR(число)
Возвращает символ, имеющий указанный в скобках
код из набора символов БД.
Например: Simb:= CHR(105);
CONCAT(строка1, строка2) Возвращает строку 1, сцепленную со строкой 2
49
Продолжение табл. 4.6
1
INITCAP(строка)
INSTR(строка исходная, строка искомая, [,стартовая
позиция a[, номер
вхождения b]])
LENGTH(строка)
LOWER(строка)
LPAD(строка 1,
длина, строка 2)
LTRIM(строка 1
[,строка 2])
NCHR(код)
REPLACE(строка_с
имволов, строка_поиска, [строка_замены])
RPAD(строка 1,
длина, строка 2)
RTRIM(строка 1,
строка 2)
SOUNDEX (строка)
TRIM(строка)
UPPER(строка)
2
Возвращает строку, в которой каждое слово начинается с
прописной буквы и продолжается строчными. Слова разделяются пробелами или небуквенно-цифровыми символами
Возвращает местоположение искомой строки в исходной
строке. Исходная строка просматривается слева, начиная со
стартовой позиции. Если стартовая позиция отрицательна,
то исходная строка просматривается справа. Возвращается
позиция, указывающая местоположение искомой строки с
указанным номером вхождения. Значением по умолчанию,
как для a, так и для b, является 1. Если строка искомая не найдена, возвращается 0
Возвращает размер строки в символах. Значения типа CHAR
дополняются пробелами,поэтому если строка имеет тип
CHAR, в размере указываются и конечные пробелы. Если
строка хранит NULL, то возвращается NULL
Переводит все символы строки в нижний регистр
Возвращает строку 1, дополненную слева до размера указанной длины символами строки 2. Если размер строки 2
меньше указанной длины, то при необходимости строка 2
дублируется. Если строка 2 не указана, то ее заменяют символы пробела.
Например:
DBMS_OUTPUT.put_line('Пример='||LPAD('Привет', 10, 'Да '));
Результат: Пример=Да ДПривет
Удаляет пробелы в начале строки 1, если строка 2 не указана.
Иначе возвращает строку 1, в которой удалены крайние левые
символы, идентичные символам строки 2
Возвращает по коду символ Unicode
Возвращает "строка_символов", в которой каждое вхождение
"строка_поиска" заменяется на "строка_замены". Если "строка_замены" не указана, то все вхождения "строка_поиска"
удаляются из "строка_символов"
Возвращает строку 1, дополненную справа до размера указанной длины символами строки 2. Если размер строки 2
меньше указанной длины, то при необходимости строка 2
дублируется. Если строка 2 не указана, то ее заменяют символы пробела
Удаляет пробелы в конце строки 1, если строка 2 не указана.
Возвращает "строка 1", в которой удалены крайние правые
символы, идентичные символам строки 2
Возвращает код звучания строки
Удалить пробелы слева и справа в строке
Переводит все символы строки в верхний регистр
50
Окончание табл. 4.6
1
SUBSTR(исходная
строка, a, [,b])
2
Возвращает часть исходной строки, начинающуюся со стартовой позиции a и имеющую длину b символов. Если a = 0,
это равносильно тому, что a = 1. Если a положительно, возвращаются символы слева направо. Если a отрицательно, то
стартовая позиция определяется отсчетом с конца строки, но
возврат символов идет слева направо! Если b отсутствует, то
по умолчанию возвращаются все символы до конца строки.
Если b меньше 1, то возвращается значение NULL
TRANSLATE(строка Возвращает "строка_символов", в которой все вхождения ка_символов, замеждого символа "заменяемая_строка" замещаются соответстняемая_строка, вно- вующим символом "вносимая_строка". Функция
TRANSLATE является расширением функции REPLACE.
симая_строка)
Если "заменяемая_строка" длиннее, чем "вносимая_строка",
все ее лишние символы удаляются, поскольку для них нет соответствующих символов во "вносимая_строка". "Вносимая_строка" не может быть пустой. Oracle интерпретирует
пустую строку как значение NULL, а если любой аргумент
функции TRANSLATE является NULL, то результат тоже
будет NULL
Кроме того, в работе могут быть использованы такие функции, как
UNISTR, COMPOSE, DECOMPOSE, NLS_INITCAP, NLS_LOWER,
NLSSORT,
NLS_UPPER,
REGEXP_INSTR,
REGEXP_LIKE,
REGEXP_REPLACE, REGEXP_SUBSTR.
Пример работы со строковыми функциями:
set serveroutput on
DECLARE
c1 char(20);
c2 char(40);
BEGIN
c1:=RPAD('qwe', 15, 'xy');
DBMS_OUTPUT.put_line('c1= ' || c1);
c2:=RPAD('приqwe', 40, 'привет');
DBMS_OUTPUT.put_line('c2= ' || c2);
c2:=TRANSLATE(c2, 'привет', '*---*');
DBMS_OUTPUT.put_line('c2 после TRANSLATE = ' || c2);
END;
Результат:
c1= qwexyxyxyxyxyxy
c2= приqweприветприветприветприветприветприв
c2 после TRANSLATE = *--qwe*---**---**---**---**---**--51
Использование функций для работы с числами
В табл. 4.7 описаны основные функции для работы с числами.
Таблица 4.7
Краткий обзор математических функций
Название функции
ABS(число)
ACOS(число)
ASIN(число)
ATAN(число)
ATAN2(число)
CEIL(число с дробной
частью)
COS(радианы)
EXP(число)
FLOOR(число с дробной частью)
LN(число)
LOG(основание, число)
Действие, выполняемое функцией
Вычисляет абсолютное значение числа
Вычисляет арккосинус
Вычисляет арксинус
Вычисляет арктангенс
Вычисляет арктангенс с учетом квадратов
Выполняет округление вверх до ближайшего большего
целого
Вычисляет косинус угла, указанного в радианах
Возвращает результат возведения в указанную степень
экспоненту; если число = 1, то получим само значение
exp
Выполняет округление вниз до ближайшего целого
Вычисляет натуральный логарифм числа
Вычисляет логарифм, т.е. в какую степень нужно возвести основание, чтобы получить указанное число. Например: log(10,100) равен 2
Возвращает остаток от деления
MOD(делимое, делитель)
POWER(число, степень) Возводит число в степень
ROUND(x, [,y])
Возвращает х округленное до y разрядов справа от десятичной точки. Значением по умолчанию для y является 0,
при этом x округляется до ближайшего целого числа. Если y отрицательное число, то округляются цифры слева
от десятичной точки, y должен быть целым числом
SIGN(число)
Определяет знак числа, возвращает 1, или 0, или -1
SIN(радианы)
Вычисляет синус угла, указанного в радианах
SQRT(число)
Извлекает квадратный корень из неотрицательного числа
TAN(радианы)
Возвращает тангенс угла, указанного в радианах
TRUNC(x, [,y])
Возвращает x усеченное (не округленное !) до y десятичных разрядов. Значением по умолчанию для y является 0,
при этом x усекается до целого числа. Если y отрицательно, то усекаются цифры слева от десятичной точки
Кроме того, могут быть использованы такие функции, как BITAND,
COSH, SINH, TANH.
Пример вычисления косинуса и объявления постоянной ПИ:
SET SERVEROUTPUT ON
DECLARE
PI CONSTANT number(10,9):=3.141592654;
52
rez number(10,5):=0;
BEGIN
rez:=cos(PI); DBMS_OUTPUT.PUT_LINE(rez);
END;
Псевдослучайные числа
Генерация псевдослучайного числа реализуется системной процедурой, синтаксис которой представлен ниже:
DBMS_RANDOM.RANDOM
Возвращает число типа binary_integer.
Пример генерации псевдослучайного числа:
SET SERVEROUTPUT ON
declare
i binary_integer;
begin
i:=DBMS_RANDOM.RANDOM;
DBMS_OUTPUT.PUT_LINE(i);
end;
Использование функций для работы с типом дата/время
Присвоение даты/времени переменной реализуется через функцию
TO_DATE(‘дата/время’, ‘формат даты/времени’). В табл. 4.8 описаны основные функции для работы с датами и временем.
Пример:
SET SERVEROUTPUT ON
declare
perem date;
begin
DBMS_OUTPUT.PUT_LINE(perem);
perem:= SYSDATE + 7;
DBMS_OUTPUT.PUT_LINE(perem);
end;
Таблица 4.8
Краткий обзор основных функций для работы с датой и временем
Название функции
1
ADD_MONTHS(d,x)
CURRENT_DATE
Действие, выполняемое функцией
2
Возвращает дату d плюс x месяцев. Значение x может
быть любым целым числом. Если в месяце, полученном
в результате, число дней меньше, чем в месяце d, то
возвращается последний день месяца результата. Временные компоненты даты d и результата одинаковы
Выводит текущую дату без времени в формате, установленном в системе, используется без параметров
53
Окончание табл. 4.8
1
CURRENT_TIMESTAMP
SYSTIMESTAMP
DBTIMEZONE
LAST_DAY(d)
LOCALTIMESTAMP
MONTHS_BETWEEN(дата
1, дата 2)
NEW_TIME(d, пояс 1, пояс
2)
NEXT_DAY(d, строка_символов)
ROUND(d, [, формат])
SESSIONTIMEZONE
SYSDATE
TRUNC(d, [, формат])
2
Выводит дату, время и смещение по часовому поясу,
пишется без параметров. Пример результата:
19.01.08 21:13:08,000000515 +06:00
Показывает временную зону. Пример результата:
-05:00
Возвращает дату последнего дня того месяца, в который входит d. Эту функцию можно применять для определения количества дней, оставшихся в текущем месяце
Выводит дату, время без часового пояса, пишется без
параметров. Пример результата:
19.01.08 21:15:54,000000015
Возвращает число месяцев между "дата 1" и "дата 2".
Если дни в "дата 1" и "дата 2" или обе даты являются
последними днями своих месяцев, то результат представляет собой целое число. В противном случае результат будет содержать дробную часть по отношению
к 31-дневному месяцу
Возвращает дату и время часового пояса 2 для того момента, когда датой и временем часового пояса 1 является d. Где пояс 1, пояс 2 – это строки символов для поясного времени Америки
Возвращает дату первого дня, наступающего после даты d и обозначенного строкой символов. Строка символов указывает день недели на языке текущего сеанса
Округляет дату d до единицы, указанной форматом.
Например:
DBMS_OUTPUT.PUT_LINE(ROUND(to_date('19.01.200
8', 'dd.mm.yyyy'), 'MONTH'));
DBMS_OUTPUT.PUT_LINE(ROUND(to_date('19.01.200
8', 'dd.mm.yyyy'), 'YYYY'));
Результат:
01.02.08
01.01.08
Выводит смещение по часовому поясу, пишется без параметров. Пример результата:
+06:00
Возвращает текущую дату и время в системе
Возвращает дату d, усеченную до единицы, указанной
форматом. Если формат не указан, применяется формат
по умолчанию 'DD', который усекает d до ближайшего
дня
Кроме того, могут быть использованы такие функции, как
TIMESTAMP_TO_SCN, TO_DSINTERVAL, TO_TIME, TO_TIME_TZ,
TO_TIMESTAMP,
TO_TIMESTAMP_TZ,
TO_YMINTERVAL,
54
TZ_OFFSET,
CURRENT_TIME,
EXTRACT,
FROM_TZ,
NUMTODSINTERVAL, NUMTOYMINTERVAL, SCN_TO_TIMESTAMP.
Функция проверки и замены в переменной значения NULL
NVL(выражение 1, выражение 2)
Возвращает «выражение 2», если «выражение 1» является значением
NULL. В противном случае возвращает «выражение 1». Если «выражение
1» не является строкой символов, то возвращаемое значение имеет тот же
тип данных, что и «выражение 1», иначе возвращаемое.
Варианты заданий к лабораторной работе No4
Общие сведения
Список вариантов заданий
Вариант
Список номеров упражнений
1 1 6 11 16 21 26 31 36 41 46 51 56 61
2 2 7 12 17 22 27 32 37 42 47 52 57 62
3 3 8 13 18 23 28 33 38 43 48 53 58 63
4 4 9 14 19 24 29 34 39 44 49 54 59 64
5 5 10 15 20 25 30 35 40 45 50 55 60 65
6 6 11 16 21 26 31 36 41 46 51 56 61 1
7 7 12 17 22 27 32 37 42 47 52 57 62 2
8 8 13 18 23 28 33 38 43 48 53 58 63 3
9 9 14 19 24 29 34 39 44 49 54 59 64 4
10 10 15 20 25 30 35 40 45 50 55 60 65 5
11 2 6 12 16 22 26 32 36 42 46 52 56 62
12 1 5 11 15 21 25 31 35 41 45 51 55 61
13 3 7 13 17 23 27 33 37 43 47 53 57 63
14 4 8 14 18 24 28 34 38 44 48 54 58 64
15 5 9 15 19 25 29 35 39 45 49 55 59 65
16 6 13 26 33 36 43 46 53 56 63 1 11 17
17 7 18 27 28 37 38 47 48 57 58 2 4 10
18 8 9 18 19 28 29 38 39 48 49 58 59 60
19 9 14 29 24 39 34 49 44 59 54 61 65 3
20 10 12 20 22 30 32 40 42 50 52 60 62 8
Для получения более подробной информации о работе тех или иных
операторов или функций можно запустить файлы «User Guide PL_SQL
55
10g.pdf» и «User Guide PL_SQL Packages Oracle 10g.pdf» из рабочей папки
преподавателя, набрать искомый ключевой элемент в режиме поиска
(CTRL+F). Для выполнения заданий ориентироваться на вариант и список
номеров заданий, указанных выше.
В утилите SQL *Plus Worksheet создать отдельные программы по каждому заданию, которые сохранять на диске с названием ФамилияСтудента_Лаб4_Вариант_No_задания, текст задания в виде комментария помещать в файле перед программой для удобства проверки.
Объявление переменных:
1. Объявить переменную Perem1 для хранения информации о денежной величине, а переменную Perem2 – для хранения чисел с целой частью,
равной 8, и дробной частью, равной 2.
2. Объявить переменную Perem1 для хранения строк длиной 100, а
переменную Perem2 – для хранения длинного целого.
3. Объявить переменную Perem1 для хранения динамических строк с
максимальной длиной 1000, а переменную Perem2 – для хранения целых
чисел.
4. Объявить переменную Perem1 для хранения строк длиной 30, а переменную Perem2 – для хранения числа с целой частью, равной 10, и дробной частью, равной 3.
5. Объявить переменную Perem1 для хранения даты, а переменную
Perem2 – для хранения малого целого.
Передача результата из SELECT в переменную:
6. Подсчитать среднюю цену закупленных книг (с помощью запроса
SELECT) и умножить ее на значение 123,34, которое необходимо сохранить в отдельной переменной, вывести значение переменной на экран.
7. Подсчитать суммарную цену всех закупок книг, результат поместить в переменную, вывести значение переменной на экран.
8. Подсчитать количество книг в справочнике книг, результат поместить в переменную, вывести значение переменной на экран.
9. Определить минимальную дату рождения автора в справочнике авторов, результат поместить в переменную, вывести значение переменной
на экран.
10. Подсчитать количество поставщиков книг, результат поместить в
переменную.
11. Подсчитать сумму закупок книг, результат поместить в переменную.
12. Подсчитать среднюю цену в таблице покупок книг, результат поместить в переменную.
56
13. Подсчитать максимальную стоимость книг в закупке, результат
поместить в переменную.
Работа с датой и временем:
14. Определить переменную Date1 типа ДАТА. Присвоить ей значение
даты 31.12.2006 в формате dd.mm.yyyy.
15. Определить переменную Date1 типа ДАТА. Присвоить ей значение
даты 31.12.2006 в формате mm.dd.yyyy.
16. Определить переменную Date1 типа ДАТА. Присвоить ей значение
даты 31.12.2006 в формате yyyy.mm.dd.
Создание таблицы или записи через переменную типа TABLE или
RECORD или %ROWTYPE:
17. Создать локальную таблицу с названием TEMP по таблице Boooks.
В цикле перебрать записи таблицы и вывести каждую запись из цикла на
экран.
18. Создать локальную таблицу с названием TEMP по таблице Purchases. В цикле перебрать записи таблицы и вывести каждую запись из
цикла на экран.
19. Создать локальную таблицу с названием TEMP по таблице
Publishing_house. В цикле перебрать записи таблицы и вывести каждую запись из цикла на экран.
20. Создать запись с названием TEMP и полями типа дата, длинное целое, строка. Присвоить полям записи данные и вывести результат на экран.
21. Создать локальную таблицу с названием TEMP и полями типа дата,
число с округлением до тысяч, динамическая строка. Присвоить полям записи данные и вывести результат на экран.
Преобразование типов переменных:
22. Объявить переменные типа FLOAT, CHAR, SMALLINT. Присвоить значения, соответствующие типам. Выполнить преобразование переменных типа FLOAT, CHAR, SMALLINT в INT, DATETIME, BOOLEAN
соответственно и вывести результат на экран.
23. Объявить переменные типа INT, DATE, BOOLEAN. Присвоить
значения, соответствующие типам. Выполнить преобразование переменных типа INT, DATE, BOOLEAN в FLOAT, CHAR, SMALLINT соответственно и вывести результат на экран.
24. Объявить переменные типа NUMERIC, VARCHAR2, DATE. Присвоить значения, соответствующие типам. Выполнить преобразование переменных
типа NUMERIC, VARCHAR2, DATE в FLOAT, CHAR,
NUMERIC соответственно и вывести результат на экран.
57
25. Объявить переменные типа BOOLEAN, NVARCHAR2, DATE.
Присвоить значения, соответствующие типам. Выполнить преобразование
переменных типа BOOLEAN, NVARCHAR2, DATE в FLOAT, INT, REAL
соответственно и вывести результат на экран.
Условная конструкция IF:
26. Подсчитать количество поставщиков в таблице Deliveries. Если их
в таблице от 2 до 5, то ничего не сообщать, в противном случае вывести
сообщение вида "В таблице ... поставщиков" (вместо многоточия поставить точное количество поставщиков).
27. Подсчитать сумму закупок книг в таблице покупок. Если полученная сумма в диапазоне от 1000 до 5000, то ничего не сообщать, в противном случае вывести сообщение вида "Сумма закупок = ..." (вместо многоточия поставить точную сумму).
28. Подсчитать среднюю стоимость закупки книг в таблице покупок.
Если полученная стоимость в диапазоне от 1000 до 5000, то ничего не сообщать, в противном случае вывести сообщение вида "Средняя стоимость
закупки = ..." (вместо многоточия поставить точную среднюю стоимость).
29. Определить минимальную стоимость закупки книг в таблице покупок. Если полученная стоимость в диапазоне от 200 до 300, то ничего не
сообщать, в противном случае вывести сообщение вида "Минимальная
стоимость закупки = ..." (вместо многоточия поставить точную стоимость).
Цикл WHILE:
30. Определить количество записей в таблице Authors. Пока записей
меньше 15, делать в цикле добавление записи в таблицу с автоматическим
наращиванием значения ключевого поля, а вместо имени автора ставить
значение 'Автор не известен'.
31. Определить количество записей в таблице издательств. Пока записей меньше 20, делать в цикле добавление записи в таблицу с автоматическим наращиванием значения ключевого поля, а вместо названия издательства ставить значение 'не известно'.
32. Определить количество записей в таблице поставщиков. Пока записей меньше 17, делать в цикле добавление записи в таблицу с автоматическим наращиванием значения ключевого поля, а вместо названия поставщика ставить значение 'не известен'.
Объявление курсора:
33. Создать курсор по данным таблицы Books с полями Code_book, Title_book.
34. Создать курсор по данным таблицы поставщиков (таблица Deliveries) с полями Name_delivery, Name_company.
58
35. Создать курсор по данным таблицы Books и Authors с полями
Code_book, Title_book, Name_author.
36. Создать курсор по данным таблицы Books и Publishing_house с полями Code_book, Title_book, Publish.
Операторы для работы с курсором:
37. Создать курсор по данным таблицы Deliveries с полями
Code_delivery, Name_delivery. Вывести данные 3-й записи.
38. Поместить в курсор данные таблицы Purchases. Перебрать все записи таблицы Purchases. Просуммировать значения произведений полей
Cost и Amount и результат сохранить в переменной Sum_table, которую
после суммирования вывести на экран. Закрыть курсор.
39. Объявить курсор по данным полей Name_Author и Title_Book таблиц Authors и Books. Вывести данные 5-й записи курсора.
Использование функций для работы со строковыми переменными.
Базовый текст дан в отдельном файле по вариантам. Для выполнения
этого блока заданий в Query Analyzer объявите переменную типа varchar и
присвойте ей в качестве значения строку с базовым текстом, который будет анализироваться и/или исправляться в заданиях.
40. Удалить в тексте лишние пробелы. Лишними считаются те, которые идут непосредственно за пробелом. Подсчитать количество исправлений.
41. Подсчитать количество встреч каждой из следующих букв: "а", "в",
"и", "п" в базовом тексте.
42. Подсчитать доли процентов встречи следующих букв: "е", "о", если
суммарный процент встречаемости всех этих букв равен 100% или процент
встречаемости е% + о% равен 100%.
43. По правилам оформления машинописных текстов перед знаками
.,!?:; пробелы не ставятся, но обязательно ставятся после этих знаков. Удалите лишние пробелы. Подсчитать количество исправлений.
44. По правилам оформления машинописных текстов перед знаками
.,!?:; пробелы не ставятся, но обязательно ставятся после этих знаков. Расставьте недостающие пробелы. Подсчитать количество исправлений.
45. Найти из исходного текста второе предложение и вернуть его в переменную Perem, а также вывести на экран весь исходный текст и найденное предложение.
46. Удалить из базового текста 2-е, 4-е, 6-е, 8-е слова.
47. Удалить из базового текста 3-е, 5-е, 7-е, 10-е слова.
48. Вставить в базовый текст вместо букв «а» – «АА».
49. Вставить в базовый текст вместо букв «е» и «о» – «ББ».
50. Поменять местами первое и последнее слова в базовом тексте.
59
Использование функций для работы с числами
51. Вывести значение формулы (1), переменные которой нужно описать и присвоить произвольные значения.
R⋅T
45
v = v0 ⋅ e
.
(1)
52. Подсчитать значение формулы (2), переменные которой нужно
описать, и присвоить произвольные значения.
y = 2 x ⋅ exp(ln(x 2 )) .
(2)
53. Подсчитать значение формулы (3), переменные которой нужно
описать, и присвоить произвольные значения.
sin( a )
y= 2
⋅a .
(3)
x − b3
54. Подсчитать значение формулы (4), переменные которой нужно
описать, и присвоить произвольные значения.
10
y = ∑ I n ⋅ a.
(4)
n =1
55. Подсчитать значение формулы (5), переменные которой нужно
описать, и присвоить произвольные значения.
tg (a)
y=
⋅ a ⋅b⋅c .
(5)
a+b−c
56. Подсчитать значение формулы (6), переменные которой нужно
описать, и присвоить произвольные значения.
y = sin( a ) ⋅ exp(b ⋅ c) .
(6)
57. Подсчитать значение формулы (7), переменные которой нужно
описать, и присвоить произвольные значения.
y = x 4 ⋅ ln(a) − b ⋅ c .
(7)
58. Подсчитать значение формулы (8), переменные которой нужно
описать, и присвоить произвольные значения.
x−a
.
y=
(8)
b3
59. Подсчитать значение формулы (9), переменные которой нужно
описать, и присвоить произвольные значения.
a ⋅ cos( x)
y= 2
⋅ sin( x) .
(9)
b − a2
Использование функций для работы с типом ДАТА/ВРЕМЯ
60. Вывести на экран название текущего месяца и текущее время. Записать в таблицу Purchases в поле Date_order одинаковую дату поступления, которая равна 12.03.2000.
60
61. Разобрать на отдельные составляющие текущую дату и время и вывести значения на экран в следующем порядке (вместо многоточий):
62. "Сегодня: День = ..., Месяц = ..., Год = ..., Часов = ..., Минут = ...,
Секунд= ..."
63. В исходный текст, сохраненный в переменной Perem, после слова
"время" вставить текущее время. Результат сохранить в той же переменной
Perem и вывести на экран.
Работа с переменной типа ЗАПИСЬ
64. Создать запись с названием TEMP, аналогичную по структуре с записью таблицы Поставщики. Присвоить полям записи данные и добавить в
таблицу Поставщики значения записи TEMP.
65. Создать локальную таблицу с названием TEMP, аналогичную по
структуре с записью таблицы Издательства. Присвоить полям записи данные и добавить в таблицу Издательства значения записи TEMP.
Лабораторная работа No5
СОЗДАНИЕ ХРАНИМЫХ ПРОЦЕДУР И ФУНКЦИЙ В ORACLE
Цель работы – научиться создавать и использовать хранимые процедуры
и функции в схемах Oracle.
Содержание работы:
1. Проработка всех примеров, анализ результатов их выполнения в
утилите SQL *Plus Worksheet. Проверка наличия созданных процедур в текущей схеме.
2. Проверка всех выполненных примеров в утилите Enterprise
MANAGER Console.
3. Выполнение всех примеров и заданий по ходу лабораторной работы.
4. Выполнение индивидуальных заданий по вариантам.
Пояснения к выполнению работы
Для освоения программирования хранимых процедур используем пример базы данных в табличном пространстве DB_Books, которая была создана в лабораторной работе No1. При выполнении примеров и заданий обращайте внимание на соответствие названий таблиц и других объектов
проекта.
Хранимые процедуры представляют собой набор команд, состоящий из
одного или нескольких операторов SQL или функций и сохраняемый в базе данных в откомпилированном виде.
Процедуры и функции - это объекты базы данных и, следовательно, они
создаются командой CREATE и уничтожаются командой DROP. При соз61
дании процедуры и функции должны быть определены: имя объекта, перечень и типы параметров и логика работы процедуры или функции, описанные на языке PL/SQL.
Чтобы создать процедуру или функцию, необходимо иметь системные
привилегии CREATE PROCEDURE. Для создания процедуры, функции
или пакета в схеме, отличной от текущей схемы пользователя, требуются
системные привила на CREATE ANY PROCEDURE. После определения
имени новой процедуры или функции необходимо задать ее имена, типы и
виды параметров. Для каждого параметра должен быть указан один из видов параметра - IN, OUT или IN OUT. Вид параметра IN предполагает, что
значение параметра должно быть определено при обращении к процедуре
и не изменяется процедурой.
Попытка изменить в теле процедуры параметр вида IN приведет к сообщению об ошибке. Вид параметра OUT предполагает изменение значения параметра в процессе работы процедуры, то есть параметр вида OUT это возвращаемый параметр. Параметр IN OUT - это параметр, которому
при вызове должно быть присвоено значение, которое может быть изменено в теле процедуры. Параметры процедур или функций имеют виды, присвоенные по умолчанию.
Дополнительно к определениям, необходимым для процедуры, в определении функции должен быть тип данных единственного возвращаемого
функцией значения. Возврат значения функции выполняется командой
PL/SQL RETURN. Оператор определения процедуры Oracle использует
следующий синтаксис:
CREATE [OR REPLACE] PROCEDURE
[имя_схемы.]имя_процедуры
[(имя_параметра [{IN | OUT | IN OUT}] тип_данных
[, имя_параметра [{IN | OUT | IN OUT}] тип_данных...] )]
{IS | AS}
программа_нa_PL/SQL
Напоминание. При классическом описании синтаксиса { } обозначают
обязательный выбор одной из альтернатив, | – разделяет альтернативы, [ ] –
указывают на необязательные параметры, которые могут быть опущены.
Ключевое слово OR REPLACE указывает на безусловное замещение
старого текста процедуры. Если ключевое слово OR REPLACE не указано,
и процедура определена, то замещения старого значения кода процедуры
не происходит, и возвращается сообщение об ошибке.
62
В описании переменных процедуры не используется ключевое слово
DECLARE. Блок определения данных начинается сразу после ключевого
слова AS (или IS – по выбору пользователя).
Напомним, что функции PL/SQL отличаются от процедур тем, что возвращают в вызывающую среду значение параметра.
Оператор определения функции Oracle использует следующий синтаксис:
CREATE [OR REPLACE] FUNCTION
[имя_схемы.]имя_функции
[(имя_параметра [{IN | OUT | IN OUT}] тип_данных
[, имя_параметра [{IN | OUT | IN OUT}] тип_данных...] )]
RETURN тип_данных
{IS | AS}
программа_нa_PL/SQL
Описание типа данных для возвращаемого функцией значения требуется обязательно. При описании переменных функции так же, как и при
описании переменных процедуры, не используется ключевое слово
DECLARE. Блок определения данных начинается сразу после ключевого
слова IS (или AS, по выбору пользователя).
Удаление хранимой процедуры или функции
Если характер использования приложения изменился, то для освобождения ресурсов базы данных может потребоваться уничтожить процедуру
пли функцию. В собственной схеме пользователю не требуются дополнительные привилегии для уничтожения процедуры пли функции. Для уничтожения процедуры или функции в схеме другого пользователя необходимо наличие привилегии DROP ANY PROCEDURE.
DROP PROCEDURE [имя_схемы.]имя_процедуры
или
DROP FUNCTION [имя_схемы.]имя_функции
Пример создания процедуры без параметров:
CREATE OR REPLACE PROCEDURE ADMIN_BOOKS.Count_Books
IS
perem1 integer;
begin
Select count(Code_book) INTO perem1 from ADMIN_BOOKS.Books;
end Count_books;
63
Задание 1. Создайте данную процедуру в разделе Schema/ Procedure в
схеме ADMIN_BOOKS через утилиту Enterprise MANAGER Console. Запустите ее в утилите SQL *Plus Worksheet с помощью программы:
begin
ADMIN_BOOKS.Count_Books;
end;
Проверьте результат.
Пример создания процедуры c входным параметром:
CREATE OR REPLACE PROCEDURE
ADMIN_BOOKS.Count_Books_Pages
(Count_pages IN NUMBER)
IS
perem2 integer;
begin
Select count(Code_book) INTO perem2 from Books WHERE
Pages>=Count_pages;
end Count_Books_Pages;
Задание 2. Создайте данную процедуру в разделе Schema/ Procedure в
схеме ADMIN_BOOKS через утилиту Enterprise MANAGER Console. Запустите ее в утилите SQL *Plus Worksheet с помощью программы:
begin
ADMIN_BOOKS.Count_Books_Pages(12);
end;
Проверьте результат.
Пример создания процедуры c входными параметрами:
CREATE OR REPLACE PROCEDURE ADMIN_BOOKS.Count_Books_Title
(Count_pages IN Int, Title IN Char)
IS
perem3 integer;
begin
Select count(Code_book) INTO perem3 from Books WHERE
Pages>=Count_pages AND Title_book LIKE trim(Title)||'%';
end Count_Books_Title;
Задание 3. Создайте данную процедуру в разделе Schema/ Procedure в
схеме ADMIN_BOOKS через утилиту Enterprise MANAGER Console. Запустите ее в утилите SQL *Plus Worksheet с помощью программы:
begin
ADMIN_BOOKS.Count_Books_Title (100, 'П');
64
end;
Проверьте результат.
Пример создания процедуры c входными параметрами и выходным
параметром:
CREATE OR REPLACE PROCEDURE ADMIN_BOOKS.Count_Books_Itogo
(Count_pages IN Int, Title IN Char, Itogo OUT Int)
IS
begin
Select
count(Code_book)
INTO
Itogo
from
Books
WHERE
Pages>=Count_pages AND Title_book LIKE '%'||trim(Title)||'%';
end Count_Books_Itogo;
Задание 4. Создайте данную процедуру в разделе Schema/ Procedure в
схеме ADMIN_BOOKS через утилиту Enterprise MANAGER Console. Запустите ее в утилите SQL *Plus Worksheet с помощью программы:
SET SERVEROUTPUT ON
DECLARE
I INTEGER;
begin
ADMIN_BOOKS.Count_Books_Itogo (56, 'Руслан и Людмила', I);
DBMS_OUTPUT.PUT_LINE(I);
end;
Проверьте результат.
Пример создания процедуры без параметров для увеличения значения
ключевого поля в таблице Purchases в 2 раза:
CREATE OR REPLACE PROCEDURE ADMIN_BOOKS.update_proc
IS
BEGIN
UPDATE Purchases SET Code_purchase = Code_purchase*2;
END update_proc;
Задание 5. Создайте данную процедуру в разделе Schema/ Procedure в
схеме ADMIN_BOOKS через утилиту Enterprise MANAGER Console. Запустите ее в утилите SQL *Plus Worksheet с помощью программы:
begin
ADMIN_BOOKS.update_proc;
end;
Процедура не возвращает никаких данных.
65
Пример создания процедуры с входным параметром и значением по
умолчанию для увеличения значения ключевого поля в таблице Purchases в заданное количество раз (по умолчанию в 2 раза):
CREATE OR REPLACE PROCEDURE ADMIN_BOOKS.update_proc2
(p IN INT:= 2)
IS
BEGIN
UPDATE Purchases SET Code_purchase = Code_purchase*p;
END update_proc2;
Задание 6. Создайте данную процедуру в разделе Schema/ Procedure в
схеме ADMIN_BOOKS через утилиту Enterprise MANAGER Console. Запустите ее в утилите SQL *Plus Worksheet с помощью программы:
begin
ADMIN_BOOKS.update_proc2;
end;
или
begin
ADMIN_BOOKS.update_proc2(4);
end;
Процедура не возвращает никаких данных.
Пример создания функции c входными параметрами и RETURN:
CREATE OR REPLACE function ADMIN_BOOKS.checkname
(param IN int, ch IN char)
RETURN integer
AS
type_end integer;
begin
SELECT count(Name_author) INTO type_end FROM authors WHERE
Code_author = param AND Name_author=ch;
RETURN type_end;
end checkname;
Задание 7. Создайте данную функцию в разделе Schema/ Function в
схеме ADMIN_BOOKS через утилиту Enterprise MANAGER Console. Запустите ее в утилите SQL *Plus Worksheet с помощью программы:
SET SERVEROUTPUT ON
DECLARE
I INTEGER;
begin
I:=ADMIN_BOOKS.checkname(12,'Пушкин А.С.');
66
DBMS_OUTPUT.PUT_LINE(I);
end;
Пример создания функции с входными и выходным параметрами.
Создать функцию для определения количества заказов, совершенных
за указанный период:
CREATE OR REPLACE function ADMIN_BOOKS.count_purchases
(d1 DATE, d2 DATE)
RETURN integer
AS
count_ integer;
begin
SELECT count(Code_purchase) INTO count_ from Purchases WHERE
Date_order BETWEEN d1 AND d2;
RETURN count_;
end count_purchases;
Задание 8. Создайте данную функцию в разделе Schema/ Function в
схеме ADMIN_BOOKS через утилиту Enterprise MANAGER Console. Запустите ее в утилите SQL *Plus Worksheet с помощью программы:
SET SERVEROUTPUT ON
DECLARE
I INTEGER;
begin
I:=ADMIN_BOOKS.count_purchases(TO_DATE('12.06.2007', 'dd-mmyyyy'),TO_DATE('30.06.2007', 'dd-mm-yyyy') );
DBMS_OUTPUT.PUT_LINE(I);
end;
Проверьте результат.
Создание хранимых процедур с выходным параметром – набором
строк
Для вывода в качестве результата выполнения процедуры набора строк
используют курсор типа SYS_RefCursor.
Например:
create or replace procedure ADMIN_BOOKS.List_Authors (cursor1 out
SYS_REFCURSOR) is
begin
open cursor1 for
select Name_Author from ADMIN_BOOKS.Authors;
end List_Authors;
67
Пример запуска процедуры и просмотра набора строк, полученных из
нее:
SET SERVEROUTPUT ON
Declare
type cur_select1 is ref cursor;
cur_select2 cur_select1;
name1 ADMIN_BOOKS.Authors.Name_Author %type;
begin
ADMIN_BOOKS.List_Authors(cur_select2);
loop
FETCH cur_select2 INTO name1;
exit when cur_select2%NOTFOUND OR cur_select2%NOTFOUND IS
NULL;
DBMS_OUTPUT.PUT_LINE(cur_select2%ROWCOUNT || '. ' || name1);
end loop;
close cur_select2;
end;
Варианты заданий к лабораторной работе No5
Общие положения
В лабораторной работе в примерах тела процедур и функций написаны
так, что их можно полностью копировать, вставлять в утилиту SQL *Plus
Worksheet и запускать (F5) для их создания на сервере. Если создавать
процедуру или функцию в Enterprise MANAGER Console через мастер создания, то первая строка с конструкцией CREATE OR REPLACE
PROCEDURE имя_процедуры или CREATE OR REPLACE FUNCTION
имя_функции не копируется, а само имя_процедуры или имя_функции заносится в поле Name.
Создать примеры хранимых процедур и функций в вашем табличном
пространстве. Проверьте их работу.
По вариантам на базе таблиц, созданных в лабораторной работе No1, в
утилите SQL *Plus Worksheet создайте процедуры и функции, причем каждую программу сохранять на диске в отдельном файле с названием ФамилияСтудента_ЛАб_5_No_варианта_No_задания.
Список заданий
Вариант 1
1. Вывести список сотрудников, у которых есть хотя бы один ребенок.
2. Вывести список детей, которым выдали подарки в указанный период.
3. Вывести список родителей, у которых есть несовершеннолетние дети.
68
4. Вывести информацию о подарках со стоимостью больше указанного
числа, отсортированных по дате.
Вариант 2
1. Вывести список приборов с указанным типом.
2. Вывести количество отремонтированных приборов и общую стоимость ремонтов у указанного мастера.
3. Вывести список владельцев приборов и количество их обращений,
отсортированный по количеству обращений по убыванию.
4. Вывести информацию о мастерах с разрядом больше указанного
числа или с датой приема на работу меньше указанной даты.
Вариант 3
1. Вывести список цветков с указанным типом листа.
2. Вывести список кодов продаж, по которым продано цветов на сумму
больше указанного числа.
3. Вывести дату продажи, сумму, продавца и цветок по указанному коду продажи.
4. Вывести список цветов и сорт для цветов с высотой больше указанного числа или цветущий.
Вариант 4
1. Вывести список лекарств с указанным показанием к применению.
2. Вывести список дат поставок, по которым продано больше указанного числа одноименного лекарства.
3. Вывести дату поставки, сумму, ФИО руководителя от поставщика и
название лекарства по коду поступления больше указанного числа.
4. Вывести список лекарств и единицы измерения для лекарств с количеством в упаковке больше указанного числа или кодом лекарства
меньше определенного значения.
Вариант 5
1. Вывести список сотрудников с указанной должностью.
2. Вывести список списанного оборудования по указанной причине.
3. Вывести дату поступления, название оборудования, ФИО ответственного и дату списания для оборудования, списанного в указанный
период.
4. Вывести список оборудования с указанным типом или с датой поступления больше определенного значения.
Вариант 6
1. Вывести список блюд с весом больше указанного числа.
2. Вывести список продуктов, в названии которых встречается указанный фрагмент слова.
3. Вывести объем продукта, название блюда, название продукта с кодом блюда от указанного начального значения по определенному
конечному значению.
69
4. Вывести порядок приготовления блюда и название блюда с количеством углеводов больше определенного значения или количеством
калорий больше указанного значения.
Вариант 7
1. Вывести список сотрудников с указанной должностью.
2. Вывести список документов, в содержании которых встречается указанный фрагмент слова.
3. Вывести дату регистрации, тип документа, ФИО регистратора и название организации для документов, зарегистрированных в указанный период.
4. Вывести список зарегистрированных документов с определенным
типом документа или с датой регистрации больше указанного значения.
Вариант 8
1. Вывести список сотрудников с указанной причиной увольнения.
2. Вывести список документов с датой регистрации в указанный период.
3. Вывести дату регистрации, причину увольнения, ФИО сотрудника
для документов, зарегистрированных в указанный период.
4. Вывести список зарегистрированных документов с кодом документа
в указанном диапазоне.
Вариант 9
1. Вывести список сотрудников, бравших отпуск указанного типа.
2. Вывести список документов с датой регистрации в указанный период.
3. Вывести дату регистрации, тип отпуска, ФИО сотрудника для документов, зарегистрированных в указанный период.
4. Вывести список зарегистрированных документов с кодом документа
в указанном диапазоне.
70
Вариант 10
1. Вывести список сотрудников с указанной должностью.
2. Вывести список документов, в содержании которых встречается указанный фрагмент слова.
3. Вывести дату регистрации, тип документа, ФИО отправителя и название организации для документов, зарегистрированных в указанный период.
4. Вывести список зарегистрированных документов с указанным типом
документа или с кодом документа меньше определенного значения.
Вариант 11
1. Вывести список сотрудников, назначенных на указанную должность.
2. Вывести список документов с датой регистрации в указанный период.
3. Вывести дату регистрации, должность, ФИО сотрудника для документов, зарегистрированных в указанный период.
4. Вывести список зарегистрированных документов с кодом документа
в указанном диапазоне.
Вариант 12
1. Вывести список оборудования с указанным типом.
2. Вывести список оборудования, которое брал в прокат определенный
клиент.
3. Вывести список лиц, бравших оборудование в прокат, отсортированный по количеству их обращений, а также количество этих обращений.
4. Вывести информацию о клиентах, отсортированных по адресам.
Вариант 13
1. Вывести список оборудования с указанным типом.
2. Вывести список оборудования, которое списал определенный сотрудник.
3. Вывести количество списанного оборудования, сгруппированного по
типам оборудования.
4. Вывести информацию о сотрудниках с датой приема на работу
больше определенной даты.
Вариант 14
1. Вывести список цветков с указанным типом листа.
2. Вывести список кодов поступлений, по которым продано цветов на
суммы больше определенного значения.
3. Вывести дату поступления, сумму, названия поставщика и цветов по
определенному коду поставщика.
4. Вывести список цветов и сорт для цветов с высотой больше определенного числа или цветущий.
71
Вариант 15
1. Вывести список клиентов, заехавших в номера в указанный период.
2. Вывести общую сумму оплат за номера для каждого клиента.
3. Вывести дату заезда, тип номера, ФИО клиентов, зарегистрированных в указанный период.
4. Вывести список зарегистрированных клиентов в номерах определенного типа.
Вариант 16
1. Вывести список оборудования с указанным типом.
2. Вывести список оборудования, которое брал в прокат определенный
клиент.
3. Вывести список лиц, бравших оборудование в прокат, и количество
их обращений, отсортированных по количеству обращений по убыванию.
4. Вывести информацию о клиентах, отсортированных по адресам.
Вариант 17
1. Вывести список ценностей с закупочной стоимостью больше определенного значения или сроком гарантии больше указанного числа.
2. Вывести список мест нахождения материальных ценностей, в названии которых встречается указанное слово.
3. Вывести сумму стоимости ценностей с кодом в указанном диапазоне.
4. Вывести список материально-ответственных лиц с датой приема на
работу в указанном диапазоне.
Вариант 18
1. Вывести список ремонтных работ, выполненных определенным мастером.
2. Вывести список этапов работ, входящих в работы, в названии которых встречается указанное слово.
3. Вывести сумму стоимости этапов ремонтных работ для работ с кодом в указанном диапазоне.
4. Вывести список мастеров с датой приема на работу в указанном диапазоне.
Вариант 19
1. Вывести список лекарств с определенным показанием.
2. Вывести список номеров чеков, по которым продано больше определенного числа лекарств.
3. Вывести дату продажи, сумму, ФИО кассира и лекарство по чеку с
указанным номером.
4. Вывести список лекарств и единицы измерения для лекарств с количеством в упаковке больше указанного числа или кодом лекарства
меньше определенного значения.
72
Вариант 20
1. Вывести список сотрудников с указанной должностью.
2. Вывести список документов, в содержании которых встречается указанный фрагмент слова.
3. Вывести дату регистрации, тип документа, ФИО исполнителя и факт
исполнения для документов, зарегистрированных в указанный период.
4. Вывести список зарегистрированных документов с указанным типом
документа или с кодом документа в определенном диапазоне.
Лабораторная работа No6
СОЗДАНИЕ ТРИГГЕРОВ В ORACLE
Цель работы – научиться создавать и использовать триггеры в Oracle.
Содержание работы:
1. Проработка всех примеров, анализ результатов их выполнения в
утилите SQL *Plus Worksheet. Проверка наличия созданных триггеров в
текущей схеме.
2. Проверка всех выполненных примеров в утилите Enterprise
MANAGER Console.
3. Выполнение всех примеров и заданий по ходу лабораторной работы.
4. Выполнение индивидуальных заданий по вариантам.
Пояснения к выполнению работы
Для освоения программирования триггеров используем пример базы
данных в табличном пространстве DB_Books, которая была создана в лабораторной работе No1. При выполнении примеров и заданий обращайте
внимание на соответствие названий таблиц и других объектов проекта.
Триггер базы данных — это процедура PL/SQL, которая автоматически
запускается при возникновении определенных событий, связанных с выполнением операций вставки, удаления или модификации данных таблицы. Событие, управляющее запуском триггера, описывается в виде логических условий. Когда возникает событие, соответствующее условиям триггера, сервер Oracle автоматически запускает триггер, то есть интерпретирует код программы триггера, записанный на языке PL/SQL.
В основном триггеры используются для реализации сложных ограничений целостности данных, которые невозможно осуществить через описательные ограничения, устанавливаемые при создании таблиц, организации всевозможных видов аудита, автоматического оповещения других модулей о том, что делать в случае изменения информации, содержащейся в
73
таблице БД, для реализации "бизнес-правил", для организации каскадных
воздействий на таблицы БД.
Строковые и операторные триггеры
Синтаксис:
CREATE [OR REPLACE] TRIGGER имя_триггера
BEFORE | AFTER активизирующее_событие ON ссылка_на_таблицу
FOR EACH ROW [WHEN условие_срабатывания]
тело_триггера
где активизирующее_событие указывает момент активации триггера
BEFORE до срабатывания оператора DML, а AFTER – после срабатывания оператора DML.
FOR EACH ROW указывает на активацию триггера от воздействия на
каждую строку в наборе строк, без этого указателя триггер запускается после или до оператора DML в целом.
Порядок активации триггеров в большинстве случаев таков:
1) Выполняется операторный триггер BEFORE (при его наличии).
2) Для каждой строки, на которую воздействует оператор:
- выполняется строковый триггер BEFORE (при его наличии);
- выполняется собственно оператор;
- выполняется строковый триггер AFTER (при его наличии).
3) Выполняется операторный триггер AFTER (при его наличии).
Псевдозаписи
При создании строковых триггеров можно использовать псевдозаписи
:old и :new. Строковый триггер срабатывает один раз для каждой строки.
При этом внутри триггера можно обращаться к строке, обрабатываемой в
данный момент времени, применяя псевдозаписи.
Например:
CREATE OR REPLACE TRIGGER ADMIN_BOOKS.Trigger1
BEFORE DELETE ON ADMIN_BOOKS.Authors FOR EACH ROW
DECLARE
a ADMIN_BOOKS.Authors.Code_author%TYPE;
b ADMIN_BOOKS.Authors.Name_Author%TYPE;
c ADMIN_BOOKS.Authors.Birthday%TYPE;
BEGIN
a:= :old.Code_author;
b:= :new.Name_Author;
c:= :old.Birthday;
74
End;
Обращение к псевдозаписям :old и :new должно производиться через
имена полей и применимо только к строковым триггерам.
Условие WHERE
С его помощью можно заставить триггер работать по условию! Само
условие WHERE в триггере применимо к типу строчных триггеров.
Пример:
Предварительно создадим таблицу, которая будет фиксировать записи,
в которых не ввели название книги.
CREATE
TABLE
ADMIN_BOOKS.Audit_Trigger2(date_oper
date,
user_name char(20), code_book number(5));
Commit;
Теперь создадим триггер:
CREATE OR REPLACE TRIGGER ADMIN_BOOKS.Trigger2
BEFORE INSERT OR UPDATE OF Title_Book ON ADMIN_BOOKS.Books
FOR EACH ROW WHEN (TRIM(new.Title_Book) = '')
DECLARE
BEGIN
INSERT INTO ADMIN_BOOKS.Audit_Trigger2
(date_oper,user_name,code_book) VALUES(sysdate, user,
:new.code_book);
END Trigger2;
Обратите внимание на наличие строки OF Title_Book ON
ADMIN_BOOKS.Books – это определяется поле, на которое устанавливаем
условие триггера.
Предикаты
В триггерах БД Oracle возможно применение логических операторов предикатов. Они имеют следующие определения: INSERTING,
UPDATING, DELETING. Это внутренние переменные среды Oracle, которые в зависимости от воздействующего на таблицу оператора DML принимают одно из значений: TRUE или FALSE.
Пример:
Предварительно создадим таблицу, которая будет фиксировать виды
выполненных операций.
CREATE
TABLE
ADMIN_BOOKS.Audit_Trigger3(date_oper
date,
user_name char(20), oper varchar2(10));
75
Теперь создадим триггер:
CREATE OR REPLACE TRIGGER ADMIN_BOOKS.Trigger3 AFTER
INSERT OR UPDATE OR DELETE ON ADMIN_BOOKS.Publishing_house
FOR EACH ROW
DECLARE
TIP VARCHAR2(10);
BEGIN
IF INSERTING THEN
TIP := 'INSERT';
ELSIF UPDATING THEN
TIP := 'UPDATE';
ELSIF DELETING THEN
TIP := 'DELETE';
END IF;
INSERT INTO ADMIN_BOOKS.Audit_Trigger3(date_oper,
user_name, oper) VALUES (SYSDATE, USER, TIP);
END Trigger3;
Системные триггеры
В БД существует два основных вида событий, на которые активизируются системные триггеры, а именно на события DDL или самой БД. К событиям DDL относятся операторы CREATE, DROP, ALTER, к событиям
базы данных – запуск останов сервера, регистрация отключения пользователя БД, ошибка сервера. Основные примеры событий и их обработки даны в табл. 6.1. Описание атрибутивных функций, которые могут быть использованы в триггерах дано в табл. 6.2.
Синтаксис создания системного триггера:
CREATE OR REPLACE TRIGGER [схема.]имя_триггера
{BEFORE | AFTER}
{список_событий_DDL | список_событий_базы_данных}
ON {DATABASE | [схема.]SCHEMA}
конструкция_REFERENCING
[условие_WHEN]
тело триггера;
Системные триггеры могут создаваться на уровне схемы (SCHEMA)
или уровне БД (DATABASE).
CREATE OR REPLACE TRIGGER Trigger4 AFTER LOGON ON
DATABASE
76
BEGIN
INSERT INTO SYSTEM.AUDTBASE(NZAP, POLZ, TMIN, OPER)
VALUES(1, USER, SYSDATE, 'UserIsLog(off)');
END Trigger4;
CREATE OR REPLACE TRIGGER Trigger5 AFTER LOGON ON SCHEMA
BEGIN
INSERT INTO SYSTEM.AUDTBASE(NZAP, POLZ, TMIN, OPER)
VALUES(1, USER, SYSDATE, 'UserIsLog(off)');
END Trigger5;
Таблица 6.1
События и их обработка для БД
Событие
STARTUP
SHUTDOWN
Разрешенное время выполнения
AFTER
BEFORE
SERVERERROR AFTER
LOGON
AFTER
LOGOFF BEFORE
CREATE BEFORE, AFTER
DROP BEFORE, AFTER
ALTER BEFORE, AFTER
Описание
Активизируется после запуска экземпляра
Активизируется при остановке экземпляра. Для
заметки: это событие не активизирует триггер,
если останов БД аварийный!
Активизируется при возникновении ошибки
Активизируется после успешного соединения
пользователя с базой данных
Активизируется в начале отключения пользователя
Активизируется до и после создания объекта
схемы
Активизируется до и после удаления объекта
схемы
Активизируется до и после изменения объекта
схемы
Триггеры STARTUP и SHUTDOWN имеют смысл только на уровне
БД, хотя их можно создать и в конкретной схеме, но активизироваться они
не будут. Кроме того, для системных триггеров существует ряд атрибутных функций.
Таблица 6.2
Описание атрибутных функций
Атрибутная
функция
1
SYSEVENT
INSTANCE_NUM
Тип данных
2
VARCHAR2
(20)
NUMBER
Системное событие
3
Все события
Все события
77
Описание
4
Возвращает системное событие, активизировавшее триггер
Возвращает номер текущего
экземпляра
1
DATABASE_NAME
SERVER_ERROR 2
            VARCHAR2
           (50)
          NUMBER
IS_SERVERERROR BOOLEAN
LOGIN_USER VARCHAR2
          (20)
DICTIONARY_OBJ_ VARCHAR2
TYPE (30)
DICTIONARY_OBJ_ VARCHAR2
NAME (30)
DICTIONARY_OBJ_ VARCHAR2
OWNER (30)
DES_ENCRYPTED_P VARCHAR2
ASSWORD (30)
Окончание табл. 6.2
3
4
Все события
Возвращает имя текущей
БАЗЫ ДАННЫХ
SERVERERROR Принимает один числовой
аргумент. Возвращает ошибку на той позиции в стеке
ошибок, которая была указана аргументом
SERVERERROR Принимает номер ошибки в
качестве аргумента и возвращает TRUE, если указанная ошибка Oracle присутствует в стеке ошибок
Все события
Возвращает идентификатор
пользователя, активизирующего триггер
CREATE, DROP, Возвращает тип объекта
словаря, над которым выALTER
полнялась операция DDL,
активизировавшая триггер
CREATE, DROP, Возвращает имя объекта
ALTER
словаря, над которым выполнялась операция DDL,
активизировавшая триггер
CREATE, DROP, Возвращает владельца того
ALTER
объекта словаря, над которым выполнялась операция
DDL, активизировавшая
триггер
CREATE USER, Возвращает зашифрованный
ALTER USER
в стандарте DES пароль создаваемого или изменяемого
пользователя
Варианты заданий к лабораторной работе No6
Общие положения
В лабораторной работе в примерах тела триггеров написаны так, что их
можно полностью копировать, вставлять в утилиту SQL *Plus Worksheet и
запускать (F5) для их создания на сервере. Если создавать триггер в
Enterprise MANAGER Console через мастер создания, то первая строка с
конструкцией CREATE OR REPLACE TRIGGER имя_триггера не копируется, а само имя_триггера заносится в поле Name.
Создайте примеры триггеров в вашем табличном пространстве. Проверьте их работу.
78
По вариантам в утилите SQL *Plus Worksheet создайте триггеры, причем каждую программу сохранять на диске в отдельном файле с названием
ФамилияСтудента_ЛАб_6_No_варианта_No_задания.
Список заданий
Вариант 1
1. Создать строковый триггер, который будет фиксировать ФИО и код
каждого сотрудника в отдельно организованной таблице, у которого
изменяли данные его детей.
2. Создать строковый триггер, который будет фиксировать данные о
подарках, которые удалили, с именем пользователя в отдельно организованной таблице, который выполнил удаление.
3. Создать операторный триггер, который будет фиксировать операции
добавления в любую из трех таблиц с указанием даты и времени операции.
4. Создать системный триггер на уровне БД, который будет фиксировать в отдельно организованной таблице подключения пользователей
к Oracle.
Вариант 2
1. Создать строковый триггер, который будет фиксировать список приборов с указанным старым и новым типом, при изменении типа прибора в отдельно организованной таблице.
2. Создать строковый триггер, который будет фиксировать количество
отремонтированных приборов и общую стоимость ремонтов с указанием имени мастера в отдельно организованной таблице у мастера,
информация о котором удаляется.
3. Создать операторный триггер, который будет фиксировать операции
добавления владельца прибора в таблицу владельцев и наименование
прибора, с которым он пришел в отдельно организованной таблице, а
также с указанием имени пользователя и даты операции.
4. Создать системный триггер на уровне схемы, который будет фиксировать в отдельно организованной таблице информацию о пользователях и объектах, структуру которых изменяют.
Вариант 3
Создать строковый триггер, который будет фиксировать старое и новое
наименование цветка с типом листа в отдельно организованной таблице, если изменяется наименование цветка в таблице или удаляется
цветок из таблицы.
Создать строковый триггер, который будет фиксировать коды продаж и
даты продаж в отдельно организованной таблице при добавлении записи в таблицу продаж.
79
Создать операторный триггер, который будет фиксировать в отдельно
организованной таблице дату операции, продавца, вид действия, вызвавшего триггер, и имя пользователя, по которым работает соединение с сервером в случае добавления, удаления или изменения содержимого таблицы продаж.
Создать системный триггер на уровне схемы, который будет фиксировать в отдельно организованной таблице информацию о пользователях, датах операций и объектах, которые уничтожают.
Вариант 4
Создать строковый триггер, который будет фиксировать в отдельно организованной таблице наименование лекарства с указанным показанием к применению в отдельно организованной таблице в случае его
удаления.
Создать строковый триггер, который будет фиксировать в отдельно организованной таблице дату поставки и наименование лекарства, которого продано больше указанного числа.
Создать операторный триггер, который будет фиксировать в отдельно
организованной таблице информацию об операции, дате, времени и
имени пользователя, а также наименование лекарства при добавлении, удалении или изменении информации о лекарстве.
Создать системный триггер на уровне схемы, который будет фиксировать в отдельно организованной таблице информацию о пользователях и объектах, структуру которых создают.
Вариант 5
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице сотрудника с должностью при добавлении
нового сотрудника в таблицу сотрудников.
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице наименование списанного оборудования,
тип операции, на которую запущен триггер, и дату списания по указанной причине при добавлении или изменении записи в таблице
списания.
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице информацию о дате поступления, названии оборудования, ФИО ответственного для оборудования, списанного указанным пользователем.
4. Создать системный триггер, который будет фиксировать в отдельно
организованной таблице информацию об отключаемых пользователях и датах операции.
80
Вариант 6
Создать строковый триггер, который будет фиксировать в отдельно организованной таблице наименование блюда с его весом при изменении данных в таблице блюд.
Создать строковый триггер, который будет фиксировать в отдельно организованной таблице наименование продукта, в названии которого
встречается указанный фрагмент слова, при добавлении продукта в
справочник продуктов.
Создать операторный триггер, который будет фиксировать в отдельно
организованной таблице информацию о коде продукта, названии
продукта, имени пользователя и дате операции при изменении, удалении записи в справочнике продуктов.
Создать системный триггер, который будет фиксировать в отдельно организованной таблице информацию о подключаемых пользователях
и датах операции.
Вариант 7
Создать строковый триггер, который будет фиксировать в отдельно организованной таблице сотрудника с должностью при добавлении нового сотрудника в таблицу сотрудников.
Создать строковый триггер, который будет фиксировать в отдельно организованной таблице информацию о документах, в содержании которых встречается указанный фрагмент слова, при добавлении записи в таблицу документов.
Создать операторный триггер, который будет фиксировать в отдельно
организованной таблице дату операции, имя пользователя при удалении документов.
Создать системный триггер, который будет фиксировать в отдельно организованной таблице информацию о пользователях, запускающих
экземпляр БД, и датах операции.
Вариант 8
Создать строковый триггер, который будет фиксировать в отдельно организованной таблице данные сотрудника, на которого формируют
документ об увольнении.
Создать строковый триггер, который будет фиксировать в отдельно организованной таблице информацию о документах, которые регистрируют датой, меньшей текущей системной даты.
Создать операторный триггер, который будет фиксировать в отдельно
организованной таблице дату операции, вид операции, имя пользователя при удалении, добавлении или изменении данных в справочнике статей увольнения.
81
Создать системный триггер, который будет фиксировать в отдельно организованной таблице информацию о пользователях, отключающих
экземпляр БД, и датах операции.
Вариант 9
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице данные сотрудника, которого оформляют в
отпуск указанного типа.
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице информацию о документах, которые удаляют при сроке давности документов больше года.
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице дату операции, вид операции, имя пользователя при удалении, добавлении или изменении данных в справочнике отпусков.
4. Создать системный триггер на уровне схемы, который будет фиксировать в отдельно организованной таблице информацию о пользователях и объектах, структуру которых создают, причем таким объектом является таблица или представление.
Вариант 10
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице ФИО отправителя, которого удалили из
таблицы отправителей.
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице дату операции и информацию о документах,
которые изменяются.
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице тип и дату операции при изменении,
удалении или удалении данных из справочника организацийполучателей.
4. Создать системный триггер на уровне схемы, который будет фиксировать в отдельно организованной таблице информацию о пользователях и объектах, структуру которых меняют, причем такими объектами являются процедоры или пакеты.
Вариант 11
Создать строковый триггер, который будет фиксировать в отдельно организованной таблице льготы по должности, которую добавили в
справочник должностей.
Создать строковый триггер, который будет фиксировать в отдельно организованной таблице код документа, пользователя, если документ
регистрируется датой, меньшей системной.
Создать операторный триггер, который будет фиксировать в отдельно
организованной таблице с указанием типа и даты операции при из82
менении, удалении или удалении данных из справочника сотрудников.
Создать системный триггер на уровне схемы, который будет фиксировать в отдельно организованной таблице информацию о пользователях и объектах, которые уничтожаются.
Вариант 12
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице старое и новое название оборудования, которое изменяют.
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице информацию о клиенте, которого удалили.
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице тип, пользователя и дату операции при
изменении, удалении или удалении данных из таблицы регистрации
проката.
4. Создать системный триггер на уровне схемы, который будет фиксировать в отдельно организованной таблице информацию о пользователях и объектах, структуру которых создают, причем такими объектами являются функции.
Вариант 13
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице дату операции, пользователя и информацию
об оборудовании, которое пытаются повторно списать.
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице старое и новое названия должности, если в
справочнике сотрудников меняют должность.
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице тип, пользователя и дату операции при
изменении, удалении или удалении данных из таблицы регистрации
проката.
4. Создать системный триггер на уровне схемы, который будет фиксировать в отдельно организованной таблице информацию о пользователях и объектах, структуру которых создают.
Вариант 14
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице старое и новое названия цветка при изменении информации о цветке при условии, что новое значение средней
высоты больше 15.
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице коды поступлений и наименования цветов
при добавлении записи в таблицу поступлений.
83
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице тип, пользователя и дату операции при
изменении, удалении или удалении данных из таблицы поставщиков.
4. Создать системный триггер на уровне БД, который будет фиксировать в отдельно организованной таблице подключения пользователей
к Oracle.
Вариант 15
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице информацию о клиенте, которого добавили
в справочник клиентов при условии, что фамилия начинается на
‘ИВ’.
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице старое и новое значения перечня удобств
при изменении данных в справочнике номеров.
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице тип, пользователя и дату операции при
изменении, удалении или удалении данных из таблицы регистрации
клиентов в номерах.
4. Создать системный триггер на уровне схемы, который будет фиксировать в отдельно организованной таблице информацию о пользователях и объектах, структуру которых изменяют.
Вариант 16
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице информацию о добавляемом оборудовании
при типе оборудования ‘комбайн’.
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице старое и новое имена клиента и дату операции при изменении фамилии клиента.
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице тип, пользователя и дату операции при
изменении, удалении или удалении данных из таблицы регистрации
проката.
4. Создать системный триггер на уровне схемы, который будет фиксировать в отдельно организованной таблице информацию о пользователях, датах операций и объектах, которые уничтожают.
Вариант 17
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице информацию об удаляемой ценности с закупочной стоимостью больше 15000.
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице старое и новое названия подразделения при
изменении данных в справочнике материально-ответственных.
84
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице тип, пользователя и дату операции при
изменении, удалении или удалении данных из таблицы учета материальных ценностей.
4. Создать системный триггер на уровне схемы, который будет фиксировать в отдельно организованной таблице информацию о пользователях и объектах, структуру которых создают.
Вариант 18
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице стоимость ремонта и код мастера, который
выполнил ремонт при добавлении записи в таблицу регистрации выполненных работ, причем если информация о мастере была уже добавлена, то стоимость ремонта суммируется, иначе добавляем новую
запись.
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице старое и новое наименования этапа работы
при изменении данных в таблице с описанием возможных этапов работ.
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице тип, пользователя и дату операции при
изменении, удалении или удалении данных из таблицы мастеров.
4. Создать системный триггер, который будет фиксировать в отдельно
организованной таблице информацию об отключаемых пользователях и датах операции.
Вариант 19
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице данные о лекарстве, которые удаляются.
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице номера чеков и наименования лекарства при
добавлении записи в таблицу СОСТАВ ЧЕКА с условием, что количество проданного лекарства больше 10.
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице тип, пользователя и дату операции при
изменении, удалении или удалении данных из таблицы с общей информацией о чеке.
4. Создать системный триггер, который будет фиксировать в отдельно
организованной таблице информацию о подключаемых пользователях и датах операции.
Вариант 20
1. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице информацию об исполнителе, при изменении даты приема на работу.
85
2. Создать строковый триггер, который будет фиксировать в отдельно
организованной таблице старое и новое содержания документа, если
в таблице регистрации документов удаляется или изменяется запись.
3. Создать операторный триггер, который будет фиксировать в отдельно организованной таблице тип, пользователя и дату операции при
изменении, удалении или удалении данных из таблицы учета исполнения документов.
4. Создать системный триггер, который будет фиксировать в отдельно
организованной таблице информацию о пользователях, запускающих
экземпляр БД, и датах операции.
Лабораторная работа No7
СОЗДАНИЕ КЛИЕНТСКОЙ ЧАСТИ ПРИЛОЖЕНИЯ
ДЛЯ ПРОСМОТРА, РЕДАКТИРОВАНИЯ ДАННЫХ БД.
ВЫЗОВ ХРАНИМЫХ ПРОЦЕДУР ИЗ КЛИЕНТСКОЙ ЧАСТИ
Цель работы – научиться создавать клиентское приложение для работы с
базой данных с применением встроенных инструментов в среде Delphi 7.
Содержание работы:
1. Выполнение всех заданий по ходу лабораторной работы.
2. Выполнение индивидуальных заданий.
Пояснения к выполнению работы
Для создания клиентского приложения в Delphi 7 используем пример
базы данных в табличном пространстве DB_Books, которая была создана в
лабораторной работе No1.
При выполнении примеров и заданий обращайте внимание на соответствие названий таблиц и других объектов проекта.
В данной работе при создании клиентского приложения будем использовать встроенные инструменты для работы с данными (в Delphi 7 – вкладка Data Controls).
Если данный проект был выполнен в лабораторной работе с СУБД MS
SQL Server, то в нем необходимо лишь перенастроить свойство Connection
String на соединение с Oracle согласно пункту 4 и перекомпилировать
проект.
В Delphi 7:
1. В новом проекте создадим модуль данных (меню File – New –
DataModule). Переименуем форму в DM (свойство Name – DM).
86
2. В основной форме (например, Form1, переименовать ее в
MainForm) в коде добавить описание модуля DM, для этого после ключевого слова USES в конце списка поставить запятую и дописать название
программного модуля, например UNIT2, который соответствует созданной
форме DM.
3. На форму DM с вкладки ADO добавить компонент ADOConnection
(название, например ADOConnection1), 5 компонентов типа ADOTable
(переименовать компоненты в ADOPurchases, ADOBooks, ADOAuthors,
ADODeliveries, ADOPublish), с вкладки Data Access 5 компонентов типа
DataSource (переименовать компоненты в DataPurchases, DataBooks,
DataAuthors, DataDeliveries, DataPublish).
4. У компонента ADOConnection1 настроить свойства:
Connected String = нажать кнопку Build\ выбрать Поставщик
данных – Microsoft OLE DB Provider for Oracle
Источник данных – ORCL
Пользователь – ADMIN_BOOKS
Пароль – worlds
Получится в результате – Provider=MSDAORA.1;User
ID=ADMIN_BOOKS;Data Source=Orcl;Persist Security
Info=False
LoginPrompt = True;
Connected = True.
5. У ADOAuthors изменить следующие свойства:
Connection на ADOConnection1;
TableName на Authors;
Active на True.
6. У DataAuthors изменить следующие свойства (это будет ссылка на
таблицу):
DataSet на ADOAuthors.
7. У ADOPurchases изменить следующие свойства:
Connection на ADOConnection1;
TableName на Purchases;
Active на True.
8. У DataPurchases изменить следующие свойства (это будет ссылка
на таблицу):
DataSet на ADOPurchases.
9. У ADOBooks изменить следующие свойства:
Connection на ADOConnection1;
TableName на Books;
Active на True.
10. У DataBooks изменить следующие свойства (это будет ссылка на
таблицу):
87
DataSet на ADOBooks.
11. У ADODeliveries изменить следующие свойства:
Connection на ADOConnection1;
TableName на Deliveries;
Active на True.
12. У DataDeliveries изменить следующие свойства (это будет ссылка
на таблицу):
DataSet на ADODeliveries.
13. У ADOPublish изменить следующие свойства:
Connection на ADOConnection1;
TableName на Publishing_house;
Active на True.
14. У DataPublish изменить следующие свойства (это будет ссылка на
таблицу):
DataSet на ADOPublish.
15. На основной форме (MainForm) добавить компонент Меню с
вкладки Standart. В редакторе меню сделать первый пункт «Работа с таблицами» и в подменю пункты «Авторы», «Книги», «Издательства», «Поставщики», «Поставки».
16. Создать пять форм, каждую из которых назвать (изменить свойство
Name): FormAuthors, FormPurchases, FormBooks, FormDeliveries,
FormPublish. В главной форме, в коде добавить описание этих форм, для
этого после ключевого слова USES в конце списка через запятую дописать
названия программных модулей, которые соответствуют описанным формам. В каждой из созданных форм в коде добавить описание модуля DM,
для этого после ключевого слова USES в конце списка поставить запятую
и дописать название программного модуля, например UNIT2, который соответствует созданной форме DM.
17. На основной форме в подпунктах меню в соответствующих методах Click вызвать соответствующие формы с помощью кода:
для FormAuthors:
DM.ADOAuthors.Open;
FormAuthors:=TFormAuthors.Create(Application);
FormAuthors.Show;
для FormPurchases:
DM.ADOPurchases.Open;
FormPurchases:=TFormPurchases.Create(Application);
FormPurchases.Show;
для FormBooks:
DM.ADOBooks.Open;
FormBooks:=TFormBooks.Create(Application);
FormBooks.Show;
88
для FormDeliveries:
DM.ADODeliveries.Open;
FormDeliveries:=TFormDeliveries.Create(Application);
FormDeliveries.Show;
для FormPublish:
DM.ADOPublish.Open;
FormPublish:=TFormPublish.Create(Application);
FormPublish.Show;
18. На формы FormAuthors, FormPurchases, FormBooks, FormDeliveries,
FormPublish добавить с вкладки Data Controls по паре компонент типа
DBGrid и DBNavigator. Настроить у DBGrid и DBNavigator свойство
DataSource для связи с соответствующим источником данных.
19. Проверить работу приложения.
20. На форму FormBooks с вкладки Data Controls добавить 3 компонента типа DBEdit, 2 компонента типа DBLookupComboBox.
У 1-го компонента DBEdit изменить свойства:
Name на DBE_Code_Book;
DataSource на DM.DataBooks;
DataField на Code_book.
У 2-го компонента DBEdit изменить свойства:
Name на DBE_Title_book;
DataSource на DM.DataBooks;
DataField на Title_book.
У 3-го компонента DBEdit изменить свойства:
Name на DBE_Pages;
DataSource на DM.DataBooks;
DataField на Pages.
У 1-го компонента DBLookupComboBox изменить свойства:
Name на DBL_Code_author;
DataSource на DM.DataBooks;
DataField на Code_author;
ListSource на DM.DataAuthors;
ListField на name_author;
KeyField на Code_author.
У 2-го компонента DBLookupComboBox изменить свойства:
Name на DBL_Code_Publish;
DataSource на DM.DataBooks;
DataField на Code_publish;
ListSource на DM.DataPublish;
ListField на Publish;
KeyField на Code_publish.
89
Рядом с каждым настроенным компонентом поставить Label (надпись),
у которой в свойстве Caption написать, например, "Введите название книги" и т.д.
У компонента DBGrid настроить свойство ReadOnly в режим True.
Так как на форме будут использоваться компоненты DBLookupComboBox, которые ссылаются на таблицы Authors и Publishing_house, нужно
на основной форме в подпункте меню "Книги" в методе Click добавить в
начало две команды:
DM.ADOPublish.Open;
DM.ADOAuthors.Open;
В противном случае при открытии формы может произойти ошибка,
если по какой-то причине источники данных для компонент
DBLookupComboBox будут неактивны.
21. Аналогично для остальных форм добавить элементы типа DBEdit
(для полей данные которых будут просто набираться или редактироваться
пользователем) и DBLookupComboBox (для полей связи, к которым подходит связь типа «много», они позволят выбирать данные из соответствующего справочника и пользователю не придется помнить значения кодов).
22. Проверить работу приложения.
23. Теперь необходимо создать фильтры по текущим значениям полей
таблицы. Значения для фильтра будут браться из колонок DBGrid. Например, строка formbooks.DBGrid1.Columns.Items[0].Field.Text; будет брать
текущее значение из первой колонки DBGrid. Поэтому при выполнении
этого задания обращайте внимание на соответствие индексов колонки порядку полей и исправьте при необходимости индексы в соответствии с вашим порядком полей в таблице.
На форму FormBooks с вкладки Standart добавить 5 компонентов типа
Button.
У 1-го компонента Button изменить свойства и метод:
Name на B_Publish;
Caption на Фильтр по текущему издательству;
В методе Click кнопки написать код:
dm.ADOBooks.Filter:= 'Code_Publish = '+ formbooks.DBGrid1.Columns.Items[4].Field.Text;
dm.ADOBooks.Filtered:= true;
У 2-го компонента Button изменить свойства и метод:
Name на B_Title_Book;
90
Caption на Фильтр по текущему названию книги.
В методе Click кнопки написать код:
dm.ADOBooks.Filter:= 'Title_book = '+ QuotedStr( formbooks.DBGrid1.Columns.Items[1].Field.Text);
dm.ADOBooks.Filtered:= true;
У 3-го компонента Button изменить свойства и метод:
Name на B_Author;
Caption на Фильтр по текущему автору.
В методе Click кнопки написать код:
dm.ADOBooks.Filter:= 'Code_Author = '+ formbooks.DBGrid1.Columns.Items[0].Field.Text;
dm.ADOBooks.Filtered:= true;
У 4-го компонента Button изменить свойства и метод:
Name на B_Pages;
Caption на Фильтр по количеству страниц в книге.
В методе Click кнопки написать код:
dm.ADOBooks.Filter:= 'Pages = '+ formbooks.DBGrid1.Columns.Items[3].Field.Text;
dm.ADOBooks.Filtered:= true;
У 5-го компонента Button изменить свойства и метод:
Name на B_Cancel;
Caption на Снять фильтр.
В методе Click кнопки написать код:
dm.ADOBooks.Filter:= '';
dm.ADOBooks.Filtered:= false;
24. Аналогично для остальных форм добавить элементы типа Button,
которые будут запускать фильтры по соответствующим значениям полей
текущей записи в объекте Grid. Пример интерфейса формы представлен на
рис. 7.1.
25. Проверить работу приложения.
26. Создать форму, назвать (изменить свойство Name) FormProcedure.
В главной форме в коде добавить описание этой формы, для этого после
ключевого слова USES в конце списка через запятую дописать название
программного модуля, которое соответствует созданной форме. В созданной форме в коде добавить описание модуля DM, для этого после ключевого слова USES в конце списка поставить запятую и дописать название
программного модуля, например UNIT2, который соответствует созданной
форме DM.
27. Добавить на главной форме в меню пункт с названием Работа с
процедурами. В методе Click пункта меню написать код для запуска формы FormProcedure (см. пример кода в пункте 17 текущей лабораторной
работы).
91
Рис. 7.1. Пример расположения компонентов на форме FormBooks
28. Подключить хранимую процедуру Count_Books_Itogo, выполненную в лабораторной работе No5, которая возвращает одно значение. На
форму DM добавить компонент ADOStoredProc, переименовать компонент
в ADOSP_Count. У ADOSP_Count изменить следующие свойства:
Connection на ADOConnection1;
ProcedureName на Count_Books_Itogo.
29. У компонента ADOSP_Count выбрать свойтсво Parameters и создать 3 параметра:
для Count_pages IN Int:
Name на Count_pages;
Datatype на ftInteger;
Direction на pdInput;
Value–Type на Integer;
для Title IN Char:
Name на Title;
Datatype на ftString;
Direction на pdInput;
Value–Type на OleStr;
для Itogo OUT Int:
Name на Itogo;
Datatype на ftInteger;
Direction на pdOutput;
Value–Type на Integer.
30. На форму FormProcedure добавить 3 компонента типа Edit (имена
соответственно Edit1, Edit2, Edit3) и 1 компонент типа Button. Рядом с каждым компонентом Edit поставить Label и исправить их свойства Caption
92
соответственно на «Введите количество страниц», «Введите название книги», «Количество найденных книг».
31. На кнопке поменять название на «Выполнить запрос». В методе
Click кнопки написать следующий код:
DM.ADOSP_Count.Prepared;
try
DM.ADOSP_Count.Parameters.ParamByName('Count_pages').Value:=StrToInt(Edit1.Text);
DM.ADOSP_Count.Parameters.ParamByName('Title').Value:= Edit2.Text;
DM.ADOSP_Count.ExecProc;
Edit3.Text:= inttostr(DM.ADOSP_Count.Parameters.ParamByName('Itogo').Value);
finally
DM.ADOSP_Count.Prepared:=not(DM.ADOSP_Count.Prepared);
end;// try
32. Проверить работу приложения.
33. Для вывода данных из нескольких таблиц можно использовать
представления (View), которые создаются и хранятся на сервере.
Создать представление на сервере, которое будет хранить информацию
о названии книги, авторе, издательстве. Для этого в утилите SQL *Plus
Worksheet напишите следующий код и выполните (F5):
CREATE OR REPLACE VIEW admin_books.view_books
AS
SELECT a.name_author AS "NAME_AUTHOR1",
b.title_book AS "TITLE_BOOK1",c.publish AS "PUBLISH1"
FROM (ADMIN_BOOKS.AUTHORS a INNER JOIN ADMIN_BOOKS.BOOKS b on
a.code_author=b.code_author)
INNER JOIN ADMIN_BOOKS.PUBLISHING_HOUSE c ON b.code_publish =
c.code_publish
34. Подключить созданное представление через ADOQuery. На форму
DM добавить компонент ADOQuery, переименовать компонент в
ADOView_Books. У ADOView_Books изменить следующие свойства:
Connection на ADOConnection1;
SQL на
select * from admin_books.view_books
35. Для компонента ADOView_Books добавить на форму DM компонент DataSource и присвоить его свойствам следующие значения:
Name на Data_Books_All;
DataSet на ADOView_Books.
36. На форму FormProcedure добавить DBGrid, 1 компонент типа
Button и 1 компонент типа Edit. Рядом с полем Edit поставить метку с текстом "Введите фамилию искомого автора". В свойстве Datasource компонента DBGrid выбрать Data_Books_All. На кнопке поменять название на
«Выполнить запрос». В методе Click кнопки написать следующий код:
DM.ADOView_Books.Open;
IF trim(Edit4.Text)<>'' then
begin
93
DM. ADOView_Books.Filter:='name_author1='+ QuotedStr(Edit4.Text);
DM.ADOView_Books.Filtered:=True;
end
else
DM.ADOView_Books.Filtered:=False;
DBGrid1.Refresh;
37. Проверить работу приложения.
Задания к лабораторной работе No7
В Delphi 7 создать новый проект, далее для индивидуальной БД, созданной в лабораторной работе No1, создать интерфейс, включающий все
функции и процедуры, которые описаны по ходу текущей лабораторной
работы.
Лабораторная работа No8
СОЗДАНИЕ АДМИНИСТРАТИВНОЙ СТРАНИЦЫ
Цель работы – научиться организовывать со стороны клиентского приложения удаленное управление правами доступа к данным экземпляра БД.
Содержание работы:
1. Выполнение всех заданий по ходу лабораторной работы.
2. Выполнение индивидуальных заданий.
Пояснения к выполнению работы
Для создания в приложении административной страницы используем
пример базы данных в табличном пространстве DB_Books, которая была
создана в лабораторной работе No1, а также используем клиентское приложение, которое было создано в лабораторной работе No7. При выполнении
примеров и заданий обращайте внимание на соответствие названий объектов экземпляра БД, таблиц и других объектов проекта.
В SQL *Plus Worksheet:
Создадим процедуру добавления нового пользователя в табличное
пространство DB_Books в разделе Schema – Procedure – ADMIN_BOOKS
через утилиту SQL *Plus Worksheet:
CREATE OR REPLACE PROCEDURE admin_books.add_user(name_user IN
varchar2,
passw IN VARCHAR2, table_space IN VARCHAR2) IS
sql_text varchar2(200);
BEGIN
94
sql_text:='CREATE USER '|| TRIM(NAME_USER)||' PROFILE
"DEFAULT" IDENTIFIED BY '||TRIM(PASSW)||' DEFAULT
TABLESPACE '||TRIM(TABLE_SPACE)||' ACCOUNT UNLOCK';
EXECUTE IMMEDIATE sql_text;
sql_text:='GRANT ALTER SESSION TO '||TRIM(NAME_USER);
EXECUTE IMMEDIATE sql_text;
sql_text:='GRANT CREATE SESSION TO '||TRIM(NAME_USER);
EXECUTE IMMEDIATE sql_text;
Commit;
END;
В данной процедуре использованы операторы Dynamic SQL.
В Delphi 7:
1. В проекте из лабораторной работы No7 на форму DM добавим компонент ADOStoredProc (название по умолчанию будет ADOStoredProc1).
У компонента ADOStoredProc1 изменить свойства:
Connection на ADOConnection1;
ProcedureName на ADD_USER.
2. У компонента ADOStoredProc1 выбрать Parameters и создать 3 параметра:
для name_user IN varchar2:
Name на name_user;
Datatype на ftString;
Direction на pdInput;
Value–Type на OleStr;
для passw IN varchar2:
Name на passw;
Datatype на ftString;
Direction на pdInput;
Value–Type на OleStr;
для table_space IN varchar2:
Name на table_space;
Datatype на ftString;
Direction на pdInput;
Value–Type на OleStr.
Добавить на основной форме (Form1) в меню пункт с названием Администрирование. Создать форму FormAdmin, которая будет запускаться из пункта меню Администрирование основной формы.
3. В главной форме, в коде добавить описание формы FormAdmin,
для этого после ключевого слова USES в конце списка через запятую до95
писать название программного модуля, которое соответствует созданной
форме. В созданной форме в коде добавить описание модуля DM, для этого после ключевого слова USES в конце списка поставить запятую и дописать название программного модуля, например UNIT2, который соответствует созданной форме DM.
4. На форме FormAdmin расположить три компонента Edit1, Edit2 и
DBLookupComboBox1, один компонент Button. Рядом с компонентами типа Edit поставить элементы Label, в которых соответственно изменить
свойства Caption на «Введите имя нового пользователя» и «Введите пароль», «Выберите табличное пространство по умолчанию».
5. Для настройки компонента DBLookupComboBox1 на форму DM
добавить
компонент
ADOQuery,
переименовать
компонент в
ADOQuery_ts. У ADOQuery_ts изменить следующие свойства:
Connection на ADOConnection1;
SQL на
select name from sys.ts$
Таблица sys.ts$ содержит информацию о табличных пространствах
Oracle.
Для компонента ADOQuery_ts добавить на форму DM компонент
DataSource и присвоить его свойствам следующие значения:
Name на DataSource_ts;
DataSet на ADOQuery_ts.
У компонента DBLookupComboBox1 настроить свойства:
ListSource на DM.DataSource_ts;
ListField на NAME;
KeyField на NAME.
6. В методе Click созданной кнопки написать:
try
DBLookupComboBox1.Refresh;
dm.ADOStoredProc1.Parameters.ParamByName('name_user').Value:= Edit1.Text;
dm.ADOStoredProc1.Parameters.ParamByName('passw').Value:= Edit2.Text;
dm.ADOStoredProc1.Parameters.ParamByName('table_space').Value:=
DBLookupComboBox1.Text;
DM.ADOStoredProc1.ExecProc;
ShowMessage('Пользователь добавлен');
except
ShowMessage('Невозможно добавление пользователя');
end; // try
7. В пункте меню Администрирование перед оператором запуска
формы FormAdmin добавить оператор, чтобы гарантировать для выпадающего списка работоспособность источника данных:
dm.ADOQuery_ts.Open;
96
8. Запустить приложение и проверить работу. Но для создания нового
пользователя вы должны запустить приложение от пользователя, обладающего привилегией CREATE USER, GRANT ANY PRIVILEGE.
В SQL *Plus Worksheet:
Создадим процедуру добавления новой привилегии пользователя в
табличное пространство DB_Books в разделе Schema – Procedure –
ADMIN_BOOKS через утилиту SQL *Plus Worksheet:
CREATE OR REPLACE PROCEDURE admin_books.add_privileg (name_user
IN varchar2, privileg IN VARCHAR2, object IN VARCHAR2) IS
sql_text varchar2(200);
BEGIN
sql_text:='GRANT '||TRIM(privileg)|| ' ON '||TRIM(object)|| ' TO '||
TRIM(NAME_USER);
EXECUTE IMMEDIATE sql_text;
Commit;
END;
В Delphi 7:
1. В проекте, который был создан в лабораторной работе No8, на форму DM добавим компонент ADOStoredProc (название по умолчанию будет
ADOStoredProc2).
У компонента ADOStoredProc2 изменить свойства:
Connection на ADOConnection1;
ProcedureName на ADD_PRIVILEG.
2. У компонента ADOStoredProc2 выбрать Parameters и создать 3 параметра:
для name_user IN varchar2:
Name на name_user;
Datatype на ftString;
Direction на pdInput;
Value–Type на OleStr;
для privileg IN varchar2:
Name на privileg;
Datatype на ftString;
Direction на pdInput;
Value–Type на OleStr;
для object IN varchar2:
Name на object;
Datatype на ftString;
Direction на pdInput;
97
Value–Type на OleStr.
3. На форме FormAdmin расположить три компонента типа
DBLookupComboBox, один компонент Button. Рядом с компонентами типа
DBLookupComboBox поставить элементы Label, в которых соответственно
изменить свойства Caption на «Выберите объект, на который добавляется
привилегия», «Выберите пользователя» и «Выберите привилегию».
4. Для настройки компонентов DBLookupComboBox на форму DM
добавить три компонента ADOTable и три DataSource, переименовать компоненты и изменить свойства соответственно:
для ADOTable1:
Name на ADO_all_all_tables;
Connection на ADOConnection1;
TableName на all_all_tables;
Filter на TABLESPACE_NAME='DB_BOOKS';
Filtered на True;
для DataSource1:
Name на DS_all_all_tables;
DataSet на ADO_all_all_tables;
для ADOTable2:
Name на ADO_dba_users;
Connection на ADOConnection1;
TableName на DBA_users;
Filter на DEFAULT_TABLESPACE='DB_BOOKS';
Filtered на True;
для DataSource2:
Name на DS_dba_users;
DataSet на ADO_dba_users;
для ADOTable3:
Name на ADO_Table_privilege_map;
Connection на ADOConnection1;
TableName на Table_privilege_map;
для DataSource3:
Name на DS_Table_privilege_map;
DataSet на ADO_Table_privilege_map;
У компонента DBLookupComboBox2 настроить свойства:
ListSource на DS_all_all_tables;
ListField на TABLE_NAME;
KeyField на TABLE_NAME.
У компонента DBLookupComboBox3 настроить свойства:
ListSource на DS_dba_users;
98
ListField на USERNAME;
KeyField на USERNAME.
У компонента DBLookupComboBox4 настроить свойства:
ListSource на DS_Table_privilege_map;
ListField на NAME;
KeyField на NAME.
5. В методе Click созданной кнопки написать:
try
DBLookupComboBox2.Refresh;
DBLookupComboBox3.Refresh;
DBLookupComboBox4.Refresh;
dm.ADOStoredProc2.Parameters.ParamByName('object').Value:=
DBLookupComboBox2.Text;
dm.ADOStoredProc2.Parameters.ParamByName('name_user').Value:=
DBLookupComboBox3.Text;
dm.ADOStoredProc2.Parameters.ParamByName('privileg').Value:=
DBLookupComboBox4.Text;
DM.ADOStoredProc2.ExecProc;
ShowMessage('Пользователь добавлен');
except
ShowMessage('Невозможно добавление пользователя');
end; // try
6. В пункте меню Администрирование перед оператором запуска
формы FormAdmin добавить оператор, чтобы гарантировать для выпадающих списков работоспособность источников данных:
dm.ADO_all_all_tables.Open;
dm.ADO_DBA_USERS.Open;
dm.ADO_Table_privilege_map.Open;
7. Запустить приложение и проверить работу.
Задания к лабораторной работе No8
В вашей индивидуальной базе данных, которая была выдана по вариантам (из лабораторной работы No1), создать 4 хранимые процедуры, которые будут выполнять операции по добавлению пользователя, удалению
пользователя, добавлению разрешения на одну из таблиц, удалению разрешения на одну из таблиц. В клиентском приложении, которое было создано в лабораторной работе No7 по вашему варианту, добавить на основную форму в меню пункт Администрирование, который будет запускать
форму Администрирование. На форме организовать запуск четырех созданных хранимых процедур с передачей данных в процедуры на сервере
99
из клиентского приложения. Цель задания − создание удаленного управления правами доступа к объектам вашего табличного пространства.
Лабораторная работа No9
СОЗДАНИЕ ОТЧЕТНЫХ ФОРМ В КЛИЕНТСКОМ ПРИЛОЖЕНИИ
С ПРИМЕНЕНИЕМ RAVE REPORT 5
Цель работы – научиться создавать формы отчетных документов по данным БД с применением Rave Report.
Содержание работы:
1. Выполнение все заданий по ходу лабораторной работы.
2. Выполнение индивидуальных заданий.
Спасибо студенту Полозову Василию за помощь в подготовке материалов к этой лабораторной работе.
Пояснения к выполнению работы
Для выполнения трех первых заданий используем пример базы данных
c названием DB_Books, которая была создана в лабораторной работе
No1. При выполнении примеров и заданий обращайте внимание на соответствие названий БД, таблиц и других объектов проекта.
Отчеты во многом похожи на формы и тоже позволяют получить результаты работы запросов в наглядной форме, но только не на экране, а в
виде распечатки на принтере. Таким образом, в результате работы отчета
создается бумажный документ.
Простой отчет представляет собой отчет на основе данных из одного набора данных и содержит сведения, которые выводятся в табличном виде без какой-либо дополнительной обработки данных (например,
группирования). Размещение и вид печатаемых в отчете данных аналогичны размещению и виду данных, отображаемых в сетке DBGrid. Отличием является то, что данные отчета не размещаются в форме, а представлены в виде бумажного документа и их нельзя редактировать.
Рассмотрим последовательность шагов, которую требуется выполнить
приложению базы данных.
В Delphi 7 есть несколько способов создания отчетов, познакомимся
с компонентами Rave.
Задание 1. Создание отчета в табличной форме по запросу, который выбирает из таблицы Books все поля, кроме кодов, из таблицы Publish_house −
100
название издательства и место издательства, из таблицы Authors − имя автора.
1. Откроем приложение базы данных Delphi, для которого требуется
добавить простой отчет.
2. В проекте на главной форме в меню добавить пункт меню Отчеты,
а также подпункты:
Отчет в табличной форме;
Отчет в свободной форме;
Отчет с группировкой по двум таблицам.
3. В проекте на форму DM добавить компонент ADOQUERY1, у которого изменить SQL на соответствующий запрос (см. текст задания):
select * from books, authors, publishing_house where
books.code_author = authors.code_author AND
books.code_publish = publishing_house.code_publish,
а свойство Connection на ADOConnection1. Активизировать запрос.
4. В проекте на форму DM с вкладки Rave поместим компонент
RvDataSetConnection. У свойства DataSet установить ссылку на
ADOQUERY1.
5. С помощью визуального конструктора отчетов подготовим отчет и
создадим файл проекта отчета. Для этого:
5.1. с помощью команды Tools\Rave Designer меню Delphi запустим
визуальный конструктор Rave Reports 5.0;
5.2. выбором команды File\New Data Object откроем диалоговое окно
Data Connections и выберем в нем вариант Direct Data View;
5.3. в очередном диалоговом окне в списке Active Data Connections
выберем вариант RVDataSetConnection1 и нажмем кнопку Finish;
5.4. в дереве проекта в правой части окна визуального конструктора отчетов раскроем узел Data View Dictionary и в нем раскроем вновь
созданный узел DataView1;
5.5. выбрав команду меню Tools\Report Wizards\Simple Table, запустим мастер создания простых таблиц в отчете, в котором выберем вариант
DataView1 и нажмем кнопку Next;
5.6. на последующих шагах работы с Мастером выберем поля таблицы для отображения в отчете, при необходимости изменим очередность следования полей, установим параметры полей страницы,
текст заголовков и шрифтов, используемых в отчете;
5.7. на заключительном этапе работы с Мастером нажатием кнопки
Generate запустим процесс генерации отчета;
5.8. для просмотра сгенерированного отчета выберем команду
File\Execute Report, в открывшемся диалоговом окне Output Options в
поле Report Destination выберем переключатель Preview и нажмем ОК.
Вид полученного нами отчета при просмотре приведен на рис. 9.1;
101
5.9. при необходимости выполним настройку параметров (шрифта –
заменить на Courier, цвета и др.) отдельных составляющих созданного отчета, все подписи сделать на русском языке (рис. 9.2);
5.10. сохраним созданный нами проект отчета в файле с произвольным
именем, например Report1, и расширением .rav с помощью команды
File\Save As;
5.11. свернем или закроем диалоговое окно работы с визуальным конструктором отчета и вернемся к работе с приложением в Delphi.
Рис. 9.1. Пример сгенерированного табличного отчета в режиме Preview
Рис. 9.2. Пример исправленного табличного отчета в режиме Preview
6. На главную форму MainForm клиентского приложения с вкладки
Rave поместим компонент RvProject и установим значение Report1.RAV
102
(спецификация созданного нами файла проекта) свойству ProjectFile этого
компонента с помощью Инспектора объектов.
7. В главной форме приложения в подпункте Отчет в табличной
форме в методе Click вызываем метод Execute, обеспечивающий выполнение отчета (в нашем примере Report1) из состава проекта отчета (компонента RvProjectl):
dm.ADOQuery1.Open;
RvProject1.Open;
try
RvProject1.Execute;
finally
RvProject1.Close;
end;//try
8. Запустим приложение, проверим работу отчета.
Задание 2. Создание отчета в свободной форме по запросу из первого задания. Создадим карточку книги для библиотечной картотеки.
Особенность отчета в свободной форме в том, что он создает шаблон на
каждую отдельную запись таблицы, другими словами, он создается по
документам, у которых нет шапки и примечаний. Примером таких документов могут служить приходный или расходный кассовые ордера,
этикетка для товара или ценник в магазине, пригласительное письмо и
т.д.
Продолжаем работу с визуальным конструктором отчетов Rave
Reports 5.0; Создаем новый отчет, для этого:
1. С помощью команды Tools\Rave Designer меню Delphi снова запустим визуальный конструктор Rave Reports 5.0.
2. Создаем новый отчет выбором команды File\New Report.
3. Устанавливаем компонент Region с вкладки Report, который является контейнером для компонентов Band (Полоса), у которого установить
следующие свойства:
Column на 2;
ColumnSpacing на 0,1;
Height на 10,6;
Width на 8,1.
4. Устанавливаем компонент DataBand component с вкладки Report
в область Region, у которого установить следующие свойства:
DataView на DataView1;
KeepRowTogether на True;
Height на 3.
103
5. Размещаем компонент Bitmap с вкладки Standart на DataBand
component и настраиваем следующие свойства:
Image на какой-либо рисунок;
MatchSide на msBoth;
Height на 2,6;
Width на 3,8.
6. Размещаем три компонента DataText с вкладки Report на форму
согласно рис. 9.3. Устанавливаем свойствам всех трех компонент следующие значения: DataView – DataView1; Font – Courier, 15, Bold; Width –
3,6; для свойства DataField – title_book, name_author, publish соответственно.
Рис. 9.3. Пример расположения компонентов
с изображением на заднем фоне
7. Размещаем три компонента Text с вкладки Standart на форму согласно рис. 9.3 и устанавливаем свойству Text – “Название книги”, “Автор”, “Издательства” соответственно, свойству Font – Courier, 14.
8. Сохранить отчет с названием Report2.rav.
9. На главную форму MainForm клиентского приложения с вкладки
Rave поместим компонент RvProject и установим значение Report2.RAV
(спецификация созданного нами файла проекта) свойству ProjectFile этого
компонента с помощью Инспектора объектов.
10. В главной форме приложения в подпункте Отчет в свободной
форме в методе Click вызываем метод Execute, обеспечивающий выполнение отчета (в нашем примере Report2) из состава проекта отчета (компонента RvProject2):
dm.ADOQuery1.Open;
RvProject2.Open;
try
104
RvProject2.Execute;
finally
RvProject2.Close;
end;//try
11. Запустите приложение, проверьте работу.
Задание 3. Создание отчета по двум таблицам. Создадим отчет с группировкой, в котором сначала будут выводиться данные автора книги из таблицы Authors, а затем список книг, которые написал этот автор.
В проекте на форму DM с вкладки Rave поместим 2 компонента
RvDataSetConnection, заменить их имена на RV_Authors и RV_Books. У
свойства DataSet установить ссылку по очереди на соответствующие компоненты ADOAuthors и ADOBooks.
Продолжаем работу с визуальным конструктором отчетов Rave
Reports 5.0. Создаем новый отчет, для этого:
С помощью команды Tools\Rave Designer меню Delphi снова запустим
визуальный конструктор Rave Reports 5.0.
Создаем новый отчет выбором команды File\New Report.
Выбором команды File\New Data Object откроем диалоговое окно Data
Connections и выберем в нем вариант Direct Data View. В следующем окне
выберем в качестве активных источников данных RV_Authors и
RV_Books. В правом окне RaveProject будут добавлены разделы
DataView2 и DataView3.
Устанавливаем компонент Region с вкладки Report, который является
контейнером для компонентов Band (Полоса), у которого установить следующие свойства:
Height на 10,6;
Width на 8,1.
Устанавливаем 2 компонента Band с вкладки Report в область Region.
Помещаем в каждую добавленную полосу по компоненту Text с вкладки
Standart. В первой полосе у компонента Text меняем следующие свойства:
Font на Courier, 15, Bold;
Text на Отчет с группировкой.
Во второй полосе у компонента Text меняем следующие свойства:
Font на Courier, 15, Bold;
Text на Ф.И.О. автора.
Устанавливаем 2 компонента DataBand с вкладки Report в область
Region, у которых изменить свойство DataView на DataView2 и
DataView3 соответственно. Помещаем в каждую добавленную полосу по
компоненту DataText с вкладки Report. В первой полосе у компонента
DataText меняем следующие свойства:
105
DataView на DataView2;
DataField на name_author.
Ниже под компонентом DataText помещаем компонент Text, где меняем надпись на «Названия книг данного автора».
Во второй полосе у компонента DataText меняем следующие свойства:
DataView на DataView3;
DataField на Title_book.
Пример размещения компонент на форму представлен на рис. 9.4.
Рис. 9.4. Пример расположения компонентов отчета по двум таблицам
В отчете присутствуют два соответствующих представления данных,
каждое из которых подключено к компоненту DataBand (оба компонента
располагаются внутри региона).
Первый компонент DataBand1 ассоциирован с основным набором
данных и не обладает какими-либо специальными настройками.
Второй компонент DataBand2 определяет отношения типа «основное/подробности»,
используя
несколько
свойств.
Свойство
MasterDataView ссылается на представление данных основного набора
данных DataView2, а свойства MasterKey и DetailKey ссылаются на поля,
при помощи которых определяется объединение, в данном случае оба этих
свойства ссылаются на поле Code_author. Свойство ControllerBand ссылается на компонент DataBand1, который отображает данные из основного набора данных. Кроме того, для отображения данных из подчиненной
таблицы, в данном случае Books, нужно настроить свойство компонента
DataBand2 – BandStyle, нажав рядом со свойством кнопку «...». В окне
Band Style Editor отметить свойство Detail(D).
Если вы не хотите, чтобы отображаемые подробности переходили на
следующую страницу (в этом случае основные данные и часть подробностей будут располагаться на разных страницах), присвойте свойству
106
KeepRowTogether значение True.
Сохранить отчет с названием Report3.rav.
На главную форму MainForm клиентского приложения с вкладки Rave
поместим компонент RvProject и установим значение Report3.RAV (спецификация созданного нами файла проекта) свойству ProjectFile этого
компонента с помощью Инспектора объектов.
В главной форме приложения в подпункте Отчет с группировкой в
методе Click вызываем метод Execute, обеспечивающий выполнение отчета (в нашем примере Report3) из состава проекта отчета (компонента
RvProject3):
dm.ADOAuthors.Open;
dm.ADOBooks.Open;
RvProject3.Open;
try
RvProject3.Execute;
finally
RvProject3.Close;
end;//try
Запустите приложение, проверьте работу.
Варианты заданий к лабораторной работе No9
По индивидуальной базе данных, которая выдана по вариантам (из лабораторной работы No1), сделать в клиентском приложении четыре отчета,
которые будут запускаться через меню главной формы:
- отчет в табличной форме по одному из справочников, причем необходимо вывести итоговое количество записей в отчете;
- отчет в свободной форме. Выберите одну из таблиц, по которой можно
сделать или бейдж, или ценник, или пригласительный билет. При создании отчета используйте рисунок в качестве подложки;
- отчет по запросу. Соедините данные всех основных таблиц, кодовые поля в запрос не помещайте. Создайте отчет в табличной форме с итоговым полем. Это может быть сумма или количество и т.п., в зависимости
от содержания запросов. Каждая строка в отчете должна иметь номер по
порядку. Например (см. фрагмент ниже):
1) Крупа 10 кг
2) Мука 20 кг
и т.д.;
- отчет с группировкой по нескольким таблицам. Выберите одну пару
связанных таблиц, определите главную и зависимую таблицы и сделайте
отчет в табличной форме, в котором данные из главной таблицы расшифровываются (дополняются) данными из зависимой таблицы.
107
Лабораторная работа No10
ИЕРАРХИЧЕСКИЕ СТРУКТУРЫ ДАННЫХ И УЧЕТ
ВЕРСИОННОСТИ ПРИ РАБОТЕ C ДАННЫМИ И МОДЕЛЯМИ
Цель работы – научиться средствами реляционной объектноориентированной СУБД создавать базы моделей, а также хранить историю
работы и версии текстов, программного кода и математических моделей в
форме иерархических структур.
Содержание работы:
1. Познакомиться с примером представления иерархической структуры
в СУБД.
2. Познакомиться с понятием версионности и способом учета ее в БД.
3. Выполнение примера по ходу лабораторной работы.
4. Выполнение индивидуальных заданий.
Пояснения к выполнению работы
Задача организации хранения и обращения к версиям текстовых документов решается в современных системах документооборота, также как и
задача многоступенчатого утверждения документов в электронном виде.
При этом если обратить внимание на работу специалистов, занимающихся
задачами моделирования сложных технических объектов (СТО) и динамических систем, то можно увидеть, что их процесс работы также носит ступенчатый характер, нет последовательного развития модели, есть версии
модели, которые либо последовательно накладываются одна на другую,
либо происходит откат к одной из более ранних версий и ее дальнейшее
развитие. В результате, если рассматривать процесс моделирования в современных системах, то мы приходим к необходимости хранения иерархически связанных версий модели.
В работе [http://semenova-ii.narod.ru/model/MS_IT_Semenova.pdf] описан подход к формированию модели СТО, особенностью которого является возможность учета всех компонентов модели и их сочетаний (многокомпонентность и многовариантность), показывающие полную картину
режимов эксплуатации СТО (рис. 10.3).
Эту многовариантную и многокомпонентную структуру, удобно формализовать посредством языка морфологических графов, аналогичных тем,
что используются для автоматизации структурного синтеза систем. В данном способе И-компонентом будет выступать варьируемый параметр, для
которого обязательно нужно выбрать вариант уравнения, по которому, он
будет определяться, а ИЛИ-компонентом будет уравнение или константа,
108
которые играют роль варианта для определяемого родительского параметра. Любой возможный вариант сборки модели однозначно задаётся поддеревом, включающим корневую вершину, всех её потомков (И–типа), и последующим присоединением к каждому И-потомку одного из его ИЛИпотомков, и к каждому ИЛИ-потомку – всех его И-потомков. Выбор поддерева продолжается до тех пор, пока все включённые в него потомки самого нижнего уровня не окажутся листьями, т. е. известными функциями
времени или константами.
При подобной организации представления модели версия модели – это
совокупность компонент модели в И-ИЛИ дереве, над которыми были выполнены операции модификации и/или добавления, и/или удаления по отношению к родительской версии, версия модели может быть создана на
базе любой из уже существующих. Первая версия модели считается корневой. На рис. 10.1 представлен фрагмент базы данных, организующей хранение И-ИЛИ деревьев моделей и их версий.
Рис. 10.1. Фрагмент структуры базы данных, хранящей
И-ИЛИ деревья моделей и их версии
Для создания проекта по работе с деревьями, информация о которых
хранится в БД, представленной на рис. 10.1, в Oracle нужно создать
пользователя с помощью следующего кода:
CREATE USER "ADMIN_TREE" PROFILE "DEFAULT" IDENTIFIED BY "worlds"
DEFAULT TABLESPACE "USERS" TEMPORARY TABLESPACE "TEMP" ACCOUNT
UNLOCK;
109
COMMIT;
GRANT "CONNECT" TO "ADMIN_TREE" WITH ADMIN OPTION;
GRANT "DBA" TO "ADMIN_TREE" WITH ADMIN OPTION;
GRANT "EXP_FULL_DATABASE" TO "ADMIN_TREE" WITH ADMIN OPTION;
COMMIT;
Далее от имени пользователя ADMIN_TREE создать табличное
пространство и переопределить для пользователя табличное пространство
по умолчанию:
CREATE TABLESPACE "DB_TREE" LOGGING DATAFILE
'C:\ORACLE\ORADATA\ORCL\DB_TREE.dbf' SIZE 5M EXTENT MANAGEMENT
LOCAL;
ALTER USER "ADMIN_TREE" DEFAULT TABLESPACE "DB_TREE";
Далее создать таблицы БД:
CREATE TABLE ADMIN_TREE.Nodes(Node_id NUMERIC(3) PRIMARY KEY NOT
NULL, Node_type VARCHAR2(50), Textlayer VARCHAR2(50), Schematic_layer BLOB,
Structural_layer VARCHAR2(50), Math_layer BLOB, Algorithmic_layer
VARCHAR2(4000), Procedural_layer VARCHAR2(4000));
CREATE TABLE ADMIN_TREE.Models(Model_id NUMERIC(3) PRIMARY KEY
NOT NULL, Root_id NUMERIC(3) NOT NULL, Model_name VARCHAR2(50),
Create_date DATE NULL, Author VARCHAR2(50), CONSTRAINT FK_Models_Nodes
FOREIGN KEY(Root_id) REFERENCES ADMIN_TREE.Nodes(Node_id));
CREATE TABLE ADMIN_TREE.Versions(Model_id NUMERIC(3) NOT NULL,
Parent_version_id NUMERIC(3) NULL, Version NUMERIC(3) NOT NULL, Version_id
NUMERIC(3) PRIMARY KEY, Create_date DATE DEFAULT SYSDATE NOT NULL,
Version_name VARCHAR2(50), CONSTRAINT FK_Versions_Models FOREIGN
KEY(Model_id) REFERENCES ADMIN_TREE.Models(Model_id));
CREATE TABLE ADMIN_TREE.Tree(Relation_id NUMERIC(3) PRIMARY KEY
NOT NULL, Model_id NUMERIC(3) NOT NULL, Parent_id NUMERIC(3) NULL,
Node_id NUMERIC(3) NOT NULL, Parent_relation_id NUMERIC(3) NULL, Level_
NUMERIC(3) NOT NULL, CONSTRAINT FK_Tree_Models FOREIGN KEY(Model_id)
REFERENCES ADMIN_TREE.Models(Model_id), CONSTRAINT FK_Tree_Nodes
FOREIGN KEY(Parent_id) REFERENCES ADMIN_TREE.Nodes(Node_id),
CONSTRAINT FK_Tree_Nodes1 FOREIGN KEY(Node_id) REFERENCES
ADMIN_TREE.Nodes (Node_id), CONSTRAINT FK_Tree_Tree FOREIGN
KEY(Parent_relation_id) REFERENCES ADMIN_TREE.Tree(Relation_id));
CREATE TABLE ADMIN_TREE.Operations(Operation_id NUMERIC(3) PRIMARY
KEY NOT NULL, Version_id NUMERIC(3), Relation_id NUMERIC(3), Operation char(1),
CONSTRAINT FK_Operations_Tree FOREIGN KEY(Relation_id) REFERENCES
ADMIN_TREE.Tree(Relation_id), CONSTRAINT FK_Operations_Versions FOREIGN
KEY(Version_id) REFERENCES ADMIN_TREE.Versions(Version_id));
Далее создать представление, которое собирает деревья моделей из
всей БД:
110
CREATE VIEW ADMIN_TREE.View_Tree AS
SELECT b.model_id, ADMIN_TREE.Models.model_name, b.relation_id, b.Parent_node,
ADMIN_TREE.Nodes.textlayer AS Child_node, b.Parent_relation_id, b.level_
FROM ADMIN_TREE.Nodes INNER JOIN
(SELECT ADMIN_TREE.Tree.model_id, ADMIN_TREE.Tree.relation_id, a.textlayer
AS Parent_node, ADMIN_TREE.Tree.Node_id, ADMIN_TREE.Tree.Parent_relation_id,
ADMIN_TREE.Tree.level_ FROM (ADMIN_TREE.Nodes a) RIGHT OUTER JOIN
ADMIN_TREE.Tree ON a.Node_id = ADMIN_TREE.Tree.Parent_id) b
ON ADMIN_TREE.Nodes.Node_id = b.Node_id INNER JOIN ADMIN_TREE.Models
ON ADMIN_TREE.Models.model_id = b.model_id ORDER BY b.model_id, b.level_,
b.Parent_node, Child_node;
Далее создать таблицу для временного хранения информации о наборе
версий в процессе работы процедуры ADMIN_TREE.TreeVersion_Model:
CREATE TABLE ADMIN_TREE.temp (ver NUMERIC(3));
commit;
Далее создать таблицу для временного хранения результата работы
процедуры ADMIN_TREE.TreeVersion_Model:
CREATE TABLE ADMIN_TREE.TreeVersion_Temp(version_id NUMERIC(3),
parent_version_id NUMERIC(3), version NUMERIC(3), operation_id NUMERIC(3),
relation_id NUMERIC(3), operation CHAR(1), Parent_relation_id NUMERIC(3), level_
NUMERIC(3), Parent_Node VARCHAR2(50), Child_Node VARCHAR2(50));
Далее создать процедуру, которая из единой базы данных по запросу
клиентского приложения по указанной модели и ее версии может выбрать
интересующую версию конкретной модели и представить в удобном для
клиентского приложения виде:
CREATE PROCEDURE ADMIN_TREE.TreeVersion_Model (idModel IN NUMERIC,
VersionIN IN NUMERIC)
IS
parent_version NUMERIC(3);
version_id NUMERIC(3);
versionIN_ NUMERIC(3);
BEGIN
DELETE FROM ADMIN_TREE.temp;
DELETE FROM ADMIN_TREE.TreeVersion_Temp;
commit;
INSERT INTO ADMIN_TREE.temp VALUES(VersionIN);
SELECT Parent_version_id INTO parent_version FROM ADMIN_TREE.Versions
WHERE model_id=idModel AND version=VersionIN;
WHILE NOT(parent_version IS NULL) LOOP
SELECT version INTO versionIN_ FROM ADMIN_TREE.Versions
WHERE model_id=idModel AND version_id=parent_version;
INSERT INTO ADMIN_TREE.temp VALUES(versionIN_);
SELECT Parent_version_id INTO parent_version FROM ADMIN_TREE.Versions
111
WHERE model_id=idModel AND version= versionIN_;
End LOOP;
сommit;
insert into ADMIN_TREE.TreeVersion_Temp
SELECT S.version_id, S.parent_version_id, S.version, S.operation_id, S.relation_id,
S.operation, S.Parent_relation_id, S.level_, NP.textlayer as Parent_Node, S.Child_Node
FROM ADMIN_TREE.Nodes NP, (SELECT V.parent_version_id,
V.version_id,V.version, O.operation_id, O.relation_id, O.operation, t.Parent_id,
t.Parent_relation_id, t.level_, N.textlayer AS Child_Node FROM ADMIN_TREE.Versions V,
ADMIN_TREE.Operations O, ADMIN_TREE.Tree T, ADMIN_TREE.Nodes N
WHERE V.version_id=O.version_id AND T.relation_id=O.relation_id AND
N.Node_id=T.Node_id AND V.model_id=idModel AND V.version in
(SELECT ver from ADMIN_TREE.TEMP) ) S WHERE NP.Node_id=S.Parent_id
ORDER BY S.operation_id ASC;
END TreeVersion_Model;
Для проверки работы системы в целом нужно заполнить БД тестовыми
данными с помощью следующих команд:
INSERT INTO ADMIN_TREE.Nodes(Node_id, textlayer) VALUES(2, 'узел 2');
INSERT INTO ADMIN_TREE.Nodes(Node_id, textlayer) VALUES(3, 'узел 3');
INSERT INTO ADMIN_TREE.Nodes(Node_id, textlayer) VALUES(4, 'узел 4');
INSERT INTO ADMIN_TREE.Nodes(Node_id, textlayer) VALUES(5, 'узел 5');
INSERT INTO ADMIN_TREE.Nodes(Node_id, textlayer) VALUES(6, 'узел 6');
INSERT INTO ADMIN_TREE.Nodes(Node_id, textlayer) VALUES(7, 'узел 7');
INSERT INTO ADMIN_TREE.Nodes(Node_id, textlayer) VALUES(8, 'узел 8');
INSERT INTO ADMIN_TREE.Models(model_id, root_id,model_name,create_date,author)
VALUES(1, 2, 'модель 1', NULL, NULL);
INSERT INTO ADMIN_TREE.Versions( model_id, parent_version_id, version, version_id,
create_date, version_name) VALUES(1, NULL,1, 1, '09.04.2008', 'Версия 1 модели 1');
INSERT INTO ADMIN_TREE.Versions( model_id, parent_version_id, version, version_id,
create_date, version_name) VALUES(1, 1, 2, 2, '09.04.2008', 'Версия 2 модели 1');
INSERT INTO ADMIN_TREE.Versions( model_id, parent_version_id, version, version_id,
create_date, version_name) VALUES(1, 2, 3, 3, '09.04.2008', 'Версия 3 модели 1');
INSERT INTO ADMIN_TREE.Tree(relation_id, model_id, Parent_id, Node_id, Parent_relation_id, level_) VALUES(1, 1, 2, 3, 15, 2);
INSERT INTO ADMIN_TREE.Tree(relation_id, model_id, Parent_id, Node_id, Parent_relation_id, level_) VALUES(2, 1, 2, 4, 15, 2);
INSERT INTO ADMIN_TREE.Tree(relation_id, model_id, Parent_id, Node_id, Parent_relation_id, level_) VALUES(3, 1, 3, 5, 1, 3);
INSERT INTO ADMIN_TREE.Tree(relation_id, model_id, Parent_id, Node_id, Parent_relation_id, level_) VALUES(4, 1, 3, 6, 1, 3);
INSERT INTO ADMIN_TREE.Tree(relation_id, model_id, Parent_id, Node_id, Parent_relation_id, level_) VALUES(5, 1, 5, 7, 3, 4);
112
INSERT INTO ADMIN_TREE.Tree(relation_id, model_id, Parent_id, Node_id, Parent_relation_id, level_) VALUES(6, 1, 7, 8, 5, 5);
INSERT INTO ADMIN_TREE.Tree(relation_id, model_id, Parent_id, Node_id, Parent_relation_id, level_) VALUES(15, 1, NULL, 2, NULL, 1);
INSERT INTO ADMIN_TREE.Tree(relation_id, model_id, Parent_id, Node_id, Parent_relation_id, level_) VALUES(18, 1, 3, 8, 4, 3);
INSERT INTO ADMIN_TREE.Operations(operation_id, version_id, relation_id, operation)
VALUES(1, 1, 1, 'i');
INSERT INTO ADMIN_TREE.Operations(operation_id, version_id, relation_id, operation)
VALUES(2, 1, 2, 'i');
INSERT INTO ADMIN_TREE.Operations(operation_id, version_id, relation_id, operation)
VALUES(3, 1, 3, 'i');
INSERT INTO ADMIN_TREE.Operations(operation_id, version_id, relation_id, operation)
VALUES(4, 1, 4, 'i');
INSERT INTO ADMIN_TREE.Operations(operation_id, version_id, relation_id, operation)
VALUES(5, 1, 5, 'i');
INSERT INTO ADMIN_TREE.Operations(operation_id, version_id, relation_id, operation)
VALUES(6, 1, 6, 'i');
INSERT INTO ADMIN_TREE.Operations(operation_id, version_id, relation_id, operation)
VALUES(7, 2, 5, 'd');
INSERT INTO ADMIN_TREE.Operations(operation_id, version_id, relation_id, operation)
VALUES(8, 3, 18, 'i');
Клиентское приложение выполнено в Delphi 7. Порядок создания
включает в себя следующие этапы:
1. Создать новый проект. Основную форму переименовать в
MainForm. В коде формы после раздела implementation описать две переменные, которые будут использоваться всеми процедурами формы:
var
Nodes : TTreeNodes; //компонент “набор узлов дерева”
Node : TTreeNode; //компонент “узел дерева”
2. Добавьте на форму компонент ADOConnection (рис. 10.2) и установите ему следующие свойства:
Name на ADOConnection1;
Connected String = нажать кнопку Build\ выбрать Поставщик данных – Microsoft OLE DB Provider for Oracle
Источник данных – ORCL
Пользователь – ADMIN_TREE
Пароль – worlds
Получится в результате – Provider=MSDAORA.1;User
ID=ADMIN_BOOKS;Data Source=Orcl;Persist Security
Info=False
3. Добавьте на форму два компонента TreeView (рис. 10.2).
У 1-го компонента TreeView изменить следующие свойства:
Name на Tree;
113
У 2-го компонента TreeView изменить следующие свойства:
Name на TV2;
4. Добавьте на форму компонент ADOTable (рис. 10.2) и установите
ему следующие свойства:
Name на ADOView_table;
Connection на ADOConnection1;
TableName на View_Tree;
Active на True.
5. Добавьте на форму 3 компонента ADOTable и 3 компонента
DataSource (рис. 10.2).
У 1-го компонента ADOTable изменить следующие свойства:
Name на ADOModels;
Connection на ADOConnection1;
TableName на Models;
Active на True.
У 1-го компонента DataSource изменить следующие свойства:
Name на DataModels;
DataSet на ADOModels.
У 2-го компонента ADOTable изменить следующие свойства:
Name на ADOVersion;
Connection на ADOConnection1;
TableName на Versions;
IndexFieldNames на model_id;
MasterField на model_id;
MasterSource на DataModels;
Active на True.
У 2-го компонента DataSource изменить следующие свойства:
Name на DataVersion;
DataSet на ADOVersion.
У 3-го компонента ADOTable изменить следующие свойства:
Name на ADOVersii;
Connection на ADOConnection1;
TableName на Versions;
Active на True.
У 3-го компонента DataSource изменить следующие свойства:
Name на DataSource1;
DataSet на ADOVersii.
6. Добавьте на форму два компонента DBLookupComboBox (рис.
10.2).
У 1-го компонента DBLookupComboBox изменить следующие свойства:
Name на DBCombo_Models;
ListSource на DataModels;
114
KeyField на model_id;
ListField на Model_name.
У 2-го компонента DBLookupComboBox изменить следующие свойства:
Name на DBCombo_Version;
ListSource на DataVersion;
KeyField на version_id;
ListField на version.
7. Добавьте на форму два компонента Label (рис. 10.2).
У 1-го компонента Label изменить следующие свойства:
Caption на Выберите модель для работы.
У 2-го компонента Label изменить следующие свойства:
Caption на Выберите версию модели.
8. Добавьте на форму два компонента Button (рис. 10.2).
У 1-го компонента Button изменить следующие свойства:
Name на BCreate_ModelTree;
Caption на Дерево модели с версией.
У 2-го компонента Button изменить следующие свойства:
Name на BCreate_VersionTree;
Caption на Сформировать дерево версий.
9. Добавьте на форму компонент ADOStoredProc (рис. 10.2) и установите ему следующие свойства:
Name на ADOTreeVersion;
Connection на ADOConnection1;
ProcedureName на TreeVersion_Model.
10. Добавьте на форму компонент ADOTable (рис. 10.2) и установите
ему следующие свойства:
Name на ADOTreeVersion_Temp;
Connection на ADOConnection1;
TableName на TreeVersion_Temp;
Active на True.
11. В методе Create компонента Form написать следующий код:
procedure TForm1.FormCreate(Sender: TObject);
begin
ADOModels.Open;
ADOVersion.Open;
end;
115
Рис. 10.2. Схема формы для работы с версиями
12. В методе Click компонента Button с именем Create_ModelTree написать код, который выполняет прорисовку дерева модели с учетом выбранной версии:
procedure TForm1.BCreate_ModelTreeClick(Sender: TObject);
var
i: integer;
Node_:TTreeNode;
begin
if (DBCombo_Models.KeyValue>0) AND (DBCombo_Version.KeyValue>0) then
begin
ADOTreeVersion.Close;
ADOTreeVersion_Temp.Close;
ADOTreeVesion.Parameters.ParamByName('idModel').Value:= StrToInt(VarToStr(DBCombo_Models.KeyValue));
ADOTreeVersion.Parameters.ParamByName('VersionIN').Value:= StrToInt(VarToStr(DBCombo_Version.Text));
ADOTreeVersion.ExecProc;
ADOTreeVersion_Temp.Open;
ADOView_table.Filter:='Parent_node = null AND model_id = '+ VarToStr(DBCombo_Models.KeyValue);
ADOView_table.Filtered:=True;
ADOView_table.Open;
ADOView_table.First;
Tree.Items.Clear;
116
while not ADOView_table.Eof do
begin
node_:=Tree.Items.AddObject(nil, 'Модель " ' +
ADOView_table.FieldByName('model_name').AsString +'"', nil);
Tree.Items.AddChildObject(node_,
ADOView_table.FieldByName('Child_Node').AsString,
Pointer(ADOView_table.FieldByName('relation_id').asInteger));
ADOView_table.Next;
end;
ADOTreeVersion_Temp.First;
while not ADOTreeVersion_Temp.Eof do
begin
i := 0;
while i < Tree.Items.Count do
if ( Tree.Items.Item[i].Data =
Pointer(ADOTreeVersion_Temp.FieldByName('Parent_relation_id').asInteger)
) AND (VarToStr(ADOTreeVersion_Temp.FieldByName('operation').Value)='i') then
begin
Node_:=Tree.Items.AddChildObject(Tree.Items.Item[i], ADOTreeVersion_Temp.FieldByName('Child_Node').AsString,
Pointer(ADOTreeVersion_Temp.FieldByName('relation_id').asInteger));
break;
end
else
Inc(i);
ADOTreeVersion_Temp.Next;
end;
//удаляем лишние узлы, которые в версии помечены буквой ‘d’ - удалены
ADOTreeVersion_Temp.First;
while not ADOTreeVersion_Temp.Eof do
begin
i := 0;
while i < Tree.Items.Count do
if (Tree.Items.Item[i].Data =
Pointer(ADOTreeVersion_Temp.FieldByName('relation_id').asInteger) ) AND
(VarToStr(ADOTreeVersion_Temp.FieldByName('operation').Value)='d') then
begin
Tree.Items.Delete(Tree.Items.Item[i]);
break;
end
else
Inc(i);
ADOTreeVersion_Temp.Next;
end;
end //конец if (DBCombo_Models....
else
Showmessage('Выберите модель и ее версию');
end;
117
13. В методе Click компонента Button с именем Create_VersionTree написать код, который выполняет прорисовку дерева всех версий с учетом
выбранной модели, т.к. версии модели тоже образуют иерархическую
структуру:
procedure TForm1.BCreate_VersionTreeClick(Sender: TObject);
var
i: integer;
begin
if (DBCombo_Models.KeyValue>0) then
begin
ADOVersii.Close;
ADOVersii.Filter:='Parent_version_id = null AND model_id = '+ VarToStr(DBCombo_Models.KeyValue);
ADOVersii.Filtered:=True;
ADOVersii.Open;
ADOVersii.First;
TV2.Items.Clear;
while not ADOVersii.Eof do
begin
TV2.Items.AddObject(nil, ADOVersii.FieldByName('version_name').AsString,
Pointer(ADOVersii.FieldByName('version_id').asInteger));
ADOVersii.Next;
end;
ADOVersii.Filtered:=false;
ADOVersii.First;
while not ADOVersii.Eof do
begin
i := 0;
while i < TV2.Items.Count do
begin
if TV2.Items.Item[i].Data =
Pointer(ADOVersii.FieldByName('Parent_version_id').asInteger) then
begin
TV2.Items.AddChildObject(TV2.Items.Item[i], ADOVersii.FieldByName('version_name').AsString,
Pointer(ADOVersii.FieldByName('version_id').asInteger));
break;
end
else
Inc(i);
end;
ADOVersii.Next;
end;
end;
end;
14. В методе AdvancedCustomDrawItem компонента TreeView с именем
Tree для более наглядного представления уровней иерархии написать следующий код:
118
procedure TForm1.TreeAdvancedCustomDrawItem(Sender: TCustomTreeView; Node:
TTreeNode; State: TCustomDrawState; Stage: TCustomDrawStage; var PaintImages, DefaultDraw: Boolean);
begin
if (stage = cdPrePaint) AND ((Node.Level MOD 2)=0) AND (Node.Level>0) then
begin
Sender.Canvas.Font.Color:=clred; //цвет шрифта узла будет красным
Sender.Canvas.Font.Style:=[fsbold]; //шрифт узла будет полужирным
end
else
begin
if Node.Level>0 then
Sender.Canvas.Font.Color:=clblue; //цвет шрифта узла будет голубым
end;
end;
15. В методе CloseUp компонента DBLookupComboBox с именем
DBCombo_Models для проверки наличия версий у выбранной модели написать следующий код:
procedure TForm1.DBCombo_ModelsCloseUp(Sender: TObject);
begin
if adoversion.RecordCount<=0 then
begin
DBCombo_Version.Enabled:=False;
BCreate_VersionTree.Enabled:=False;
ShowMessage('Выбранная модель не содержит ни одной версии');
end
else
begin
DBCombo_Version.Enabled:=true;
BCreate_VersionTree.Enabled:=true;
end;
end;
16. Сохраните проект и проверьте работу.
На рис. 10.3 представлен фрагмент программной реализации И-ИЛИ
дерева модели и его версий в режиме текстового описания. На нулевом
уровне иерархии указывается информация о самой модели. На первом
уровне иерархии выделена искомая величина, на втором уровне (все узлы
И-типа обозначены жирным шрифтом) представлены И-узлы, для каждого
из которых должен быть обязательно выбран из числа им соответствующих дочерних узлов ИЛИ-типа (обозначены нежирным шрифтом) вариант
зависимости, по которым будет определяться значения узлов И-типа и т.д.
При необходимости можно редактировать дерево в СУБД, что приведет к появлению очередной версии модели на базе выбранной, после сохранения будет преобразовано дерево версий.
119
Таким образом, описанный подход позволяет сохранить всю историю
работы с моделью, имеющей иерархическую структуру, не потерять варианты модели, которые по каким-то причинам были отброшены разработчиком, но позднее признаны как наиболее подходящие.
Рис. 10.3. Пример реализации моделей с учетом версий
Варианты заданий к лабораторной работе No10
Цель задания − создание единого клиент-серверного приложения для
вывода данных в форме иерархической структуры.
Вариант 1. Создать БД для хранения вариантов комплектации новогодних подарков с классификацией групп товаров, входящих в подарок.
Одно дерево должно показывать названия вариантов подарков, и на какой
комплектации основан описанный вариант подарка. Второе дерево в корне
должно хранить название подарка, далее группы товаров, из которых собирается подарок, далее перечень конкретных товаров и количество.
Вариант 2. Создать БД для хранения классификации групп ремонтных
работ, их состава и мастеров, которые могут выполнять указанные работы.
Одно дерево должно показывать ФИО мастеров и группы работ, на которых они специализируются. Второе дерево в корне должно хранить название ремонтной мастерской, далее группы ремонтных работ, далее перечень
конкретных работ, далее ФИО мастеров, которые могут выполнить эти работы.
120
Библиографический список
Астахова И.Ф. Распределенные базы данных на примере ORACLE: Методические
материалы к спецкурсу.– Воронеж: Изд-во ВГУ, 2000.–40 с.
Документация Oracle 10g: PL/SQL Packages and Types Reference.– Электрон. дан.–
1992–2008.–Режим доступа:
http://www.oracle.com/pls/db102/to_pdf?pathname=appdev.102%2Fb14258.pdf&remark=po
rtal+%28Books%29.– Загл. с экрана. – Яз. англ.– ©Oracle.
Документация Oracle 10g: PL/SQL User's Guide and Reference.– Электрон. дан.–
1992–2008.–Режим доступа:
http://www.oracle.com/pls/db102/to_pdf?pathname=appdev.102%2Fb14261.pdf&remark=po
rtal+%28Books%29.– Загл. с экрана. – Яз. англ.– ©Oracle.
Летучий С. Первые шаги: PL/SQL в Oracle.– Электрон. дан.– 2005–2007.–Режим
доступа: http://www.firststeps.ru/sql/oracle/oracle1.html,
http://www.firststeps.ru/sql/oracle/oracle2.html,
http://www.firststeps.ru/sql/oracle/oracle3.html.– Загл. с экрана. – Яз. рус.– © Летучий С.
Остринская Л.И., Семенова И.И., Дороболюк Т.Б. Теория и практика работы с
современными базами и банками данных: Учебное пособие. − Омск: Изд-во СибАДИ,
2005.− 250 с.
Семенова И.И. Сборник упражнений по стандарту SQL. − Омск: Изд-во СибАДИ,
2005.− 43 с.
Шкрыль А.А. Разработка клиент-серверных приложений в Delphi.− СПб.: БХВПетербург, 2006.− 480 с.
121
Оглавление
ОБЩИЕ ПОЛОЖЕНИЯ...................................................................................... 3
Лабораторная работа No1.................................................................................... 4
СОЗДАНИЕ ОБЪЕКТОВ БАЗЫ ДАННЫХ (БД) В ORACLE 9i ................... 4
Лабораторная работа No2.................................................................................. 21
ЗАПОЛНЕНИЕ ТАБЛИЦ ORACLE 9i ДАННЫМИ ..................................... 21
Лабораторная работа No3.................................................................................. 26
УПРАВЛЕНИЕ ПРАВАМИ ДОСТУПА И РАЗРЕШЕНИЯМИ
К СОЗДАВАЕМЫМ ОБЪЕКТАМ БД В ORACLE 9i ................................... 26
Лабораторная работа No4.................................................................................. 33
ОСВОЕНИЕ ПРОГРАММИРОВАНИЯ С ПОМОЩЬЮ
ВСТРОЕННОГО ЯЗЫКА PL/SQL В ORACLE............................................. 33
Лабораторная работа No5.................................................................................. 61
СОЗДАНИЕ ХРАНИМЫХ ПРОЦЕДУР И ФУНКЦИЙ В ORACLE .......... 61
Лабораторная работа No6.................................................................................. 73
СОЗДАНИЕ ТРИГГЕРОВ В ORACLE ........................................................... 73
Лабораторная работа No7.................................................................................. 86
СОЗДАНИЕ КЛИЕНТСКОЙ ЧАСТИ ПРИЛОЖЕНИЯ
ДЛЯ ПРОСМОТРА, РЕДАКТИРОВАНИЯ ДАННЫХ БД
ВЫЗОВ ХРАНИМЫХ ПРОЦЕДУР ИЗ КЛИЕНТСКОЙ ЧАСТИ ............... 86
Лабораторная работа No8.................................................................................. 94
СОЗДАНИЕ АДМИНИСТРАТИВНОЙ СТРАНИЦЫ .................................. 94
Лабораторная работа No9................................................................................ 100
СОЗДАНИЕ ОТЧЕТНЫХ ФОРМ В КЛИЕНТСКОМ ПРИЛОЖЕНИИ
С ПРИМЕНЕНИЕМ RAVE REPORT 5......................................................... 100
Лабораторная работа No10.............................................................................. 108
ИЕРАРХИЧЕСКИЕ СТРУКТУРЫ ДАННЫХ И УЧЕТ
ВЕРСИОННОСТИ ПРИ РАБОТЕ C ДАННЫМИ И МОДЕЛЯМИ .......... 108
Библиографический список............................................................................ 121
122
Учебное издание
Ирина Ивановна Семенова
РАЗРАБОТКА КЛИЕНТ-СЕРВЕРНЫХ ПРИЛОЖЕНИЙ
С ИСПОЛЬЗОВАНИЕМ ТЕХНОЛОГИЙ
ORACLE
Учебно-методическое пособие
***
Редактор И.Г. Кузнецова
***
Подписано к печати___.___.2008
Формат 60х90 1/16. Бумага писчая
Оперативный способ печати
Гарнитура Таймс
Усл.п. л.
, уч.-изд. л. ____
Тираж 100 экз. Заказ No _____
Цена договорная
Издательство СибАДИ
644099, г. Омск, ул. П. Некрасова, 10
Отпечатано в ПЦ издательства СибАДИ
644099, г. Омск, ул. П. Некрасова, 10

ЕНИЕМ RAVE REPORT 5......................................................... 100
Лабораторная работа No10.............................................................................. 108
ИЕРАРХИЧЕСКИЕ СТРУКТУРЫ ДАННЫХ И УЧЕТ
ВЕРСИОННОСТИ ПРИ РАБОТЕ C ДАННЫМИ И МОДЕЛЯМИ .......... 108
Библиографический список............................................................................ 121
122
Учебное издание
Ирина Ивановна Семенова
РАЗРАБОТКА КЛИЕНТ-СЕРВЕРНЫХ ПРИЛОЖЕНИЙ
С ИСПОЛЬЗОВАНИЕМ ТЕХНОЛОГИЙ
ORACLE
Учебно-методическое пособие
***
Редактор И.Г. Кузнецова
***
Подписано к печати___.___.2008
Формат 60х90 1/16. Бумага писчая
Оперативный способ печати
Гарнитура Таймс
Усл.п. л.
, уч.-изд. л. ____
Тираж 100 экз. Заказ No _____
Цена договорная
Издательство СибАДИ
644099, г. Омск, ул. П. Некрасова, 10
Отпечатано в ПЦ издательства СибАДИ
644099, г. Омск, ул. П. Некрасова, 10

