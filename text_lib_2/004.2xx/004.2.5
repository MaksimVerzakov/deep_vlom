МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РФ
МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ ИНДУСТРИАЛЬНЫЙ УНИВЕРСИТЕТ
В.Ю. Радыгин
А РХИТЕКТУРА
ВЫЧИСЛИТЕЛЬНЫХ СИСТЕМ И
КОМПЬЮТЕРНЫХ СЕТЕЙ
Учебно-методическое пособие
Москва 2011
УДК 004.2
ББК 32.81
Р15
Рецензенты:
Е.А. Роганов, кандидат физико-математических наук,
доцент, зав. каф. информационных систем и технологий
Московского государственного индустриального университета;
И.М. Белова, кандидат физико-математических наук,
доцент Московского государственного индустриального университета
Р15
Радыгин В.Ю.
Архитектура вычислительных систем и компьютерных сетей:
учебно-методическое пособие. — М.: МГИУ, 2011. — 45 c.
ISBN 978-5-2760-1974-1
Предназначено для студентов, обучающихся по направлениям
«Прикладная математика и информатика», «Информатика и вычис
лительная техника» и специальности «Математическое обеспечение и
администрирование информационных систем». Содержит набор лабо
раторных проектов, посвящённых решению различных задач с помо
щью языка ассемблер для микропроцессоров архитектуры Intel 80386
(IA32). Описания проектов включают в себя краткую теоретическую
справку, примеры выполнения и различные варианты заданий.
УДК 004.2
ББК 32.81
ISBN 978-5-2760-1974-1
© МГИУ, 2011
© Радыгин В.Ю., 2011
Оглавление
Предисловие . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1. Общая теория. Основы архитектуры Intel 80386 . . . . . . . 5
. . . . . . . 9
. . . . . . . 9
. . . . . . . 19
. . . . . . . 22
. . . . . . . . . . 24
80386 . . . . . . 24
. . . . . . . . . . 25
. . . . . . . . . . 27
. . . . . . . . . . 30
4. Проект 3. Операции с числами с плавающей запятой . . . . 32
                                       4.1. Представление чисел с плавающей запятой на архитектуре 
                                                                                       Intel 80386 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
                                                                                       4.2. Работа с математическим сопроцессором Intel 80387 . . . . 
                                                                                                                         4.3. Вычисление объёма шара . . . . . . . . . . . . . . . . . . . 
                                                                                                                                             4.4. Задачи для самостоятельного решения . . . . . . . . . . . . 
5. Дополнительные задачи для самостоятельного решения . . 44
. . . . . . . . . . . . . 46
2. Проект 1. Простейшие действия с массивами
2.1. Основы языка Ассемблер для Intel 80386 .
2.2. Работа с массивами . . . . . . . . . . . . . .
2.3. Задачи для самостоятельного решения . . .
3. Проект 2. Вычисления с длинными числами
3.1. Представление целых чисел в архитектуре
3.2. Перенос, переполнение и заём . . . . . . .
3.3. Сложение двух 128-битных чисел . . . . .
3.4. Задачи для самостоятельного решения . .
Список литературы и интернет-ресурсов
.
.
.
.
.
.
.
.
32
33
40
42
Предисловие
Учебное пособие подготовлено автором на основе многолетнего опы
та чтения курсов «Архитектура вычислительных систем и компьютерных
сетей» и «Организация ЭВМ и ситем» студентам Московского государ
ственного индустриального университета (направления «Прикладная мате
матика и информатика» и «Информатика и вычислительная техника», а
также специальности «Математическое обеспечение и администрирование
информационных систем»). При разработке данного курса было использо
вано только свободное программное обеспечение. Его же рекомендуется
применять и в процессе обучения.
1. Общая теория. Основы архитектуры
Intel 80386
Микропроцессор Intel 80386 (i80386) был выпущен фирмой Intel в 1985
году и стал первым 32-разрядным микропроцессором в линейке IBM PC
совместимых персональных компьютеров. Большинство последующих мик
ропроцессоров линейки x86 поддерживает весь набор возможностей данно
го микропроцессора. Это означает, что программы, написанные для работы
на архитектуре микропроцессора i80386 (или IA32), будут запускаться и
на большинстве современных персональных компьютеров.
Предшественниками микропроцессора Intel 80386 были 16-разрядные
IBM PC-совместимые машины, в том числе Intel 80086/80088, Intel 80186,
Intel 80286. В связи с этим архитектура i80386 поддерживает весь набор
команд и возможностей своих 16-разрядных предшественников. Микро
процессор 80386 поддерживает три варианта работы:
1) реальный режим, в котором он деградирует до микропроцессора 8086
и позволяет выполнять программы, написанные для 16-битной архи
тектуры (причём в случае сбоя происходит полный отказ системы);
2) виртуальный режим 8086, в котором операционная система созда
ет специальную изолированную среды, работающую как процессор
8086 (причём в случае сбоя операционной системе передается соот
ветствующая информация и полного отказа системы не происходит);
3) защищенный режим, в котором он работает как полноценная 32-раз
рядная система.
В защищённом режиме доступны четыре уровня привилегий, которые
управляются битами во флаговом регистре. Уровень ноль соответствует
привилегированному режиму и имеет полный доступ к машине. Его ис
пользует операционная система. Уровень три предназначен для пользова
тельских программ. Он блокирует доступ к определённым командам и реги
страм управления, чтобы ошибки какой-нибудь пользовательской програм
мы не привели к выходу из строя всей машины. Микропроцессор 80386
поддерживал адресуемое пространство памяти размером до 4 Гб (32-бит
ный адрес). Микропроцессор 8086 мог работать только с адресным про
странством памяти в 20 бит (максимальный объём 1Мб). При этом байты
памяти нумеровались от 0 до 220 −1. В дальнейшем в данном методическом
пособии будем рассматривать только работу в защищённом режиме.
Микропроцессор Intel 80386, также как и его прародитель микропро
цессор Intel 8086 не содержит встроенных средств обработки вычислений
для чисел с плавающей запятой. Данные вычисления осуществляются при
6
Общая теория. Основы архитектуры Intel 80386
помощи специальной микросхемы — сопроцессора (FPU — Floating Point
Unit). Поэтому набор команд и регистров при вычислениях с целыми опе
рандами и при вычислениях с дробными операндами разный. Хотя в более
старших версиях микропроцессоров линейки IBM PC-совместимых пер
сональных компьютеров блок сопроцессора встроен внутрь самого микро
процессора, минимальный набор команд и регистров остаётся тот же, что
был и у 80386.
Таким образом, c точки зрения программирования, из составляющих
микропроцессора нас будут интересовать только арифметическо-логиче
ское устройство (АЛУ), блок операций с плавающей запятой (сопроцес
сор), регистры общего назначения, регистр флагов и стек регистров сопро
цессора. С арифметическо-логическим устройством (и связанной с ним
схемой сдвига) программист взаимодействует посредством выполнения ин
струкций. Набор инструкций включает в себя операции перемещения ин
формации, операции управления выполнением программы, вычисления с
целыми числами и т.д. Блок операций с плавающей запятой предоставля
ет программисту набор инструкций по управлению стеком сопроцессора и
множество арифметических, логических и трансцендентных операций над
числами с плавающей запятой.
Множество регистров общего назначения содержит восемь сверхбыст
рых запоминающих ячеек с собственными именами. Микропроцессор Intel
80386 является 32-разрядной машиной. Это означает, что все основные
операции могут обрабатывать операнды, двоичное представление которых
помещается в 32 бита. Большинство команд имеет три варианта работы: с
32-битными значениями, с 16-битными значениями и 8-битными значени
ями. Исключение составляют действия с дробными числами. О них будет
рассказано позже. Как следствие, регистры общего назначение также име
ют размер 32 бита. Множество регистров общего назначения состоит из
регистров eax, ebx, ecx, edx, ebp, esp, esi и edi. Все регистры общего
назначения могут быть использованы в 16-битном варианте. В этом случае
рассматривается только их младшая часть, а название сокращается до ax,
bx, cx, dx, bp, sp, si и di, соответственно. Первые четыре из регистров об
щего назначения поддерживают также деление на 8-битный режим. Тогда
биты с 0-го по 7-й образуют младшую часть (al, bl, cl и dl, соответ
ственно), а биты с 8-го по 15-й образуют старшую часть (ah, bh, ch и dh,
соответственно). Буквы l и h соответствуют английским словам low и high.
Отдельный интерес представляет регистр флагов EFlags. В данном
32-битном регистре каждый бит отвечает за определённый флаг. Флаги
служат двум целям. Одни флаги влияют на выполнение последующих ин
струкций. Другие флаги содержат характеристики результата последней
арифметической или логической операции. Назначение каждого бита в ре
Общая теория. Основы архитектуры Intel 80386
No Обознач.
  0 CF
  1 1
  2 PF
  3 0
  4 AF
5 0
6 ZF
7 SF
8 TF
9 IF
10 DF
11 OF
12 IOPL
13 IOPL
14 NT
15 0
16 RF
17 VM
18 0
... ...
31 0
7
Таблица 1
Регистр флагов (побитовая карта)
Английское название Название с расшифровкой
Carry Flag
Флаг переноса
Зарезервированная единица
Parity Flag
Флаг чётности
Зарезервированный ноль
Auxiliary Carry Flag
Вспомогательный флаг переноса
для вычислений с псевдодесятичны
ми числами
Зарезервированный ноль
Zero Flag
Флаг нуля
Sign Flag
Флаг знака
Trap Flag
Флаг трассировки
Interrupt Enable Flag Флаг разрешения прерываний
Direction Flag
Флаг направления
Overflow Flag
Флаг переполнения (знакового пере
носа)
I/O Privilege Level
Первый бит уровня приоритета вво
да/вывода
I/O Privilege Level
Второй бит уровня приоритета вво
да/вывода
Nested Task
Флаг вложенности задачи
Зарезервированный ноль
Resume Flag
Virtual 8086 Mode
Зарезервированный ноль
...
...
Зарезервированный ноль
гистре EFlags описано в табл. 1.
Немного поясним назначения флагов. Флаги CF и OF отвечают за пере
полнение. Представление целых чисел на компьютере накладывает огра
ничения на минимальное и максимальное значения. Например, 32-битное
целое число может быть знаковым или беззнаковым. Знаковые числа ле
жат в диапазоне от −231 до 231 − 1. Беззнаковые числа лежат в диапазоне
от 0 до 232 − 1. Флаг CF отвечает за переполнение (или перенос) в без
знаковых числах. Флаг OF за переполнение в знаковых числах. Оба флага
хранят единицу, если в результате последнего действия произошло соот
ветствующее переполнение.
Флаг PF характеризует чётность числа. То есть он содержит значение
последнего бита из двоичного представления результата последней ариф
метической (или логической) операции.
8
Общая теория. Основы архитектуры Intel 80386
Флаг AF относится к переполнению в режиме псевдодесятичных чи
сел. Микропроцессор Intel 80386 умеет работать в режиме, когда 32 бита
представления чисел делятся на группы по 4 бита. Каждая такая группа
соответствует одной цифре от 0 до 9. В общем случае, 4 бита позволяют
хранить больше информации. Но остальные комбинации (от 10 до 15) про
сто игнорируются. Таким образом, получается одно число, состоящее из
8-ми десятичных цифр. Операции с такими цифрами приводят в некоторых
случаях к переполнениям, не совпадающим с переполнениями, описанны
ми флагами CF и OF. Чтобы понять нужна ли коррекция, используется флаг
AF.
Флаг ZF показывает, был ли равен нулю результат последней арифме
тической (логической) операции или нет. Во флаг SF копируется знаковый
бит из двоичного представления результата последней операции.
Флаг TF включает/выключает режим трассировки. В данном режиме
после каждого действия генерируется прерывание. Он удобен для отладки
программ.
Флаг IF отвечает за резрешение/запрет прерываний.
Флаг DF влияет на направления движения некоторых циклических опе
раций. Движение по массивам данных осуществляется посредством изме
нения указателей на соответствующие области памяти. Значение указате
лей на каждом шаге можно уменьшать на единицу (движение из конца в
начало), но можно и увеличивать на единицу (движение из начала в конец).
Чтобы выбрать направление движения, используется флаг DF.
Пара бит, образующих флаг IOPL, отвечает за уровень приоритета опе
раций ввода/вывода, применяемый в защищённом режиме. Флаг NT уста
навливается процессором при переходе из одной задачи в другую с исполь
зованием инструкции CALL или аппаратного прерывания. Он показывает,
была ли выполняемая задача текущей или является вызванной из преды
дущей задачи. Флаг RF управляет реакцией процессора на возникающие
при отладке исключения.
Флаг VM переключает процессор из защищённого режима в режим эму
ляции микропроцессора Intel 8086 (если выставлен в единицу).
2. Проект 1. Простейшие действия с массивами
Язык Ассемблер (Assembler) уникален для каждой архитектуры ком
пьютера. Таким образом, всё, что приводится в данной главе будет работать
только на соответствующих моделях микропроцессоров. Поэтому прежде
чем начинать работу убедитесь, что Ваш персональный компьютер совме
стим с Intel 80386. Далее под словом Ассемблер будет подразумеваться
Ассемблер для архитектуры 80386 и ни какой иной.
Существуют два основных стандарта написания программ для языка
Ассемблер: в синтаксисе фирмы Intel и в синтаксисе фирмы AT&T. Данное
пособие описывает только синтаксис фирмы Intel.
2.1. Основы языка Ассемблер для Intel 80386. Программа
на языке Ассемблер в общем случае может состоять из разнообразных
комбинаций четырёх видов объектов: инструкций, директив, меток и аргу
ментов. Инструкция — это, собственно говоря, буквенная интерпретация
основных команд микропроцессора. Обычно инструкция состоит из комби
нации английских букв и цифр, образующих либо сокращение от англий
ского слова, либо аббревиатуру словосочетания. Регистр букв значения не
имеет. Пример:
mov,
CALL,
LOOP
push.
Метка в Ассемблере — это способ присвоить имя тому или иному месту
программы. Название метки может быть образовано из комбинации ан
глийских букв и цифр. При установке метки в программе после её названия
указывается двоеточие. При ссылке на метку двоеточие не используется.
Пример:
start:
...
loop start
В качестве аргументов инструкций могут выступать разные объекты.
Все виды передачи аргументов называются способами адресации. Мик
ропроцессор Intel 80386 допускает большое число таких способов, но в
данном пособии не будут рассмотрены все допустимые варианты, а только
основные из них.
10
Проект 1. Простейшие действия с массивами
1. Непосредственная адресация: аргумент задаётся в виде константного
значения. Пример:
push 2
2. Регистровая адресация: аргумент передаётся в виде значения, лежа
щего в регистре общего назначения. Пример:
push eax
3. Косвенная адресация: аргумент считывается из оперативной памяти
по адресу, рассчитываемому по формуле:
адрес = [база + масштаб × индекс ± смещение] ,
где в качестве базы и индекса могут выступать значения, лежащие в
регистрах общего назначения, масштаб принимает только значения
из набора {1, 2, 4, 8}, а смещение — это некоторая целочисленная
константа. Обязательной составляющей формулы является только
база. Масштаб, индекс и смещение могут отсутствовать. Масштаб
также не применяется отдельно от индекса. Пример:
mov eax, [ebx + 4 * ecx - 16]
Директивы — это специальные команды, указывающие самой програм
ме Ассемблера (транслятору, переводящему из языка Ассемблер в машин
ные коды) различные дополнительные аспекты. Например, где распола
гаются определённые данные, как организовать те или иные секции про
граммы и т.д. К сожалению, общего стандарта для директив нет! В данном
пособии рассматривается набор директив для обработки компилятором as,
который используется в среде UNIX. Так как компилятор gcc сам вызы
вает as для обработки файлов, то можно использовать непосредственно
его.
Все директивы начинаются с точки и состоят из последовательности
английских букв, цифр и некоторых спец символов. Например:
.intel_syntax
.double
.globl
Обычно учебники по языкам программирования в качестве первого при
мера содержат программу “Hello World!”, печатающую на экран фразу
«Здравствуй, мир!» на английском языке. В случае с Ассемблером зада
ча вывода чего-либо на экран не тривиальна. Более того, в современном
мире мало кто пишет на Ассемблере полноценные программы. Поэтому и
мы будем рассматривать язык Ассемблер не как основное средство про
граммирования, а как механизм, позволяющий более оптимально написать
Основы языка Ассемблер для Intel 80386
11
вспомогательные функции. Реализованные с помощью Ассемблера функ
ции будут потом использоваться в полноценной программе, написанной на
языке C. Поэтому вместо “Hello World!” рассмотрим пример написания
на языке Ассемблер функции сложения двух чисел и пример её исполь
зования в программе на языке C. Подробно о языке C можно прочесть
в [3].
Пример 1.1. Функция сложения двух целых четырёхбайтовых чисел на
языке Ассемблер.
.intel_syntax noprefix
.globl add
.type add,@function
add:
mov eax, [esp + 8]
add eax, [esp + 4]
ret
Пример 1.2. Программа на языке C, использующая функцию add.
# include <stdio.h>
extern int add(int, int);
int main(void){
int a, b;
scanf("%d", &a);
scanf("%d", &b);
printf("%d\n", add(a, b));
return 0;
}
Чтобы запустить написанную нами программу, необходимо разместить
текст примера 1.1 в файле add.s, текст примера 1.2 в файле add.c и
скомпилировать их в исполняемый файл при помощи компилятора gcc:
gcc add.s add.c
Полученный запускаемый файл a.out можно выполнить в терминале,
добавив спереди точку и слэш:
./a.out
12
Проект 1. Простейшие действия с массивами
Чтобы понять содержимое данного примера, рассмотрим основные
непривилегированные инструкции микропроцессора Intel 80386, позволя
ющие работать с целыми числами.
Инструкции для перемещения данных
mov получатель, источник — инструкция копирует значение из
операнда источник в операнд получатель. Оба операнда должны быть од
ного размера.
Обычно по операндам можно понять какого они размера. Например,
команда
mov eax, 1
подразумевает операнды 32-битного размера. Команда
mov ax, 1
подразумевает операнды 16-битного размера. Команда
mov al, 1
подразумевает операнды 8-битного размера. Размер операндов очевиден
из названий регистров: eax, ax и al. Если операнды не позволяют опре
делить свой размер, то он может быть задан явно при помощи указателей
размерности: byte ptr — 8 бит, word ptr — 16 бит, dword ptr — 32
бита, qword ptr — 64 бита. Пример:
mov dword ptr [esp + 4], 2
Кроме требования равенства размерности команда mov (как и большин
ство других команд Ассемблера) накладывает ограничения на «качество»
операндов. Опуская некоторые подробности (и сегментные регистры), мож
но упрощёно сказать, что один из них всегда должен быть либо регистром
общего назначения, либо константой.
xchg получатель, источник — инструкция меняет местами значе
ния из получателя и источника. Оба операнда должны быть одного раз
мера. Причём один из них обязательно должен быть регистром общего
назначения, и они оба не могут быть константами.
lea получатель, источник — инструкция загрузки эффективного
адреса (load effective address). Источником всегда должен быть операнд
с косвенной адресацией. Получателем — регистр. Команда вычисляет ад
рес источника и кладёт его (адрес) в получателя. Вычисление адреса не
изменяет значений регистра флагов EFlags. Пример:
lea eax, [ebx + 4 * ecx - 4]
Основы языка Ассемблер для Intel 80386
13
Для дальнейшего знакомства с инструкциями микропроцессора Intel
80386 необходимо рассмотреть понятие стека локальных переменных. Ко
гда мы пишем функцию на языке C, то часто используем внутри неё ло
кальные переменные. Пример:
int distance2(int x1, int y1, int x2, int y2){
int d1, d2;
d1 = (x1 - x2);
d2 = (y1 - y2);
return d1 * d1 + d2 * d2;
}
В данном примере шесть локальных переменных: x1, y1, x2, y2, d1 и
d2. Мы не задумывались, когда писали функцию, где они будут лежать.
На самом деле, все локальные переменные размещаются в специальной
области памяти, носящей название стека локальных переменных. Адрес
вершины стека локальных переменных всегда размещается в регистре esp.
Поэтому мы никогда не будем использовать данный регистр для других
целей. Сам стек размещается в оперативной памяти таким образом, чтобы
его хвост был направлен в сторону роста адресов, а голова — в сторону
уменьшения роста адресов. То есть при добавлении в стек новой локальной
переменной его голова смещается в сторону начала оперативной памяти, а
хвост всегда стоит на месте. Все объекты в стеке локальных переменных
занимают место, кратное четырём байтам.
В показанном примере у функции было четыре аргумента. Если бы мы
хотели написать её на Ассемблере, а не на C, то как бы выглядел стек
локальных переменных в самом начале функции? Соглашение языка C
подразумевает, что все аргументы функции размещаются на стеке локаль
ных переменных в обратном порядке. То есть глубже всех будет лежать
переменная y2, а выше всех — переменная x1. Помимо переменных на сте
ке также размещается так называемый адрес возврата. Адрес возврата —
это адрес той области памяти, в которой располагается код программы,
вызывающей нашу функцию. Он нужен, чтобы по завершении функции
можно было понять куда надо вернуть управление, то есть какую коман
ду выполнять следующей. Адрес возврата всегда лежит на самой вершине
стека локальных переменных и занимает 4 байта (в случае архитектуры
Intel 80386).
Таким образом, в нашем случае стек будет выглядеть, как показано на
рис. 1.
Теперь можно рассмотреть набор инструкций, обеспечивающих работу
со стеком локальных переменных.
14
Проект 1. Простейшие действия с массивами
ESP →
адрес возврата
x1
y1
x2
y2
-8
-4
+0
+4
+8
+12
+16
Рис. 1. Размещение переменных на стеке
push источник — помещает значение источника на вершину стека
локальных переменных. При этом стек сдвигается (изменяется значение
регистра esp), и все остальные локальные переменные оказываются раз
мещёнными глубже.
pop получатель — перемещает значение с вершины стека локальных
переменных в получателя. При этом стек сдвигается в обратную сторону
(изменяется значение регистра esp), и все остальные локальные перемен
ные оказываются размещёнными ближе к началу. Очевидно, что получа
тель не может быть константой.
pushad — копирует значения всех регистров общего назначения на
вершину стека локальных переменных (порядок: eax, ecx, edx, ebx, esp,
ebp, esi, edi).
pushad — загружает значения всех регистров общего назначения с
вершины стека локальных переменных, кроме значения esp. То есть сна
чала загружаются edi, esi и ebp. Затем стек просто сдвигается на четыре
байта. А после загружаются оставшиеся ebx, edx, ecx и eax.
pushfd — загружает в стек значение регистра флагов.
popfd — загружает значение с вершины стека в регистр флагов.
Арифметические операции
add получатель, источник — складывает два знаковых или без
знаковых числа по принципу: получатель = получатель + источник. Оба
операнда могут быть образованы как при помощи косвенной, так и при
помощи регистровой адресации. Источник может также быть константой.
Аргументы должны быть одного размера (1, 2 или 4 байта). Два операнда
не могут одновременно адресоваться косвенно.
sub получатель, источник — осуществляет вычитание для двух
знаковых или беззнаковых чисел по принципу: получатель = получатель
- источник. Оба операнда могут быть образованы как при помощи кос
венной, так и при помощи регистровой адресации. Источник может также
быть константой. Аргументы должны быть одного размера (1, 2 или 4 бай
та). Два операнда не могут одновременно адресоваться косвенно.
Основы языка Ассемблер для Intel 80386
15
cmp источник1, источник2 — осуществляет «сравнение» двух зна
ковых или беззнаковых чисел по принципу: источник1 - источник2. Аргу
менты должны быть одного размера (1, 2 или 4 байта). Два операнда не
могут одновременно адресоваться косвенно. Результат никуда не записы
вается! Основная цель инструкции — изменить флаги.
adс получатель, источник — складывает два числа и значение фла
га переноса по принципу: получатель = получатель + источник + CF. Оба
операнда могут быть образованы как при помощи косвенной, так и при
помощи регистровой адресации. Источник может также быть константой.
Аргументы должны быть одного размера (1, 2 или 4 байта). Два операнда
не могут одновременно адресоваться косвенно.
sbb получатель, источник — осуществляет вычитание для двух
чисел с учётом флага переноса по принципу: получатель = получатель источник - CF. Оба операнда могут быть образованы как при помощи кос
венной, так и при помощи регистровой адресации. Источник может также
быть константой. Аргументы должны быть одного размера (1, 2 или 4 бай
та). Два операнда не могут одновременно адресоваться косвенно.
mul источник — умножение беззнаковых чисел. Значение источника
умножается на значение регистра eax (ax или al в зависимости от раз
мера), и полученный результат записывается в edx:eax (dx:ax или ah:al).
Для источника может применяться как регистровая, так и косвенная адре
сации.
imul источник — умножение знаковых чисел. Значение источника
умножается на значение регистра eax (ax или al в зависимости от раз
мера), и полученный результат записывается в edx:eax (dx:ax или ah:al).
Для источника может применяться как регистровая, так и косвенная адре
сации. Доступны также ещё два варианта работы этой инструкции: imul
получатель, источник и imul получатель, источник1, источник2. В первом
из них осуществляется умножение по принципу: получатель = источник ×
получатель. Во втором — по принципу: получатель = источник1 × источ
ник2.
div источник — деление беззнаковых чисел. Значение источника де
лится на значение регистра eax (ax или al в зависимости от размера).
Частное записывается в eax (ax или al), а остаток в edx (dx или ah). Для
источника может применяться как регистровая, так и косвенная адресации.
Важно! До выполнения деления необходимо обнулить регистр edx (dx
или ah). В противном случае — при выполнении программы либо произой
дёт ошибка, либо результат деления будет неверен!
Замечание. Обнулять регистр edx при помощи команды mov:
mov edx, 0
16
Проект 1. Простейшие действия с массивами
неэффективно! Более правильно использовать либо не описанное в данном
пособии исключающее или:
xor edx, edx,
либо рассматриваемую ниже инструкцию cltd.
idiv источник — деление знаковых чисел. Значение источника делит
ся на значение регистра eax (ax или al в зависимости от размера). Частное
записывается в eax (ax или al), а остаток в edx (dx или ah). Для источника
может применяться как регистровая, так и косвенная адресации.
inc получатель — увеличивает значение получателя на единицу, не
изменяя флага CF. Для получателя может применяться как регистровая,
так и косвенная адресации.
dec получатель — уменьшает значение получателя на единицу, не
изменяя флага CF. Для получателя может применяться как регистровая,
так и косвенная адресации.
neg получатель — инвертирует знак получателя. Для получателя
может применяться как регистровая, так и косвенная адресации.
cbw — конвертирует знаковое 8-битное число в 16-битное. Начальное
значение должно лежать в регистре al. Результат помещается в регистр
ax.
cwde — конвертирует знаковое 16-битное число в 32-битное. Началь
ное значение должно лежать в регистре ax. Результат помещается в ре
гистр eax.
cltd (или cdq) — конвертирует знаковое 32-битное число в 64-битное.
Начальное значение должно лежать в регистре eax. Результат помещается
в пару регистров eax и edx.
Управляющие инструкции
call адрес (метка) — передача управления по адресу. Говоря более
простым языком, инструкция call соответствует вызову функции. Прежде
чем перейти в указанное место, call размещает на стеке адрес возврата
(адрес следующей за собой инструкции). Если call используется для вы
зова функции стандартной библиотеки C, то аргументы функции должны
быть предварительно размещены на стеке в обратном порядке.
ret [кол-во байт для удаления] — возврат управления назад. Дан
ная инструкция ищет на вершине стека адрес возврата и переходит на соот
ветствующую ему инструкцию, удаляя при этом его со стека. Если указан
необязательный аргумент — целое число, то перед осуществлением пере
хода со стека удаляется указанное число байт.
iret — отличается от ret только тем, что дополнительно загружает со
стека значения регистра флагов.
Основы языка Ассемблер для Intel 80386
17
jmp адрес (метка) — безусловный переход по адресу (метке), то
есть переход к выполнению той инструкции, которая расположена по дан
ному адресу в памяти или стоит после данной метки.
jxx адрес (метка) — набор инструкций условного перехода. Вместо
символов xx подставляются краткие обозначения флагов или их комби
нация с символом n, означающим отрицание. Иногда краткое обозначение
флагов заменяется сокращением их смыслового назначения. Например, со
кращённому обозначению флага ZF (z) соответствует сокращение от слова
equal — e. Основные примеры:
jc — переход в случае если флаг CF равен единице;
jnc — переход в случае если флаг CF равен нулю;
js — переход в случае если флаг SF равен единице;
jns — переход в случае если флаг SF равен нулю;
jz, je — переход в случае если флаг ZF равен единице;
jnz, jne — переход в случае если флаг ZF равен нулю.
loop адрес (метка) — простейший цикл. Каждый раз при достиже
нии инструкции loop значение регистра ecx уменьшается на единицу. Если
после этого ecx становится равным нулю, то происходит переход к следу
ющей за loop инструкции, иначе происходит переход по указанной метке
(адресу). Обычно цикл выглядит следующим образом:
ïðèñâîåíèå çíà÷åíèÿ ecx
...
label:
äåéñòâèÿ â òåëå öèêëà
loop label
При таком подходе надо быть осторожным! Цикл всегда выполняется хотя
бы один раз! Более того, при стартовом значении ecx, равном нулю, цикл
будет работать «бесконечно».
clc — устанавливает флаг CF в ноль.
stc — устанавливает флаг CF в единицу.
cld — устанавливает флаг DF в ноль.
std — устанавливает флаг DF в единицу.
Более подробно с набором инструкций микропроцессора Intel 80386
для целочисленных вычислений можно ознакомиться в [1, 2, 4] .
Основные директивы
Кроме набора инструкций нам придётся кратко познакомиться с на
бором директив Ассемблера as. Важно понимать, что данный набор ди
ректив будет работать только в той среде, для которой он предназначен.
18
Проект 1. Простейшие действия с массивами
В частности, рассматриваемые директивы будут работать при компиляции
программой as на 32-битной архитектуре в среде Linux.
.intel_syntax noprefix — директива, включающая синтаксис языка Ас
семблер фирмы Intel. Ключ noprefix подразумевает, что названия регистров
будут писаться без дополнительного символа процента перед ними.
.globl метка — директива, экспортирующая название во внешнее про
странство имён.
.type метка,тип — директива, указывающая тип экспортируемого име
ни. Например, для функций:
.type label,@function
.byte, .word, .int — директивы определения константных переменных
для однобайтового, двухбайтового и четырёхбайтового целых чисел. При
мер:
...
var1: .int 32
...
mov eax, var1
.string — директива определения константной текстовой строки. Для
получения указателя на данную строку можно использовать конструкцию
offset. Пример:
...
var1: .string "Hello World!"
...
mov eax, offset var1
Теперь можно вернуться к примеру 1.1. Первые три строки примера
(будем называть их в дальнейшем «шапкой») содержат подготовочные ди
рективы. Включается нужный синтаксис языка. Экспортируется название
функции во внешнее пространство имён.
Содержательная часть примера начинается с метки add:, соответству
ющей названию формируемой нами функции. Аргументы функции по со
глашению языка C размещаются на стеке локальных переменных следом
за адресом возврата. Адрес возврата занимает четыре байта, переменные
типа int тоже. Ситуация на стеке локальных переменных показана на
рис. 2.
Из рисунка видно: для того чтобы добраться до первого аргумента функ
ции, надо к указателю, хранящемуся в регистре esp, прибавить четыре, а
до второго — восемь.
Работа с массивами
19
ESP →
адрес возврата
аргумент 1
аргумент 2
-8
-4
+0
+4
+8
Рис. 2. Размещение переменных на стеке для задачи сложения двух чисел
Команда сложения не позволяет просуммировать два объекта с кос
венной адресацией. То есть один из аргументов необходимо переложить
со стека локальных переменных в любой из регистров общего назначе
ния. Это и делается при помощи инструкции mov. Следующий шаг — это
непосредственное сложение (add).
Осталось определиться, каким образом функция будет возвращать по
лученный результат. Язык С подразумевает, что для этой цели (в случае
если возвращаемое значение по размеру меньше или равно четырём бай
там) служит регистр eax, а именно в нём сейчас и лежит сумма. Поэтому
завершаем нашу функцию и возвращаем управление назад посредством
ret.
2.2. Работа с массивами. Наиболее часто используемое представле
ние массивов в языке C предусматривает размещение элементов массива
единым куском в памяти. Обычно для работы с ними необходимо знать
указатель на начало массива и количество элементов в нём.
Рассмотрим пример решения задачи на обработку массивов: напишите
на языках C и Ассемблер функцию, заменяющую значения элементов мас
сива целых двухбайтовых чисел (тип short) на их абсолютную величину
(модуль). Прототип функции будет следующим:
short* array_abs(short* array, int size);
Сначала рассмотрим реализицию на C.
Пример 2.1.
# include <stdlib.h>
short* array_abs(short* array, int size)
{
while(size > 0){
size--;
array[size] = abs(array[size]);
}
return array;
20
Проект 1. Простейшие действия с массивами
}
Давайте рассмотрим, что размещается на стеке локальных переменных
в начале работы функции (рис. 3).
ESP →
адрес возврата
array
size
-8
-4
+0
+4
+8
Рис. 3. Размещение переменных на стеке для задачи с массивом
Подумаем, какие регистры придётся занять. Во-первых, нужен регистр
для указателя на массив, так как Ассемблер не поддерживает двойную
операцию взятия значения по адресу. Во-вторых, понадобится регистр ecx
для счётчика цикла. В него мы положим переменную size. В Ассемблере
нет инструкции для вычисления модуля целого числа. Делать эту опера
цию придётся в два шага: сначала проверим знак числа, а затем, если оно
отрицательно, то инвертируем при помощи инструкции neg.
Наш план решения содержит один недостаток. Если мы будем исполь
зовать регистр ecx, то испортим значение, лежавшее в нём до вызова функ
ции, что может привести к краху или неправильной работе вызывающего
процесса. Поэтому значения всех используемых нами регистров необхо
димо предварительно сохранить на стеке локальных переменных. Почему
же мы не делаем это для регистра eax? Это дозволяется, так как дан
ный регистр предназначен для возвращения функцией результата (в языке
С). Следовательно, он не может быть не изменён. Стек при сохранении
значений регистров изменится (рис. 4).
ESP →
ecx
адрес возврата
array
size
-8
-4
0
+4
+8
+12
Рис. 4. Размещение переменных на стеке для задачи с массивом после
сохранения регистра ecx
Теперь по аналогии с примером 2.1 можно написать и реализацию на
Ассемблере.
Работа с массивами
21
Пример 2.2.
.intel_syntax noprefix
.globl array_abs
.type array_abs,@function
array_abs:
push ecx
mov eax, [esp + 8]
mov ecx, [esp + 12]
cmp ecx, 0
jz end
step:
cmp word ptr [eax + ecx * 2], 0
jns next
neg word ptr [eax + ecx * 2]
next:
loop step
end:
pop ecx
ret
Осталось только написать тестовую программу на языке C, которая
позволяла бы продемонстрировать использование реализованных функ
ций.
Пример 2.3.
# include <stdio.h>
extern short* array_abs(short*, int);
int main(void)
{
short b[10] = {1, -1, 2, -2, -3, 3, -4, 4, 5, -5}, *a;
a = array_abs(b, 10);
printf("%hd %hd %hd %hd ...\n", a[0], a[1], a[2], a[3]);
return 0;
}
22
Проект 1. Простейшие действия с массивами
2.3. Задачи для самостоятельного решения. Напишите на
языках C и Ассемблер функции, описание и прототип которых приведе
ны ниже.
1. int* reverse(int* array, int size);
Функция переставляет местами элементы массива array из конца в
начало. Массив состоит из целочисленных элементов размерностью
в четыре байта. Их количество указанно в переменной size.
2. char* invert(char* array, int size);
Функция инвертирует знак элементов массива array. Массив состо
ит из целочисленных элементов размерностью в один байт. Их коли
чество указанно в переменной size.
3. short sum(const short* array, int size);
Функция считает сумму элементов массива array. Массив состоит из
целочисленных элементов размерностью в два байта. Их количество
указанно в переменной size.
4. int scalar_mult(const int* a, const int* b, int size);
Функция вычисляет скалярное произведение элементов двух масси
вов: a и b. Массивы состоят из целочисленных элементов размерно
стью в четыре байта. Их количество указанно в переменной size.
5. char* minus(char* a, const char* b, int size);
Функция вычисляет разность двух векторов по принципу a = a − b.
Векторы представлены в виде массивов, состоящих из целочислен
ных элементов размерностью в один байт. Их количество указанно в
переменной size.
6. short* vector_mult(const short* a,
const short* b, short* res);
Функция вычисляет векторное произведение двух векторов размерно
стью три по принципу: res = a × b. Векторы представлены в виде
массивов, состоящих из целочисленных элементов размерностью в
два байта.
7. int* mod(int* a, int size, int unit);
Функция вычисляет остатки от деления компонент вектора a на целое
число unit: a = a % unit. Вектор представлен в виде массива, со
стоящего из целочисленных элементов размерностью в четыре байта.
Их количество указанно в переменной size.
8. int* max(int* a, int* b, int* r, int size);
Функция вычисляет для каждой пары элементов с одинаковыми ин
дексами из массивов a и b максимальное значение и записывает его
в элемент с тем же индексом массива r. Векторы представлены в ви
де массивов, состоящих из целочисленных элементов размерностью
в четыре байта. Их количество указанно в переменной size.
Задачи для самостоятельного решения
23
9. int* min(int* a, int* b, int size);
Функция вычисляет для каждой пары элементов с одинаковыми ин
дексами из массивов a и b минимальное значение и записывает его
в элемент с тем же индексом массива a. Массивы состоят из цело
численных элементов размерностью в четыре байта. Их количество
указанно в переменной size.
10. int max(int* a, int size);
Функция находит максимальный элемент массива a. Массив состо
ит из целочисленных элементов размерностью в четыре байта. Их
количество указанно в переменной size.
11. int* sort(int* a, int size);
Функция сортирует пузырьковым методом элементы массива a по
убыванию. Массив состоит из целочисленных элементов размерно
стью в четыре байта. Их количество указанно в переменной size.
3. Проект 2. Вычисления с длинными числами
В своей жизни человек при необходимости легко оперирует в вычис
лениях бесконечными множествами чисел (конечно, имеются в виду не
вычисления в уме). Единственное ограничение — это Ваше терпение и
способности. Возможности же компьютера в обычной ситуации ограниче
ны. Архитектура любого современного ЭВМ не позволяет осуществлять
непосредственные вычисления с числами произвольной длины. В частно
сти, архитектура Intel 80386 для целых чисел ограничена 32-мя битами.
С другой стороны, любой хороший программист легко может, исполь
зуя ограниченные числа, реализовать методы обработки длинных чисел.
Как это делается? Чтобы найти решение данного вопроса нужно прежде
всего рассмотреть, как представлются целые числа на компьютере. Причём
важно понимать, что представление только неотрицательного ряда целых
чисел (будем называть их беззнаковые) и представление всех целых чисел,
включая отрицательные (будем называть их знаковыми), — это разные за
дачи.
3.1. Представление целых чисел в архитектуре 80386. Ещё
в середине XX века Фон-Нейман показал преимущество использования
двоичной системы представления чисел на компьютерах. Двоичная систе
ма применяется на сегодняшний день для представления как целых, так и
вещественных чисел. Рассмотрим для начала представление целых беззна
ковых чисел. Например, архитектура Intel 80386 поддерживает 8-битный
режим работы с целыми числами. Это означает, что для представления
целого числа используется не более 8-ми двоичных цифр. Минимальное
число, соответственно, — ноль, максимальное — 111111112 = 20 + 21 +
+ 22 + 23 + 24 + 25 + 26 + 27 = 25510 .
Вспомним материалы школьного курса. Как перевести число из деся
тичной системы счисления в двоичную? Например, мы хотим перевести
число 13310 из десятичной системы счисления в двоичную. Можно вос
пользоваться делением в столбик. Но мы используем степени двойки. Из
вестно, что 27 = 128, 26 = 64, 25 = 32, 24 = 16, 23 = 8, 22 = 4,
21 = 2, 20 = 1. Число 133 больше, чем 128. Следовательно, в позиции с
номером семь мы записываем единицу и уменьшаем 133 на 128. Остаётся
5. Числа 64, 32, 16 и 8 больше 5. Следовательно, в позиции шесть, пять,
четыре и три записывается ноль. Число 4 меньше 5. Поэтому записываем
в позицию два единицу и уменьшаем число на четвёрку. Остаётся едини
ца. Два больше, чем единица. Поэтому записываем в позицию один ноль.
Единица совпадает с единицей нулевой степени двойки, следовательно, в
Перенос, переполнение и заём
25
позиции ноль у нас будет единица. Процесс завершён! Получаем: 13310 =
= 100001012 .
Представление знаковых чисел на компьютере гораздо сложнее. Во
первых, старший бит числа теперь играет роль знака. Неотрицательные
числа начинаются с нуля, отрицательные — с единицы. Таким образом,
неотрицательных чисел становится меньше. Доступны числа от 0 до 127.
Отрицательные числа доступны в диапазоне от -1 до -128. Для получения
представления отрицательного числа недостаточно к 7-ми битам двоичной
формы его абсолютного значения добавить спереди 8-ю единичку. Всё го
раздо сложнее. Для начала модуль числа уменьшается на единицу, а затем
к нему применяется побитовое инвертирование. Например, посмотрим, как
будет записано число −3.
1. Необходимо перевести −310 в двоичную систему счисления. Для это
го получим модуль числа: | − 310 | = 310 = 00000112 .
2. Уменьшим на единицу: |310 | − 1 = 00000102 .
3. Применим побитовое инвертирование: !(00000102) = 11111012 .
4. Добавим знаковую единицу: −310 = 111111012 .
5. Ответ получен: −310 = 111111012 .
Зачем так сложно? Преимущество такого представления легко понять
на примере. Давайте сложим числа −3 и 3, используя алгоритм сложения
беззнаковых чисел. То есть будем считать, что двоичное компьютерное
представление числа −310 = 111111012 является обычным беззнаковым
числом. Тогда вместо −3 мы получаем число 25310 = 20 + 22 + 23 + 24 +
+ 25 + 26 + 27 . Сложим: 310 + 25310 = 25610 = 1000000002 . Обратите
внимание, что результат такого сложения не поместился в требуемые во
семь бит. Если отрезать лишние старшие биты, то получаем ноль! Что и
требовалось получить в исходной задаче. Таким образом, данное представ
ление отрицательных чисел позволяет использовать те же самые алгорит
мы сложения и вычитания, что и для беззнаковых чисел. К сожалению,
умножение и деление такого простого подхода не позволяют.
3.2. Перенос, переполнение и заём. Как видно из последнего
примера, при вычислениях на компьютере результат может не поместить
ся в отведённое для представления числа место. Причём для знаковых
и беззнаковых чисел такая ситуация наступает для различных значений.
Например, для 8-битных чисел результат знаковых вычислений перестаёт
помещаться уже при превышении величины 127. Для беззнаковых чисел
предел — 255. Будем называть превышение допустимого знакового значе
ния переполнением, а превышение допустимого беззнакового значения —
переносом. Переносу соответствует флаг Carry (CF), а переполнению —
флаг Overflow (OF).
26
Проект 2. Вычисления с длинными числами
Перенос в случае операции сложения приводит к потере старшего би
та, так как его некуда записать. Поэтому флаг CF как раз играет роль
недостающей цифры. В случае переполнения мы получаем более сложную
ситуацию. Потеря старшего бита приводит к смене знака числа. В частно
сти, если к 8-битному знаковому числу 127 добавить единицу, мы получим
минимальное отрицательно число — −128.
Похожая ситуация происходит и в случае операции вычитания. Напри
мер, если попробовать вычесть в беззнаковом режиме что-либо из числа
ноль, то произойдёт заём недостающего бита. То есть вычитание осуще
ствится так, как будто у нас был не ноль, а число 1000000002 = 25610 .
Для знаковых чисел переход через минимально допустимую границу зна
чений приводит к смене знака. Например, −128 − 1 = 127.
Чтобы лучше понять смысл флага переноса, вспомним, как нас учили
складывать столбиком в школе. Например, сложим два числа: 1567 и 4488
(рис. 5).
1 1 1 1 5 6 7
4 4 8 8
6 0 5 5
+
Рис. 5. Сложение столбиком чисел 1567 и 4488
Аналогичным образом можно складывать в любой системе счисления,
начиная с двоичной (рис. 6) и заканчивая системами с большими основа
ниями, например, с основанием 256 (рис. 7).
1 1 0 0 0 1 1 1 1 0 1
1 0 1 0 1 0
1 0 1 1 1 1
+
1
Рис. 6. Сложение столбиком чисел 1111012 (6110) и 1010102 (4210)
Из рассмотренных примеров видно, что «единичка в уме», которой нас
учили в школе, — это упрощённая модель флага переноса. Причём по
следний пример наглядно показывает, как данный флаг можно использо
вать. Если есть возможность производить вычисления с 8-битовыми чис
лами, то, используя флаг переноса, можно из обычного сложения получить
«длинное». Каждое длинное число при этом делится на 8-битовые блоки, а
Сложение двух 128-битных чисел
27
1 1 214 128 1
1 127 255
216 0 0
+
Рис. 7. Сложение столбиком чисел 214 128 1256 (1405747310) и
1 127 255256 (9830310)
вычисления осуществляются по аналогии со школьным алгоритмом «стол
бика» с учётом «единицы в уме», хранящейся во флаге CF. Для обобщения
алгоритма будем считать, что при сложении младших цифр двух чисел у
нас «в уме» хранится ноль.
3.3. Сложение двух 128-битных чисел. Рассмотрим пример ре
шения задачи на обработку длинных чисел. Пусть есть два числа, двоичное
представление которых помещается в 128 бит, но не помещается (хотя бы
у одного из них) в 96 бит. Числа поделены на кусочки в 32 бита (соответ
ствует типу int языка C), которые сложены в массивы. Результат сложения
тоже будем считать 128-битным числом (пренебрежём возможным пере
полнением), хранящимся в аналогичном массиве.
Прототип функции на языке C будет следующим:
int* add128(int* a, int* b, int* res);
Замечание: третий аргумент функции нужен для передачи указателя
на массив, в котором будет размещён результат сложения. Тот же самый
указатель необходимо вернуть по завершении вычислений в качестве вы
числяемого функцией значения.
Рассмотрим, что будет храниться на стеке локальных переменных
(рис. 8).
ESP →
адрес возврата
a
b
res
-8
-4
+0
+4
+8
+12
Рис. 8. Размещение переменных на стеке
Подумаем, какие регистры нам придётся занять. Ассемблер не поддер
живает двойную операцию взятия значения по адресу. Поэтому нам по
требуются три регистра для хранения указателей на массивы a, b и res.
28
Проект 2. Вычисления с длинными числами
Пусть это будут esi, edi и eax. Также необходимо завести счётчик элемен
тов, чтобы следить сколько уже обработано элементов массива. Счётчик
положим в регистр ecx. Ассемблер не позволяет сложить два элемента с
косвенной адресацией. По этой причине нам потребуется ещё один регистр
для промежуточного сложения. Выберем для этой цели регистр ebx.
Значения всех используемых нами регистров, кроме регистра eax, необ
ходимо предварительно сохранить на стеке локальных переменных. После
таких преобразований стек примет вид, показанный на рис. 9.
ESP →
edi
esi
ecx
ebx
адрес возврата
a
b
res
-8
-4
+0
+4
+8
+12
+16
+20
+24
+28
Рис. 9. Размещение переменных на стеке после сохранения значений ис
пользуемых регистров
Если части представления числа уложены в массивы в обычном (для че
ловека) порядке, то старшие биты находятся в начале массива, а — млад
шие в конце. Алгоритм сложения чисел в столбик выполняет обработку
чисел от младших цифр к старшим. Следовательно, нам будет необходимо
двигаться по массиву с конца в начало. Как получить адрес последнего эле
мента массива, зная адрес его начала и общее число элементов? Пусть,
для однозначности, мы рассматриваем массив a. Тогда, согласно нашей
схеме, адрес его начала лежит в регистре esi, а номер элемента в реги
стре ecx. Один 32-битный элемент занимает четыре байта памяти. Тогда
n-й элемент массива доступен по формуле:
[esi + 4 * ecx].
Замечание. Количество элементов массива на единицу больше номера
его последнего элемента. Поэтому если в ecx лежит общее количество эле
ментов массива, то адрес последнего элемента массива будет получаться
по следующей формуле:
[esi + 4 * ecx - 4].
Сложение двух 128-битных чисел
29
Роль «запоминаемой в уме» цифры у нас будет играть флаг CF. На
первом шаге его надо обнулить! Это можно сделать командой clc.
Всё готово, чтобы написать реализацию функции на языке Ассемблер.
Пример 3.1.
.intel_syntax noprefix
.globl add128
.type add128,@function
add128:
step:
push ebx
push ecx
push esi
push edi
mov esi,
mov edi,
mov eax,
mov ecx,
clc
[esp + 20]
[esp + 24]
[esp + 28]
4
mov ebx, [esi + 4 * ecx - 4]
adc ebx, [edi + 4 * ecx - 4]
mov [eax + 4 * ecx - 4], ebx
loop step
pop
pop
pop
pop
ret
edi
esi
ecx
ebx
Осталось только написать тестовую программу на языке C, которая
позволяла бы продемонстрировать использование реализованной функции.
Пример 3.2.
# include <stdio.h>
extern int* add128(int*, int*, int*);
int main(void)
{
int a[4] = {1, 0xffffffff, 1, 0xffffffff},
30
}
Проект 2. Вычисления с длинными числами
b[4] = {0, 1, 0, 1},
c[4] = {0, 0, 0, 0}, *res;
res = add128(a, b, c);
printf("%x %x %x %x\n", res[0], res[1],
res[2], res[3]);
return 0;
3.4. Задачи для самостоятельного решения. Напишите на
языках C и Ассемблер функции, описание и прототип которых приведе
ны ниже.
1. char* minus(const char* a, const char* b, char* c,
int size_a, int size_b);
Функция вычитает длинное число b из длинного числа a и кладёт
ответ в длинное число c. Длинные числа представлены массивами
из 16-битных элементов. Размер массива b — size_b вхождений,
массивов a и c — size_a вхождений. Функция возвращает указатель
на начало массива c.
2. short* minus(short* a, const short* b, int size);
Функция вычитает длинное число b из длинного числа a и кладёт от
вет назад в длинное число a. Длинные числа представлены массивами
из 16-битных элементов. Размер массивов a и b — size вхождений.
Функция возвращает указатель на начало массива a.
3. unsigned int* avg(unsigned int* a, const unsigned int* b,
int size);
Функция вычисляет среднее арифметическое двух длинных чисел a и
b и кладёт ответ назад в длинное число a. Длинные числа представ
лены массивами из 32-битных элементов. Размер массивов a и b —
size вхождений. Функция возвращает указатель на начало массива
a. Для деления на два рекомендуется использовать операцию сдвига
shr.
4. unsigned int* avg(unsigned int* a, const unsigned int* b,
unsigned int* c, int size);
Функция вычисляет среднее арифметическое двух длинных чисел a
и b и кладёт ответ в длинное число c. Длинные числа представлены
массивами из 32-битных элементов. Размер массивов a, b и c —
size вхождений. Функция возвращает указатель на начало массива
c. Для деления на два рекомендуется использовать операцию сдвига
shr.
5. int* longdiv(const int* a, const int* b,
int* c, int size);
Задачи для самостоятельного решения
31
Функция осуществляет целочисленное деление длинного числа a на
длинное число b и кладёт ответ в длинное число c. Длинные числа
представлены массивами из 32-битных элементов. Размер массивов
a, b и c — size вхождений. Деление длинных чисел реализуйте путём
их вычитания. Функция возвращает указатель на начало массива c.
6. int* longmod(const int* a, const int* b,
int* c, int size);
Функция осуществляет целочисленное деление длинного числа a на
длинное число b и кладёт остаток от деления в длинное число c.
Длинные числа представлены массивами из 32-битных элементов.
Размер массивов a, b и c — size вхождений. Деление длинных чисел
реализуйте путём их вычитания. Функция возвращает указатель на
начало массива c.
7. int* longmul(const int* a, const int* b,
int* c, int size);
Функция осуществляет умножение длинного числа a на длинное чис
ло b и кладёт результат в длинное число c. Длинные числа представ
лены массивами из 32-битных элементов. Размер массивов a, b и c
— size вхождений. Умножение длинных чисел реализуйте путём их
сложения. Функция возвращает указатель на начало массива c.
8. int* longmul(const int* a, const int* b, int size);
Функция осуществляет умножение длинного числа a на длинное чис
ло b и кладёт результат назад в длинное число a. Длинные числа
представлены массивами из 32-битных элементов. Размер массивов
a, и b — size вхождений. Умножение длинных чисел реализуйте пу
тём их сложения. Функция возвращает указатель на начало массива
a.
4. Проект 3. Операции с числами с плавающей
запятой
4.1. Представление чисел с плавающей запятой на архи
тектуре Intel 80386. Важным аспектом при работе с числами с пла
вающей запятой (далее дробные числа) является тот факт, что их представ
ление на компьютере ограничено, в отличие от целых чисел, не только по
максимальному и минимальному значеням. Ограничения накладываются
также и на точность представления чисел, то есть на количество знача
щих цифр в их записи. По этой причине допустимы только дробные числа,
1
имеющие конечную форму записи. Например, дробь 3 будет округлена до
конечного числа знаков.
Математический сопроцессор Intel 80387 умеет обрабатывать три ос
новных типа дробных чисел 32-битное число, 64-битное число и 80-битное
число. Первым двум из них соответствуют типы языка C float и double,
соответственно.
В предыдущей главе был рассмотрен алгоритм преобразования целого
числа из десятичной системы счисления в двоичную систему счисления. Но
как быть с дробными числами? Разберём преобразование дробных чисел
из десятичной системы счисления в двоичную на примере. Пусть в деся
тичной системе задано число 12, 62510 . Преобразуем целую часть числа
по старому алгоритму: 1210 = 101002 . Остаётся преобразовать дробную
часть. Рассмотрим по убыванию степени числа два, начиная со степени
−1 (табл. 1). Будем по очереди сравнивать десятичную запись числа со
значениями отрицательных степеней двойки. Если значение степени боль
ше оставшейся части числа, то в соответствующую позицию после запятой
вписывается ноль, иначе число уменьшается на единицу, и в соответствую
щую позицию вписывается единица. Процесс повторяется до тех пор, пока
число не превратится в ноль. Для числа 12, 62510 получаем:
12, 62510 = 10100, ...2 остаток: 0, 625;
0, 625 > 0, 5 ⇒ 12, 62510 = 10100, 1...2 остаток: 0, 125;
0, 125 < 0, 25 ⇒ 12, 62510 = 10100, 10...2 остаток: 0, 125;
0, 125 = 0, 125 ⇒ 12, 62510 = 10100, 1012 .
Известно, что любое число в десятичной системе счисления может быть
записано в экспоненциальной форме. Или, говоря другим языком, любое
Работа с математическим сопроцессором Intel 80387
Показатель степени
-1
-2
-3
-4
-5
-6
Полная запись
2−1
2−2
2−3
2−4
2−5
2−6
33
Десятичная дробь
0,5
0,25
0,125
0,0625
0,03125
0,015625
Таблица 1. Cоответствие отрицательных степеней двойки десятичным дро
бям
число может быть записано в такой форме, когда перед десятичной запятой
стоит всего одна цифра, и она отлична от нуля (исключение составляет
число ноль). Например:
1234, 56 = 1, 23456 × 103 ;
120 = 1, 2 × 102 ;
−0, 000123456 = −1, 23456 × 10−4 .
Аналогичный подход применим и для двоичной системы счисления. На
пример, наше число 12, 62510 = 10100, 1012 может быть записанно в виде:
1, 01001012 × 21002 . Степень двойки (в данном примере 1002) называется
экспонентой, а предшествующее знаку умножения число (в данном приме
ре 1, 01001012) — мантиссой.
В десятичной системе счисления цифра перед запятой в экспоненциаль
ной форме записи числа может принимать значения от 1 до 9. В двоичной
форме возможен только один вариант — 1. По этой причине разработчики
фирмы Intel приняли решение её не хранить. Таким образом, в представ
лении дробных чисел хранится не вся мантисса, а только её часть после
запятой. Экспонента в общем случае может быть как положительной, так и
отрицательной. Это не очень удобно. Разработчики Intel всегда прибавля
ют к экспоненте некоторое большое положительное число, что позволяет
избежать необходимости отслеживания знака. Размеры мантиссы и экспо
ненты для разных типов дробных чисел показаны в табл. 2.
4.2. Работа с математическим сопроцессором Intel 80387.
Сопроцессор Intel 80387 содержит собственный набор регистров и предо
ставляет пользователю собственный набор команд. Группа основных, необ
ходимых для работы программиста регистров включает в себя набор реги
стров данных (R0-R7), регистр состояния (SR) и регистр управления (CR).
34
Проект 3. Операции с числами с плавающей запятой
Общее
кол-во бит
32
64
80
Тип данных
в языке C
float
double
–
Длина
мантиссы
23 бита + 1 бит для знака
52 бита + 1 бит для знака
64 бита + 1 бит для знака
Длина
экспоненты
8 бит
11 бит
15 бит
Таблица 2. Основные поддерживаемые архитектурой Intel 80386 типы
дробных чисел
Регистры данных аналогичны регистрам общего назначения основно
го микропроцессора с двумя отличиями. Во-первых, они все полностью
равнозначны и служат одинаковым целям. Во-вторых, они не могут быть
доступны по непосредственному имени. Вместо этого регистры данных об
разуют циклический стек. Вершина стека адресуема по имени st(0), осталь
ные регистры по аналогичным именам с большими индексами: st(1)-st(7).
Все регистры данных имеют размер в 80 бит, но могут использоваться и
для 32- и 64-битных операций.
Регистры состояния и управления играют роль аналогичную регистру
флагов (EFlags) основного микропроцессора. Флаги регистра CR управ
ляют выполнением последующих инструкций. Разберём некоторые из них
(табл. 3). Как уже говорилось ранее, сопроцессор Intel 80387 поддержива
ет три режима вычислений: 32-, 64- и 80-битные. Выбор точности вычис
лений осуществляется посредством флага PC, состоящего из 8-го и 9-го
битов регистра управления. Два бита образуют четыре варианта значений.
Ноль соответствует 32-битной точности. Двойка — 64-битной точности.
Тройка — 80-битной точности. Единица зарезервирована и не использует
ся.
При работе с дробными числами часто возникает задача округления
до целого числа. Сопроцессор Intel 80387 предлагает четыре алгоритма
округления. Каждому из них соответствует двухбитовое число. Для выбо
ра алгоритма округления его номер записывается в 10-й и 11-й биты ре
гистра управления, образующие флаг RC. Доступны следующие алгоритмы
округления: ноль — округление к ближайшему числу, один — округление
к отрицательной бесконечности, два — округление к положительной бес
конечности, три — округление к нулю.
В регистре состояния интерес представляют биты 8, 9, 10 и 14. Они
образуют набор условных флагов (Ñ0-Ñ3). Команды сопроцессора не изме
няют значений регистра флагов EFlags. Вместо этого выставляются зна
чения условных флагов регистра состояния. Их можно легко скопировать
в регистр EFlags. Например, набор команд
Работа с математическим сопроцессором Intel 80387
35
fstsw ax
sahf
копирует значения Ñ0 в CF, C2 в PF, Ñ3 в ZF.
Номер бита
8
9
10
11
Флаг
PC
PC
RC
RC
Описание
Первый бит управления точностью
Второй бит управления точностью
Первый бит управления округлением
Второй бит управления округлением
Таблица 3. Основные поддерживаемые архитектурой Intel 80387 типы
дробных чисел
Все инструкции сопроцессора начинаются с литеры f (от английского
названия сопроцессора — floating point unit). Рассмотрим наиболее важ
ные из них.
Инструкции для перемещения данных
fld источник — загружает на вершину стека сопроцессора дробное
число. При этом число размещается на месте регистра st(7), после чего
стек циклически сдвигается на один шаг. Таким образом, st(7) превра
щается в st(0), то есть в новую вершину стека. Источник может быть
размещён в оперативной памяти или в другом регистре стека сопроцессо
ра.
fst получатель — загружает дробное число c вершины стека сопро
цессора и копирует его в получателя. Стек при этом не изменяется. Полу
чатель может быть размещён в оперативной памяти или в другом регистре
стека сопроцессора.
fstp получатель — перемещает дробное число c вершины стека со
процессора и в получателя. Стек при этом циклически сдвигается в об
ратную сторону, а ставший после этого регистром st(7) бывший регистр
st(0) помечается свободным. Говоря простым языком, с вершины стека
удаляется одно значение. Получатель может быть размещён в оперативной
памяти или в другом регистре стека сопроцессора.
Замечание. Если инструкция сопроцессора оканчивается на литеру p,
то это означает, что помимо основного действия осуществляется удаление
вершины стека. Если в конце инструкции стоит две литеры p, то с вершины
стека удаляются два подряд идущих значения.
fldz — загружает на вершину стека число ноль. При этом ноль разме
щается на месте регистра st(7), после чего стек циклически сдвигается
36
Проект 3. Операции с числами с плавающей запятой
на один шаг. Таким образом, st(7) превращается в st(0), то есть в новую
вершину стека.
fld1 — загружает на вершину стека единицу. При этом единица разме
щается на месте регистра st(7), после чего стек циклически сдвигается
на один шаг. Таким образом, st(7) превращается в st(0), то есть в новую
вершину стека.
fild источник — загружает на вершину стека целое число. Число при
этом размещается на месте регистра st(7), после чего стек циклически
сдвигается на один шаг. Таким образом, st(7) превращается в st(0), то
есть в новую вершину стека. Источник может быть размещён только в
оперативной памяти.
fldpi — загружает на вершину стека приблежённое значение числа π.
При этом оно размещается на месте регистра st(7), после чего стек цик
лически сдвигается на один шаг. Таким образом, st(7) превращается в
st(0), то есть в новую вершину стека.
fxch источник — меняет местами значения источника и регистра
st(0). Источник может быть размещён только в другом регистре стека
сопроцессора. Если источник не указан, то меняются местами st(0) и
st(1).
Арифметические инструкции
fadd получатель, источник — складывает значения источника и
получателя. Результат записывается в получателя. Если один из операндов
размещён в оперативной памяти, то получателем всегда выступает st(0). В
этом случае указывается только источник. Один из операндов всегда лежит
в st(0). Если операнды лежат в st(0) и st(1), то аргументы можно не
указывать вовсе.
faddp получатель, источник — инструкция аналогична fadd, толь
ко помимо вычислений она дополнительно выталкивает одно значение с
вершины стека.
Замечание: данная инструкция очень удобна, когда необходимо убрать
после сложения «мусор». Вместо двух аргументов остаётся только резуль
тат.
fmul получатель, источник — умножает значение источника на
значение получателя. Результат записывается в получателя. Если один из
операндов размещён в оперативной памяти, то получателем всегда высту
пает st(0). В этом случае указывается только источник. Один из опе
рандов всегда лежит в st(0). Если операнды лежат в st(0) и st(1), то
аргументы можно не указывать вовсе.
fmulp получатель, источник — инструкция аналогична fmul, толь
ко помимо вычислений она дополнительно выталкивает одно значение с
вершины стека.
Работа с математическим сопроцессором Intel 80387
37
Замечание. Операции умножения и сложения обладают свойством ком
мутативности, то есть их аргументы можно менять местами без изменения
результата. Операции вычитания и деления таким свойством не обладают.
Их результат зависит от порядка следования аргументов.
fsub получатель, источник — вычитает значение источника из по
лучателя. Результат записывается в получателя. Если один из операндов
размещён в оперативной памяти, то получателем всегда выступает st(0).
В этом случае указывается только источник. Один из операндов всегда ле
жит в st(0). Если операнды лежат в st(0) и st(1), то аргументы можно
не указывать вовсе.
fsubp получатель, источник — инструкция аналогична fsub, толь
ко помимо вычислений она дополнительно выталкивает одно значение с
вершины стека.
fsubr получатель, источник — вычитает значение получателя из
источника. Результат записывается в получателя. Если один из операндов
размещён в оперативной памяти, то получателем всегда выступает st(0). В
этом случае указывается только источник. Один из операндов всегда лежит
в st(0). Если операнды лежат в st(0) и st(1), то аргументы можно не
указывать вовсе.
fsubrp получатель, источник — инструкция аналогична fsubr,
только помимо вычислений она дополнительно выталкивает одно значение
с вершины стека.
fdiv получатель, источник — делит значение получателя на зна
чение источника. Результат записывается в получателя. Если один из опе
рандов размещён в оперативной памяти, то получателем всегда выступает
st(0). В этом случае указывается только источник. Один из операндов
всегда лежит в st(0). Если операнды лежат в st(0) и st(1), то аргумен
ты можно не указывать вовсе.
fdivp получатель, источник — инструкция аналогична fdiv, толь
ко помимо вычислений она дополнительно выталкивает одно значение с
вершины стека.
fdivr получатель, источник — делит значение источника на значе
ние получателя. Результат записывается в получателя. Если один из опе
рандов размещён в оперативной памяти, то получателем всегда выступает
st(0). В этом случае указывается только источник. Один из операндов
всегда лежит в st(0). Если операнды лежат в st(0) и st(1), то аргумен
ты можно не указывать вовсе.
fdivrp получатель, источник — инструкция аналогична fdivr,
только помимо вычислений она дополнительно выталкивает одно значение
с вершины стека.
38
Проект 3. Операции с числами с плавающей запятой
fabs — вычисляет абсолютное значение (модуль) числа, лежащего на
вершине стека сопроцессора (в st(0)), и записывает полученный результат
на то же самое место (в st(0)).
fchs — инвертирует знак числа, лежащего на вершине стека сопроцес
сора — в st(0), и записывает полученный результат на то же самое место
— в st(0).
frndint — округляет до целого (по одному из рассмотренных ранее ал
горитмов округления) значение числа, лежащего на вершине стека сопро
цессора — в st(0), и записывает полученный результат на то же самое
место — в st(0).
fscale — умножает значение, лежащее в st(0), на число два, возве
дённое в степень. Показатель степени берётся из st(1), значение которого
предварительно округляется в сторону нуля до целого числа.
fsqrt — вычисляет квадратный корень числа, лежащего на вершине
стека сопроцессора — в st(0), и записывает полученный результат на то
же самое место — в st(0).
Инструкции для сравнения
fcom источник — сравнивает значение, лежащее в st(0), c источ
ником. Источник может быть размещён как в оперативной памяти, так и
в одном из регистров сопроцессора. Если источник не указан, то сравни
ваются значения st(0) и st(1). В результате сравнения выставляются
условные флаги регистра состояния SR (табл. 4).
Замечание. Помимо трёх основных результатов сравнения возможен
ещё четвёртый — числа несравнимы. Этот вариант возможен в режиме
маскировки недопустимых операций. В этом случае операции, вызываю
щие деление на ноль, операции, приводящие к превышению допустимых
рамок представления чисел, или другие подобные ошибочные ситуации
не завершаются возникновением исключения. Вместо этого формируются
несравнимые числа. Например, NaN (от англ. not a number). Если один из
операндов был таким числом, и по-прежнему включён режим маскировки,
то три условных флага выставляются в единицу.
Ситуация
Источник < st(0)
Источник = st(0)
Источник > st(0)
Операнды несравнимы
Флаг C0
0
0
1
1
Флаг C2
0
0
0
1
Флаг C3
0
1
0
1
Таблица 4. Изменение условных флагов в результате применения инструк
ции fcom
Работа с математическим сопроцессором Intel 80387
39
fcomp источник — инструкция аналогична fcom, только помимо
сравнения она дополнительно выталкивает одно значение с вершины стека.
fcompp — инструкция аналогична fcom, только помимо сравнения она
дополнительно выталкивает два значение с вершины стека. Аргументов
нет. Всегда сравниваются st(0) и st(1).
Замечание. Инструкции fcom, fcomp и fcompp заполняют только флаги
регистра состояния SR, но не изменяют флагов регистра EFlags. Поэтому
для того чтобы можно было пользоваться результатами сравнения в опера
циях условных переходов, необходимо предварительно скопировать флаги
из SR в EFlags.
fcomi источник — инструкция аналогична fcom, только помимо срав
нения она дополнительно копирует флаги из регистра SR в регистр EFlags.
Флаг Ñ0 переходит в CF, C2 — в PF, а Ñ3 — в ZF.
fcomip источник — инструкция аналогична fcomp, только помимо
сравнения и выталкивания она дополнительно копирует флаги из регистра
SR в регистр EFlags. Флаг Ñ0 переходит в CF, C2 — в PF, а Ñ3 — в ZF.
Управляющие инструкции
ffree аргумент — инструкция помечает указанный в качестве аргу
мента регистр сопроцессора как пустой.
fincstp — циклически меняет нумерацию регистрового стека сопроцес
сора в большую сторону по аналогии с выталкиванием.
Замечание. Полноценное выталкивание вершины стека получается
только при использовании комбинации инструкций ffree и fincstp.
fdecstp — циклически меняет нумерацию регистрового стека сопроцес
сора в меньшую сторону.
finit — обнуление состояния сопроцессора до значения по умолчанию.
Значения регистров данных не изменяются.
Трансцендентные операции
fsin — вычисляет синус угла (заданного в радианах), записанного в
st(0), и кладёт его на то же самое место — в st(0).
fcos — вычисляет косинус угла (заданного в радианах), записанного в
st(0), и кладёт его на то же самое место — в st(0).
fsincos — вычисляет синус и косинус угла (заданного в радианах), за
писанного в st(0). Значение синуса кладётся на старое место — в st(0).
После чего в стек добавляется значение косинуса. Таким образом, стек
продвигается, и значение синуса перемещается в st(1). Косинус же ле
жит на вершине стека — â st(0).
Замечание. Данная команда позволяет быстро вычислить значение ко
тангенса угла. Достаточно дополнить её делением.
fptan — вычисляет тангенс угла (заданного в радианах), записанного
в st(0), и кладёт его на то же самое место — в st(0). После этого в
40
Проект 3. Операции с числами с плавающей запятой
стек добавляется единица. Таким образом, стек продвигается, и значение
тангенса перемещается в st(1).
Замечание. Данная команда тоже позволяет быстро вычислить значе
ние котангенса угла. Вновь достаточно только дополнить её делением.
fpatan — вычисляет арктангенс угла (заданного в радианах). Причём
аргумент арктангенса получается из значений регистров st(0) и st(1) по
формуле: st(1) . Одно из значений впоследствии выталкивается из стека,
st(0)
а на место второго кладётся результат. Таким образом, результат оказыва
ется в st(0).
fil2x — вычисляет произведение значения регистра st(1) и двоичного
логарифма от значения регистра st(0) (st(1) × log2 st(0)). Одно из зна
чений впоследствии выталкивается из стека, а на место второго кладётся
результат. Таким образом, результат оказывается в st(0).
4.3. Вычисление объёма шара. Рассмотренный минимальный на
бор инструкций позволяет решать простейшие задачи. В качестве примера
разберём задачу о нахождении объёма шара по заданному радиусу. Про
тотип функции на языке C выглядит следующим образом:
double volume(double radius);
Для начала вспомним формулу объёма шара:
V =
4 3
πr ,
3
где r — радиус шара.
Для начала нам потребуется вычислить константу 4 . Сделаем это в лоб,
3
поделив число четыре на три. В процессе будем использовать промежуточ
ную переменную в памяти. Свободное место для размещения переменной
есть на стеке. Чтобы стек не смещался, будем хранить числа в его отри
цательной части. В частности, целое 4-байтовое число можно разместить
по адресу [esp + 4].
Важно также решить, как будет передаваться ответ вызывающему
функцию процессу. Соглашение языка C подразумевает, что функции, тип
возвращаемого значения у которых double или float, перед завершением
работы размещают результат своих вычислений на вершине стека сопро
цессора. То есть в st(0).
Кроме того, функция не должна оставлять после себя «мусор». Стек
сопроцессора должен содержать только ответ. Таким образом, необходимо
позаботиться об удалении результатов всех промежуточных вычислений!
Замечание. Если стек сопроцессора не чистить, то после нескольких
вызовов функции вычисления перестанут осуществляться правильно. Не
Вычисление объёма шара
41
забывайте тестировать свои решения задач на нескольких подряд идущих
вызовах!
Пример 3.1. Реализация функции нахождения объёма шара на языке
C.
# include <math.h>
double volume(double radius)
{
return 4.0 / 3.0 * atan(1) * 4 * radius * radius * radius;
}
Замечание. Функция арктангенса потребовалась для получения чис
ла π. Для этого использовалась формула: π = 4 × arctg(1).
Пример 3.2. Реализация функции нахождения объёма шара на языке
ассемблер.
.intel_syntax noprefix
.globl volume
.type volume,@function
volume:
mov dword ptr [esp - 4], 4
fild dword ptr [esp - 4]
mov dword ptr [esp - 4], 3
fild dword ptr [esp - 4]
fdivp st(1), st(0)
fldpi
fmulp
fld qword ptr [esp + 4]
fld qword ptr [esp + 4]
fld qword ptr [esp + 4]
fmulp
fmulp
fmulp
ret
Пример 3.3. Тестовая программа на языке C, позволяющая продемон
стрировать использование реализованных функций.
# include <stdio.h>
extern double volume(double);
42
Проект 3. Операции с числами с плавающей запятой
int main(void)
{
double r = 5;
printf("%g\n", volume(r));
return 0;
}
4.4. Задачи для самостоятельного решения. Напишите на
языках C и Ассемблер функции, описание и прототип которых приведе
ны ниже.
1. double logxy(double x, double y)
Функция вычисляет logy x.
2. double dist(double xa, double ya,
double xb, double yb)
Функция вычисляет расстояние между двумя точками A(xa, ya) и
B(xb, yb) на плоскости.
3. int isright(double xa, double ya,
double xb, double yb,
double xc, double yc)
Функция проверяет, является ли треугольник с вершинами A(xa, ya),
B(xb, yb) и C(xc, yc) правильным или нет. Возвращает единицу, если
треугольник правильный, и ноль иначе. Проверку правильности осу
ществляйте в рамках некоторой точности. Задаётся некоторая ма
ленькая величина ε, с которой по абсолютному значению сравнива
ется разность между длинами сторон треугольника. Если разность
меньше, чем ε, стороны считаются равными.
4. int roots(double a, double b, double c,
double* x1, double* x2)
Функция находит корни уравнения ax 2 + bx + c = 0. Константы a,
b и c могут быть любыми. Функция возвращает количество корней.
Если корней бесконечно много, то возвращается число −1. В пере
менные по указателям x1 и x2 размещаются значения корней (если
они есть).
5. double cube_root(double x)
√
Функция вычисляет 3 x.
6. double square(double a, double num)
Функция вычисляет по заданным длине a и числу сторон num пло
щадь соответствующего правильного многоугольника.
7. double square(double xa, double ya,
double xb, double yb,
Задачи для самостоятельного решения
8.
9.
10.
11.
43
double xc, double yc)
Функция вычисляет площадь треугольника с вершинами A(xa, ya),
B(xb, yb) и C(xc, yc).
double square(double a)
Функция вычисляет площадь окружности, вписанной в правильный
треугольник со сторонами, длина которых равна a.
double square(double angle, double r)
Функция вычисляет площадь сектора в an gle радиан, вырезанного
из окружности радиусом r.
double is_triangle(double ax, double ay,
double bx, double by,
double cx, double cy)
Функция проверяет, является ли треугольник с вершинами A(xa, ya),
B(xb, yb) и C(xc, yc) нормальным треугольником, или он вырожден
в точку или отрезок. Возвращает единицу, если треугольник не вы
рожден, и ноль иначе.
double cube_in_four_dimensions(double a)
Функция вычисляет площадь поверхности тессеракта (аналога куба
в четырёхмерном пространстве) по заданной длине ребра a.
5. Дополнительные задачи
для самостоятельного решения
1. Напишите на языках C и Ассемблер функции, описание и прототип
которых приведены ниже.
a) int* find(int* source_array, int* sub_array,
int source_size, int sub_size);
Функция находит вхождения подмассива sub_array в массиве
source_array. В качестве результата возвращается указатель
на первое найденное вхождение. Размеры массивов sub_array
и source_aray указаны в переменных sub_size и source_size,
соответственно.
b) double* intersect(double* array1, double* array2,
int size);
Функция находит пересечение двух массивов: array1 и array2.
Результирующий массив создаётся посредством вызова стан
дартного метода malloc. Размер обоих входных массивов оди
наковый и равен size элементов. Результирующий массив со
здаётся таким же. Лишние элементы заполняются нулями.
c) double volume(double r1, double r2, double r3);
Функция вычисляет объём эллипсоида с радиусами r1, r2 и r3.
d) double volume(double r1, double r2);
Функция вычисляет объём тороида с радиусами внешней и внут
ренней окружностей «бублика» r1 и r2.
e) double sum(int n, int size);
1
Функция вычисляет сумму ряда n2 для всех n = 1 . . . size.
f) int det(int** matrix);
Функция вычисляет определитель матрицы matrix размером 3×
× 3.
g) double sum(double x0, double d, int n);
Функция вычисляет сумму элементов геометрической прогрес
x
сии xi = d0i для всех i = 1 . . . n.
2. Реализуйте самостоятельно на языках C и Ассемблер функции стан
дартной библиотеки string.h. Информацию о функциях можно по
смотреть, выполнив в терминале операционной системы Linux ко
манду man èìÿ ôóíêöèè, или найти в [3] .
a) strcmp — сравнение двух строк .
b) strncmp — сравнение n символов из двух строк.
c) strcpy — копирование строки.
Дополнительные задачи для самостоятельного решения
45
memmove — перемещение области памяти.
strlen — вычисление длины строки.
strncpy — копировние n символов строки.
memcpy — копирование области памяти.
memset — присвоение заданного значения всем байтам некото
рой области памяти.
i) strchr — поиск символа в строке.
j) strcat — склеивание строк.
k) strncat — приклеивание к строке n символов другой строки.
d)
e)
f)
g)
h)
Список литературы и интернет-ресурсов
1. Зубков С.В. Assembler для DOS, Windows и UNIX. — СПб.: Питер
Маркет, 2004.
2. Архитектура и программирование микропроцессора Intel 80386. — М.,
1992.
3. Керниган Б., Ритчи Д. Язык программирования C. —М.: Вильямс,
2010.
4. http://microsym.com/editor/assets/386intel.pdf
Programmer’s Reference Manual 1986
Intel
80386
Учебное издание
Радыгин Виктор Юрьевич
АРХИТЕКТУРА ВЫЧИСЛИТЕЛЬНЫХ СИСТЕМ И КОМПЬЮТЕРНЫХ СЕТЕЙ
Учебно-методическое пособие
Редактор
К.В. Шмат
Санитарно-эпидемиологическое заключение
No77.99.60.953.Д.006314.05.07 от 31.05.2007
Подписано в печать 28.02.11
Формат бумаги 60x84/16. Изд. No 10/11-у
Усл.печ.л. 3. Уч.-изд.л. 3,25. Тираж 100. Заказ No 10
Издательство МГИУ, 115280, Москва, Автозаводская, 16
www.izdat.msiu.ru; e-mail: izdat@msiu.ru; тел. (495) 620-39-90
По вопросам приобретения продукции
издательства МГИУ обращаться по адресу:
115280, Москва, Автозаводская ул., 16
www.izdat.msiu.ru; e-mail: izdat@msiu.ru; тел. (495) 620-39-90
Отпечатано в типографии издательства МГИУ

а МГИУ

