УДК 519.178
Оптимальный алгоритм перемещения объектов
в квадратной решетке
В. В. Морозенко, А. В. Москалев
Пермский Государственный Университет, 614990, Пермь, ул. Букирева, 15
Для произвольного натурального п рассматривается задача оптимального перемеще-
ния объектов в графе, который является декартовым произведением n-вершинной цепи на
себя. Предполагается, что из каждой вершины в каждую должен быть перемещен ровно
один объект, причем за один такт по любому ребру может быть перемещено не более од-
ного объекта. Описывается алгоритм, который осуществляет перемещение всех объек-
тов за минимальное число тактов, и доказывается его оптимальность.
Постановка задачи
Проблема оптимального синхронного
перемещения объектов внутри некоторой
структуры часто возникает на практике.
Например, она возникает при поиске распре-
деления транспортных потоков внутри транс-
портной сети, обеспечивающего максимально
возможную скорость перемещения. Другим
примером может служить оптимизация по
времени процесса перераспределения заданий
между узлами имитационной модели. Эта за-
дача возникает из-за необходимости в крат-
чайшие сроки переместить часть заданий с
более загруженных на менее загруженные
узлы вычислительной сети [1].
Во всех подобных задачах под структу-
рой, внутри которой происходит перемещение
объектов, понимается граф. При этом предпо-
лагается, что перемещение объекта из одной
вершины в другую происходит за один такт
вдоль ребра, соединяющего эти вершины, и за
один такт вдоль любого ребра может быть
перемещено не более одного объекта. Если
число перемещаемых объектов велико, то
между ними возникает конфликт из-за ребер,
по которым перемещаются объекты. Для раз-
решения конфликтов можно назначить каждо-
му объекту некоторый приоритет и каждый
раз, когда будет возникать очередь из
нескольких объектов, претендующих на пере-
мещение по одному и тому же ребру, предпо-
чтение отдавать объекту с наивысшим прио-
ритетом.
Очевидно, существует множество пра-
вил распределения приоритетов между пере-
мещаемыми объектами. Однако, как только
правило будет зафиксировано, соответствую-
щий алгоритм перемещения объектов стано-
вится полностью детерминированным. С
практической же точки зрения наибольший
интерес вызывает правило, обеспечивающее
перемещение всех объектов в кратчайшие
сроки. В [2] такое правило назначения прио-
ритетов и соответствующий ему оптимальный
алгоритм перемещения объектов найдены для
произвольного дерева при условии, что из
каждой его вершины в любую другую должно
быть перемещено ровно по одному объекту.
Поиск правила осуществлен с помощью алго-
ритма, имеющего полиномиальную слож-
ность относительно числа вершин в дереве.
В настоящей работе в качестве графа
выбрана квадратная решетка n×n с числом
вершин, равным n2. Её можно рассматривать
как декартово произведение G×G, где граф G
– это n-вершинная цепь. Вершины решетки
обозначим через vi,j, где i,j = 0, n − 1 , так что-
бы вершины vi,j и vr,t были смежными тогда и
только тогда, когда | i – r | + | j – t | = 1 (см.
рис. 1).
Рис. 1. Квадратная решетка n×n
Будем предполагать, что из каждой вер-
шины решетки в любую другую вершину дол-
жен быть перемещен ровно один объект. При
этом считается, что за один такт работы алго-
ритма по каждому ребру может быть переме-
щено не более одного объекта, и допускается
одновременное перемещение объектов по
всем ребрам. Задача состоит в том, чтобы
найти такую последовательность перемеще-
ний объектов, при которой время (т.е. число
тактов), требуемое для перемещения всех
объектов, было минимальным.
Нижние оценки сложности алгоритма
перемещения
Поскольку решетка содержит 2n(n – 1)
ребер и за один такт по любому ребру допус-
кается перемещение максимум одного объек-
та, то всего за один такт по всем ребрам мо-
жет быть перемещено не более, чем 2n(n – 1)
объектов. С другой стороны, всего в решетке
должно быть перемещено ровно n2(n2 – 1)
объектов. Следовательно, получаем нижнюю
оценку на минимальное число тактов t(n), тре-
буемое для перемещения всех объектов
t ( n ) ≥ n ( n + 1) / 2 .
Однако полученную оценку можно
улучшить. Для этого цепь, образованную вер-
шинами vi,0, vi,1,...,vi,n–1, обозначим через Pi и
назовем i-ой горизонталью, а цепь, образован-
ную вершинами v0,j, v1,j,...,vn–1,j, обозначим че-
рез Qj и назовем j-ой вертикалью, где
i,j = 0, n − 1 . Пусть m = [ n / 2] . Тогда между
вершинами, входящими в горизонтали Р0,Р1,
...,Рm–1, с одной стороны, и остальными вер-
шинами решетки, с другой стороны, должно
быть перемещено 2mn2(n – m) объектов. Оче-
видно, каждый из этих объектов должен пере-
меститься хотя бы по одному «вертикально-
му» ребру, соединяющему вершину из гори-
зонтали Рm–1 со смежной вершиной из гори-
зонтали Рm, т.е. по какому-либо ребру вида
[vm–1,j, vm,j], где j = 0, n − 1 . А поскольку число
таких ребер в решетке равно n, то число
тактов, требуемое для перемещения всех ука-
занных объектов через эти ребра не может
быть меньше, чем 2mn(n – m), где m = [ n / 2] .
Таким образом мы доказали следующую тео-
рему.
Теорема. Сложность t(n) оптимально-
го алгоритма перемещения всех объектов в
квадратной решетке n×n удовлетворяет не-
равенству
 n 3 / 2, если n четно ,
t (n) ≥ 
2
 n ( n − 1) / 2, иначе .
(1)
Полученная оценка является неулучшае-
мой, поскольку, как будет показано далее, оп-
тимальный алгоритм, выполняющий переме-
щение всех объектов в кратчайшие сроки, тре-
бует число тактов, указанное в правой части
неравенства (1).
Оптимальный алгоритм перемещения
Опишем алгоритм, решающий задачу
перемещения объектов в решетке n×n, и дока-
жем, что он выполняет все перемещения за
минимально возможное число тактов, т.е. яв-
ляется оптимальным. В работе этого алгорит-
ма будем использовать оптимальный алго-
ритм перемещения объектов в n-вершинной
цепи, описанный в [2]. Там же доказано, что
его сложность с(n) удовлетворяет равенству
 n 2 / 2, если n четно ,
с(n ) =  2
 ( n − 1) / 2, иначе .
(2)
Через [i, j; r, t], где i, j, r, t = 0, n − 1 ,
причем | i – r | + | j – t | ≠ 0, обозначим объект,
который в результате работы алгоритма дол-
жен быть перемещен из начальной вершины
vi,j в финальную для этого объекта вершину
vr,t. Для каждой фиксированной пары i и j ко-
личество таких объектов равно n2 – 1, и для
каждого из них найдется единственная пара k
и l, где k,l = 0, n − 1 , причем k + l ≠ 0, для ко-
торой сам объект будет иметь вид
[i, j; i + k (mod n), j + l (mod n)].
Оптимальный алгоритм перемещения
объектов в решетке n×n будет состоять из n
этапов. Для каждой четверки i, j, r, t = 0, n − 1
, где | i – r | + | j – t | ≠ 0, объект [i, j; r, j] пере-
мещается из vi,j в vr,j вдоль j-ой вертикали на
первом этапе алгоритма, а объект [i, j; i, t]
перемещается из vi,j в vi,t вдоль i-ой горизонта-
ли на n-ом этапе. Что касается объектов [i, j; r,
t], где i ≠ r, j ≠ t , то каждый из них перемеща-
ется в течение двух последовательных этапов:
сначала вдоль i-ой горизонтали из vi,j в vi,t, а
затем вдоль t-ой вертикали из vi,t в vr,t. Переме-
щение объектов и разрешение возникающих
при этом конфликтов осуществляется с помо-
щью оптимального алгоритма перемещений в
n-вершинной цепи из [2].
Опишем оптимальный алгоритм переме-
щения в квадратной решетке n×n c помощью
математической индукции по параметру k =
1, n – номеру этапа.
Базис индукции: k = 1. Очевидно, что ис-
ходная задача для решетки n×n содержит в
себе (помимо прочего) n подзадач перемеще-
ния объектов [i, j; r, j], при i,r = 0, n − 1 , i ≠ r,
внутри j-ой вертикали, где j = 0, n − 1 . На
первом этапе алгоритма n указанных подзадач
решаются одновременно и независимо друг от
друга внутри каждой вертикали с помощью
оптимального алгоритма для n-вершинной
цепи из [2]. Независимость в данном случае
означает, что перемещение объектов и разре-
шение конфликтов происходит только внутри
каждой вертикали. По окончании этого этапа
из каждой вершины vi,j в любую другую вер-
шину vr,j той же вертикали Qj будет перемеще-
но ровно по одному объекту. Таким образом в
свои финальные вершины будут перемещены
все объекты вида [i, j; r, j], где i,j,r = 0, n − 1 ,
i ≠ r.
Кроме того, на первом этапе из каждой
вершины vi,j вдоль i-ой горизонтали переме-
щается n – 1 объектов
ветствующую
промежуточную
вершину
vi, j + l (mod n), а в свою финальную вершину
vi + 1 (mod n), j + l (mod n) он переместится на втором
этапе, двигаясь вдоль вертикали Qj + l (mod n). Та-
ким образом в силу (2) на первом этапе будет
выполнено n2/2 тактов, если n четно, либо
(n2 – 1)/2 в противном случае. В итоге по окон-
чании первого этапа в каждую вершину пере-
местится n – 1 объектов по вертикали, для ко-
торых эта вершина является финальной, и
столько же объектов по горизонтали, для ко-
торых эта вершина является лишь промежу-
точной.
Индуктивный переход: предположим,
что на k-ом этапе, где k < n, из каждой верши-
ны vi,j вдоль i-ой горизонтали согласно алго-
ритму из [2] были перемещены n – 1 объектов
[i, j; i + k (mod n), j + 1 (mod n)],
[i, j; i + k (mod n), j + 2 (mod n)],
........................................
[i, j; i + k (mod n), j + n – 1 (mod n)]
причем для каждого l = 1, n − 1 в промежу-
точную вершину vi, j + l (mod n) был перемещен
только объект
[i, j; i + k (mod n), j + l (mod n)].
Тогда на (k + 1)-ом этапе переместим далее
каждый такой объект из vi, j + l (mod n) в соответ-
ствующую
ему
финальную
вершину
vi + k (mod n), j + l (mod n) вдоль вертикали Qj + l (mod n) (см.
рис. 2).
Рис. 2. Перемещение объектов в два этапа
[i, j; i + 1 (mod n), j + 1 (mod n)],
[i, j; i + 1 (mod n), j + 2 (mod n)],
........................................
[i, j; i + 1 (mod n), j + n – 1 (mod n)],
причем для каждого l = 1, n − 1 в вершину
vi, j + l (mod n) перемещается только объект
[i, j; i + 1 (mod n), j + l (mod n)].
Перемещение всех указанных объектов вну-
три каждой горизонтали выполняется соглас-
но алгоритму для n-вершинной цепи из [2].
При этом каждый из перечисленных объектов
перемещается на первом этапе лишь в соот-
Кроме того, с помощью алгоритма из [2]
на (k + 1)-ом этапе из каждой вершины vi,j
вдоль i-ой горизонтали выполним перемеще-
ние n – 1 объектов
[i, j; i + k + 1 (mod n), j + 1 (mod n)],
[i, j; i + k + 1 (mod n), j + 2 (mod n)],
..............................................
[i, j; i + k + 1 (mod n), j + n – 1 (mod n)],
причем для каждого l = 1, n − 1 в промежу-
точную вершину vi, j + l (mod n) переместим только
объект
[i, j; i + k + 1 (mod n), j + l (mod n)].
Если k + 1 < n, то каждый такой объект будет
перемещен в свою финальную вершину вдоль
соответствующей вертикали на (k + 2)-ом эта-
пе. Если же k + 1 = n, то (k + 1)-ый этап яв-
ляется последним, и после его окончания все
указанные объекты окажутся в своих финаль-
ных вершинах. Индуктивное описание алго-
ритма завершено.
Из приведенного описания видно, что в
своих финальных вершинах по окончании
очередного этапа алгоритма оказываются все
объекты, перемещаемые на этом этапе алго-
ритма вдоль любой вертикали, а также все
объекты, перемещаемые по горизонтали толь-
ко на последнем этапе алгоритма. Все осталь-
ные объекты, т.е. перемещаемые вдоль любой
горизонтали на всех этапах, кроме последне-
го, по окончании этих этапов оказываются
лишь в промежуточных вершинах.
Докажем корректность данного алгорит-
ма. Для этого достаточно показать, что в ре-
зультате его работы для любой фиксирован-
ной четверки i, j, r, t, где i, j, r, t = 0, n − 1 ,
| i – r | + | j – t | ≠ 0, из начальной вершины vi,j в
финальную вершину vr,t будет перемещен ров-
но один объект [i, j; r, t]. В самом деле, если
i ≠ r, t = j, то согласно базису индукции
объект [i, j; r, j] будет перемещен из vi,j в vr,j на
первом этапе алгоритма. Если i = r, j ≠ t , то
объект [i, j; i, t] будет перемещен из vi,j в vi,t
на n-ом этапе алгоритма. Если же i ≠ r, j ≠ t ,
то объект [i, j; r, t] перемещается из начальной
вершины vi,j в свою финальную вершину vr,t в
течение двух последовательных этапов: сна-
чала вдоль i-ой горизонтали из vi,j в vi,t, а затем
вдоль t-ой вертикали из vi,t в vr,t. Более точно,
пусть r = i + k (mod n), t = j + l (mod n), где
k,l = 1, n − 1 . Тогда объект [i, j; r, t] будет
перемещен на k-ом этапе из vi,j в vi,t, а затем на
(k + 1)-ом этапе – из vi,t в vr,t. Все конфликты,
возникающие при перемещении объектов
внутри каждой вертикали и горизонтали, раз-
решаются независимо в соответствии с алго-
ритмом для перемещений в n-вершинной цепи
из [2]. Таким образом описанный алгоритм
корректно решает задачу перемещения объек-
тов в квадратной решетке n×n.
Вычислим сложность алгоритма. На
каждом из n его этапов независимо и одновре-
менно решаются n подзадач перемещения
объектов для каждой горизонтали и столько
же подзадач для каждой вертикали. Посколь-
ку эти подзадачи решаются одновременно и
независимо друг от друга с помощью опти-
мального алгоритма для перемещений в n-
вершинной цепи из [2], то согласно (2) каж-
дый этап состоит из n2/2 тактов, если n четно,
либо из (n2 – 1)/2 тактов в противном случае.
Следовательно, сложность s(n) описанного ал-
горитма удовлетворяет равенству
 n 3 / 2, если n четно ,
s( n ) = 
2
 n( n − 1) / 2, иначе .
Согласно оценке (1) это означает, что данный
алгоритм является оптимальным по времени,
т.е. выполняет все требуемые перемещения
объектов за минимально возможное число
тактов.
Заключение
В данной работе найден алгоритм, кото-
рый для произвольного натурального n реша-
ет задачу перемещения объектов в квадратной
решетке n×n за минимальное число тактов, и
доказана его оптимальность. Ранее в [2,3] ана-
логичные результаты были получены для n-
вершинной цепи и n-мерного единичного
куба. Обращение к конкретным топологиям
объясняется тем, что задача нахождения алго-
ритма, обеспечивающего оптимальное (т.е. в
кратчайшие сроки) перемещение объектов в
произвольном графе, является, по-видимому,
NP-трудной, поскольку она близка к NP-пол-
ной задаче составления оптимального распи-
сания для выполнения несколькими однотип-
ными параллельно работающими исполните-
лями системы зависимых заданий с частич-
ным порядком – отношением предшествова-
ния [4]. Поэтому в описываемой проблемати-
ке прослеживаются два направления исследо-
ваний.
Первое направление связано с попытка-
ми решать задачу перемещения объектов в об-
щем виде с помощью приближенных или ге-
нетических алгоритмов [5,6]. Другое направ-
ление, в рамках которого выполнена настоя-
щая работа, состоит в обнаружении широких
классов топологий, для которых удается с по-
мощью полиномиальных по сложности проце-
дур получить оптимальные алгоритмы пере-
мещения всех объектов за минимальное число
тактов.
Очевидно, что минимальное количество
тактов для графа любой структуры всегда вы-
ражается полиномом от числа его вершин.
Однако остается открытым вопрос, для всех
ли графов поиск правил перемещения объек-
тов и разрешения конфликтов, приводящих к
минимальному числу тактов, может быть осу-
ществлен с помощью полиномиального алго-
ритма. Как следует из [2,3] и данной работы,
такие алгоритмы существуют для классов n-
вершинных цепей, n-мерных единичных ку-
бов и квадратных решеток n×n.
Список литературы
1. Zheng G. Achieving High Performance on
2. Морозенко В.В. Оптимальный алгоритм
3.
4.
5.
6.
Extremely Large Parallel Machines: Perform-
ance Prediction and Load Balancing; in
Ph.D. Thesis, Department of Computer Sci-
ence, University of Illinois at Urbana-Cham-
paign, 2005.
перемещения объектов в имитационной
модели с древовидной топологией // Мате-
матика программных систем: Межвуз. сб.
науч. тр./ Перм. ун-т. Пермь, 2007, с.16–
27.
Москалев А.В. Рекурсивный оптимальный
алгоритм перемещения объектов в n-мер-
ном единичном кубе // Сборник статей
«Современная математика и математиче-
ское образование, проблемы истории и
философии математики» / Международ-
ная конференция, Россия, Тамбов, 22–25
апреля, 2008, с. 52–55.
Коффман Э.Г. Теория расписаний и вы-
числительные машины. М.: Наука, 1984.
Mikov A.I. Simulation and Design of Hard-
ware and Software with Triad// Proc.2nd In-
tl.Conf. on Electronic Hardware Description
Languages, Las Vegas, USA, 1995, pp. 15–
20.
Миков А.И., Замятина Е.Б., Осмехин К.А.
Метод динамической балансировки про-
цессов имитационного моделирования. В
кн. «Материалы Всероссийской научно-
технической конференции «Методы и
средства обработки информации МСО-
2005». М.: Изд-во МГУ, 2005, с. 472–478.
The optimal algorithm for movement of objects
in quadratic lattice
V.V. Morozenko, A.V. Moskalev
Perm State University, 614990, Perm, Bukireva st., 15
For natural N we have considered а task about optimal movement of objects in graph, which
is Cartesian product of chain with N vertexes by itself. Let only one object has to be moved from
each vertex to each other vertex. Let each movement of any object through any edge takes one
time tick, and no more than one object can be moved through any edge in the graph during one
time tick. We have described an algorithm of objects’ movement, which requires minimal quantity
of time ticks, and we have proved that such algorithm is optimal.

