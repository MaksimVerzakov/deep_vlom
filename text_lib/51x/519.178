УДК 519.178
Оптимальный алгоритм перемещения объектов
в квадратной решетке
В. В. Морозенко, А. В. Москалев
Пермский Государственный Университет, 614990, Пермь, ул. Букирева, 15
Для произвольного натурального п рассматривается задача оптимального перемещения объектов в графе, который является декартовым произведением n-вершинной цепи на
себя. Предполагается, что из каждой вершины в каждую должен быть перемещен ровно
один объект, причем за один такт по любому ребру может быть перемещено не более одного объекта. Описывается алгоритм, который осуществляет перемещение всех объектов за минимальное число тактов, и доказывается его оптимальность.
Постановка задачи
Проблема оптимального синхронного
перемещения объектов внутри некоторой
структуры часто возникает на практике.
Например, она возникает при поиске распределения транспортных потоков внутри транспортной сети, обеспечивающего максимально
возможную скорость перемещения. Другим
примером может служить оптимизация по
времени процесса перераспределения заданий
между узлами имитационной модели. Эта задача возникает из-за необходимости в кратчайшие сроки переместить часть заданий с
более загруженных на менее загруженные
узлы вычислительной сети [1].
Во всех подобных задачах под структурой, внутри которой происходит перемещение
объектов, понимается граф. При этом предполагается, что перемещение объекта из одной
вершины в другую происходит за один такт
вдоль ребра, соединяющего эти вершины, и за
один такт вдоль любого ребра может быть
перемещено не более одного объекта. Если
число перемещаемых объектов велико, то
между ними возникает конфликт из-за ребер,
по которым перемещаются объекты. Для разрешения конфликтов можно назначить каждому объекту некоторый приоритет и каждый
раз, когда будет возникать очередь из
нескольких объектов, претендующих на перемещение по одному и тому же ребру, предпочтение отдавать объекту с наивысшим приоритетом.
Очевидно, существует множество правил распределения приоритетов между перемещаемыми объектами. Однако, как только
правило будет зафиксировано, соответствующий алгоритм перемещения объектов становится полностью детерминированным. С
практической же точки зрения наибольший
интерес вызывает правило, обеспечивающее
перемещение всех объектов в кратчайшие
сроки. В [2] такое правило назначения приоритетов и соответствующий ему оптимальный
алгоритм перемещения объектов найдены для
произвольного дерева при условии, что из
каждой его вершины в любую другую должно
быть перемещено ровно по одному объекту.
Поиск правила осуществлен с помощью алгоритма, имеющего полиномиальную сложность относительно числа вершин в дереве.
В настоящей работе в качестве графа
выбрана квадратная решетка n×n с числом
вершин, равным n2. Её можно рассматривать
как декартово произведение G×G, где граф G
– это n-вершинная цепь. Вершины решетки
обозначим через vi,j, где i,j = 0, n − 1 , так чтобы вершины vi,j и vr,t были смежными тогда и
только тогда, когда | i – r | + | j – t | = 1 (см.
рис. 1).
Рис. 1. Квадратная решетка n×n
Будем предполагать, что из каждой вершины решетки в любую другую вершину должен быть перемещен ровно один объект. При
этом считается, что за один такт работы алгоритма по каждому ребру может быть перемещено не более одного объекта, и допускается
одновременное перемещение объектов по
всем ребрам. Задача состоит в том, чтобы
найти такую последовательность перемещений объектов, при которой время (т.е. число
тактов), требуемое для перемещения всех
объектов, было минимальным.
Нижние оценки сложности алгоритма
перемещения
Поскольку решетка содержит 2n(n – 1)
ребер и за один такт по любому ребру допускается перемещение максимум одного объекта, то всего за один такт по всем ребрам может быть перемещено не более, чем 2n(n – 1)
объектов. С другой стороны, всего в решетке
должно быть перемещено ровно n2(n2 – 1)
объектов. Следовательно, получаем нижнюю
оценку на минимальное число тактов t(n), требуемое для перемещения всех объектов
t ( n ) ≥ n ( n + 1) / 2 .
Однако полученную оценку можно
улучшить. Для этого цепь, образованную вершинами vi,0, vi,1,...,vi,n–1, обозначим через Pi и
назовем i-ой горизонталью, а цепь, образованную вершинами v0,j, v1,j,...,vn–1,j, обозначим через Qj и назовем j-ой вертикалью, где
i,j = 0, n − 1 . Пусть m = [ n / 2] . Тогда между
вершинами, входящими в горизонтали Р0,Р1,
...,Рm–1, с одной стороны, и остальными вершинами решетки, с другой стороны, должно
быть перемещено 2mn2(n – m) объектов. Очевидно, каждый из этих объектов должен переместиться хотя бы по одному «вертикальному» ребру, соединяющему вершину из горизонтали Рm–1 со смежной вершиной из горизонтали Рm, т.е. по какому-либо ребру вида
[vm–1,j, vm,j], где j = 0, n − 1 . А поскольку число
таких ребер в решетке равно n, то число
тактов, требуемое для перемещения всех указанных объектов через эти ребра не может
быть меньше, чем 2mn(n – m), где m = [ n / 2] .
Таким образом мы доказали следующую теорему.
Теорема. Сложность t(n) оптимального алгоритма перемещения всех объектов в
квадратной решетке n×n удовлетворяет неравенству
 n 3 / 2, если n четно ,
t (n) ≥ 
2
 n ( n − 1) / 2, иначе .
(1)
Полученная оценка является неулучшаемой, поскольку, как будет показано далее, оптимальный алгоритм, выполняющий перемещение всех объектов в кратчайшие сроки, требует число тактов, указанное в правой части
неравенства (1).
Оптимальный алгоритм перемещения
Опишем алгоритм, решающий задачу
перемещения объектов в решетке n×n, и докажем, что он выполняет все перемещения за
минимально возможное число тактов, т.е. является оптимальным. В работе этого алгоритма будем использовать оптимальный алгоритм перемещения объектов в n-вершинной
цепи, описанный в [2]. Там же доказано, что
его сложность с(n) удовлетворяет равенству
 n 2 / 2, если n четно ,
с(n ) =  2
 ( n − 1) / 2, иначе .
(2)
Через [i, j; r, t], где i, j, r, t = 0, n − 1 ,
причем | i – r | + | j – t | ≠ 0, обозначим объект,
который в результате работы алгоритма должен быть перемещен из начальной вершины
vi,j в финальную для этого объекта вершину
vr,t. Для каждой фиксированной пары i и j количество таких объектов равно n2 – 1, и для
каждого из них найдется единственная пара k
и l, где k,l = 0, n − 1 , причем k + l ≠ 0, для которой сам объект будет иметь вид
[i, j; i + k (mod n), j + l (mod n)].
Оптимальный алгоритм перемещения
объектов в решетке n×n будет состоять из n
этапов. Для каждой четверки i, j, r, t = 0, n − 1
, где | i – r | + | j – t | ≠ 0, объект [i, j; r, j] перемещается из vi,j в vr,j вдоль j-ой вертикали на
первом этапе алгоритма, а объект [i, j; i, t]
перемещается из vi,j в vi,t вдоль i-ой горизонтали на n-ом этапе. Что касается объектов [i, j; r,
t], где i ≠ r, j ≠ t , то каждый из них перемещается в течение двух последовательных этапов:
сначала вдоль i-ой горизонтали из vi,j в vi,t, а
затем вдоль t-ой вертикали из vi,t в vr,t. Перемещение объектов и разрешение возникающих
при этом конфликтов осуществляется с помощью оптимального алгоритма перемещений в
n-вершинной цепи из [2].
Опишем оптимальный алгоритм перемещения в квадратной решетке n×n c помощью
математической индукции по параметру k =
1, n – номеру этапа.
Базис индукции: k = 1. Очевидно, что исходная задача для решетки n×n содержит в
себе (помимо прочего) n подзадач перемещения объектов [i, j; r, j], при i,r = 0, n − 1 , i ≠ r,
внутри j-ой вертикали, где j = 0, n − 1 . На
первом этапе алгоритма n указанных подзадач
решаются одновременно и независимо друг от
друга внутри каждой вертикали с помощью
оптимального алгоритма для n-вершинной
цепи из [2]. Независимость в данном случае
означает, что перемещение объектов и разрешение конфликтов происходит только внутри
каждой вертикали. По окончании этого этапа
из каждой вершины vi,j в любую другую вершину vr,j той же вертикали Qj будет перемещено ровно по одному объекту. Таким образом в
свои финальные вершины будут перемещены
все объекты вида [i, j; r, j], где i,j,r = 0, n − 1 ,
i ≠ r.
Кроме того, на первом этапе из каждой
вершины vi,j вдоль i-ой горизонтали перемещается n – 1 объектов
ветствующую
промежуточную
вершину
vi, j + l (mod n), а в свою финальную вершину
vi + 1 (mod n), j + l (mod n) он переместится на втором
этапе, двигаясь вдоль вертикали Qj + l (mod n). Таким образом в силу (2) на первом этапе будет
выполнено n2/2 тактов, если n четно, либо
(n2 – 1)/2 в противном случае. В итоге по окончании первого этапа в каждую вершину переместится n – 1 объектов по вертикали, для которых эта вершина является финальной, и
столько же объектов по горизонтали, для которых эта вершина является лишь промежуточной.
Индуктивный переход: предположим,
что на k-ом этапе, где k < n, из каждой вершины vi,j вдоль i-ой горизонтали согласно алгоритму из [2] были перемещены n – 1 объектов
[i, j; i + k (mod n), j + 1 (mod n)],
[i, j; i + k (mod n), j + 2 (mod n)],
........................................
[i, j; i + k (mod n), j + n – 1 (mod n)]
причем для каждого l = 1, n − 1 в промежуточную вершину vi, j + l (mod n) был перемещен
только объект
[i, j; i + k (mod n), j + l (mod n)].
Тогда на (k + 1)-ом этапе переместим далее
каждый такой объект из vi, j + l (mod n) в соответствующую
ему
финальную
вершину
vi + k (mod n), j + l (mod n) вдоль вертикали Qj + l (mod n) (см.
рис. 2).
Рис. 2. Перемещение объектов в два этапа
[i, j; i + 1 (mod n), j + 1 (mod n)],
[i, j; i + 1 (mod n), j + 2 (mod n)],
........................................
[i, j; i + 1 (mod n), j + n – 1 (mod n)],
причем для каждого l = 1, n − 1 в вершину
vi, j + l (mod n) перемещается только объект
[i, j; i + 1 (mod n), j + l (mod n)].
Перемещение всех указанных объектов внутри каждой горизонтали выполняется согласно алгоритму для n-вершинной цепи из [2].
При этом каждый из перечисленных объектов
перемещается на первом этапе лишь в соотКроме того, с помощью алгоритма из [2]
на (k + 1)-ом этапе из каждой вершины vi,j
вдоль i-ой горизонтали выполним перемещение n – 1 объектов
[i, j; i + k + 1 (mod n), j + 1 (mod n)],
[i, j; i + k + 1 (mod n), j + 2 (mod n)],
..............................................
[i, j; i + k + 1 (mod n), j + n – 1 (mod n)],
причем для каждого l = 1, n − 1 в промежуточную вершину vi, j + l (mod n) переместим только
объект
[i, j; i + k + 1 (mod n), j + l (mod n)].
Если k + 1 < n, то каждый такой объект будет
перемещен в свою финальную вершину вдоль
соответствующей вертикали на (k + 2)-ом этапе. Если же k + 1 = n, то (k + 1)-ый этап является последним, и после его окончания все
указанные объекты окажутся в своих финальных вершинах. Индуктивное описание алгоритма завершено.
Из приведенного описания видно, что в
своих финальных вершинах по окончании
очередного этапа алгоритма оказываются все
объекты, перемещаемые на этом этапе алгоритма вдоль любой вертикали, а также все
объекты, перемещаемые по горизонтали только на последнем этапе алгоритма. Все остальные объекты, т.е. перемещаемые вдоль любой
горизонтали на всех этапах, кроме последнего, по окончании этих этапов оказываются
лишь в промежуточных вершинах.
Докажем корректность данного алгоритма. Для этого достаточно показать, что в результате его работы для любой фиксированной четверки i, j, r, t, где i, j, r, t = 0, n − 1 ,
| i – r | + | j – t | ≠ 0, из начальной вершины vi,j в
финальную вершину vr,t будет перемещен ровно один объект [i, j; r, t]. В самом деле, если
i ≠ r, t = j, то согласно базису индукции
объект [i, j; r, j] будет перемещен из vi,j в vr,j на
первом этапе алгоритма. Если i = r, j ≠ t , то
объект [i, j; i, t] будет перемещен из vi,j в vi,t
на n-ом этапе алгоритма. Если же i ≠ r, j ≠ t ,
то объект [i, j; r, t] перемещается из начальной
вершины vi,j в свою финальную вершину vr,t в
течение двух последовательных этапов: сначала вдоль i-ой горизонтали из vi,j в vi,t, а затем
вдоль t-ой вертикали из vi,t в vr,t. Более точно,
пусть r = i + k (mod n), t = j + l (mod n), где
k,l = 1, n − 1 . Тогда объект [i, j; r, t] будет
перемещен на k-ом этапе из vi,j в vi,t, а затем на
(k + 1)-ом этапе – из vi,t в vr,t. Все конфликты,
возникающие при перемещении объектов
внутри каждой вертикали и горизонтали, разрешаются независимо в соответствии с алгоритмом для перемещений в n-вершинной цепи
из [2]. Таким образом описанный алгоритм
корректно решает задачу перемещения объектов в квадратной решетке n×n.
Вычислим сложность алгоритма. На
каждом из n его этапов независимо и одновременно решаются n подзадач перемещения
объектов для каждой горизонтали и столько
же подзадач для каждой вертикали. Поскольку эти подзадачи решаются одновременно и
независимо друг от друга с помощью оптимального алгоритма для перемещений в nвершинной цепи из [2], то согласно (2) каждый этап состоит из n2/2 тактов, если n четно,
либо из (n2 – 1)/2 тактов в противном случае.
Следовательно, сложность s(n) описанного алгоритма удовлетворяет равенству
 n 3 / 2, если n четно ,
s( n ) = 
2
 n( n − 1) / 2, иначе .
Согласно оценке (1) это означает, что данный
алгоритм является оптимальным по времени,
т.е. выполняет все требуемые перемещения
объектов за минимально возможное число
тактов.
Заключение
В данной работе найден алгоритм, который для произвольного натурального n решает задачу перемещения объектов в квадратной
решетке n×n за минимальное число тактов, и
доказана его оптимальность. Ранее в [2,3] аналогичные результаты были получены для nвершинной цепи и n-мерного единичного
куба. Обращение к конкретным топологиям
объясняется тем, что задача нахождения алгоритма, обеспечивающего оптимальное (т.е. в
кратчайшие сроки) перемещение объектов в
произвольном графе, является, по-видимому,
NP-трудной, поскольку она близка к NP-полной задаче составления оптимального расписания для выполнения несколькими однотипными параллельно работающими исполнителями системы зависимых заданий с частичным порядком – отношением предшествования [4]. Поэтому в описываемой проблематике прослеживаются два направления исследований.
Первое направление связано с попытками решать задачу перемещения объектов в общем виде с помощью приближенных или генетических алгоритмов [5,6]. Другое направление, в рамках которого выполнена настоящая работа, состоит в обнаружении широких
классов топологий, для которых удается с помощью полиномиальных по сложности процедур получить оптимальные алгоритмы перемещения всех объектов за минимальное число
тактов.
Очевидно, что минимальное количество
тактов для графа любой структуры всегда выражается полиномом от числа его вершин.
Однако остается открытым вопрос, для всех
ли графов поиск правил перемещения объектов и разрешения конфликтов, приводящих к
минимальному числу тактов, может быть осуществлен с помощью полиномиального алгоритма. Как следует из [2,3] и данной работы,
такие алгоритмы существуют для классов nвершинных цепей, n-мерных единичных кубов и квадратных решеток n×n.
Список литературы
1. Zheng G. Achieving High Performance on
2. Морозенко В.В. Оптимальный алгоритм
3.
4.
5.
6.
Extremely Large Parallel Machines: Performance Prediction and Load Balancing; in
Ph.D. Thesis, Department of Computer Science, University of Illinois at Urbana-Champaign, 2005.
перемещения объектов в имитационной
модели с древовидной топологией // Математика программных систем: Межвуз. сб.
науч. тр./ Перм. ун-т. Пермь, 2007, с.16–
27.
Москалев А.В. Рекурсивный оптимальный
алгоритм перемещения объектов в n-мерном единичном кубе // Сборник статей
«Современная математика и математическое образование, проблемы истории и
философии математики» / Международная конференция, Россия, Тамбов, 22–25
апреля, 2008, с. 52–55.
Коффман Э.Г. Теория расписаний и вычислительные машины. М.: Наука, 1984.
Mikov A.I. Simulation and Design of Hardware and Software with Triad// Proc.2nd Intl.Conf. on Electronic Hardware Description
Languages, Las Vegas, USA, 1995, pp. 15–
20.
Миков А.И., Замятина Е.Б., Осмехин К.А.
Метод динамической балансировки процессов имитационного моделирования. В
кн. «Материалы Всероссийской научнотехнической конференции «Методы и
средства обработки информации МСО2005». М.: Изд-во МГУ, 2005, с. 472–478.
The optimal algorithm for movement of objects
in quadratic lattice
V.V. Morozenko, A.V. Moskalev
Perm State University, 614990, Perm, Bukireva st., 15
For natural N we have considered а task about optimal movement of objects in graph, which
is Cartesian product of chain with N vertexes by itself. Let only one object has to be moved from
each vertex to each other vertex. Let each movement of any object through any edge takes one
time tick, and no more than one object can be moved through any edge in the graph during one
time tick. We have described an algorithm of objects’ movement, which requires minimal quantity
of time ticks, and we have proved that such algorithm is optimal.

ct through any edge takes one
time tick, and no more than one object can be moved through any edge in the graph during one
time tick. We have described an algorithm of objects’ movement, which requires minimal quantity
of time ticks, and we have proved that such algorithm is optimal.

