УДК 004.3.07
КУЗНЕЦОВ И.Н., БРЕЙМАН А.Д.
АСПЕКТНО-ОРИЕНТИРОВАННЫЙ МЕТОД: ПРОФИЛИРОВАНИЕ
В статье рассматривается актуальная проблема на сегодняшний день –
профилирование и ее реализация с помощью АОП.
In article the actual problem to date – profiling and its implementation using AOP.
Проектирование и разработка любой программной единицы — это
итеративный и последовательный процесс, во время которого происходит
многократное возвращение к каждой стадии процесса разработки, при этом
каждый раз конечный результат улучшается на каждой стадии. В течении всего
времени разработки осуществляется решение таких задач как профилирование,
трассировка, соблюдение проектных соглашений, слежение за корректностью
входных и выходных данных на разных уровнях абстракции, отслеживается
поведение объектов в многопоточной среде, применяются различные подходы
к разработке повторно используемых компонент и стратегии их повторного
использования и именно на этапе разработки достаточно ощутимую помощь
программисту могут оказать вспомогательные аспекты.
Для оценки характеристик системы и для проверки результатов
полученных на основе имитационного и аналитического моделирования очень
часто возникает необходимость проведения измерительных экспериментов
позволяющих выявить “узкие места” отрицательно сказывающиеся на
эффективности работы. И именно для целей применяются инструментыпрофилировщики — это программные средства, которые позволяют получить
ряд количественных данных о процессе выполнения программы.
Такой инструмент, как профилировщик позволяет получить
необходимую информацию о процессе выполнения программы:

каким образом и на что именно расходуется время работы
программы;

сколько раз выполняется данная строка программы;

общее количество раз и перечень модулей вызывающих данный
модуль программы;

к каким файлам идет обращение программы и сколько времени на
это было затрачено.
Стандартные инструментальные средства имеющиеся в арсенале
разработчиков и предназначенные для выше описанных целей зачастую могут
не обеспечивать заданных параметров оценок, либо быть недоступными, либо
вообще отсутствовать. Для внутренних проектных целей при возникновении
потребности профилирования и отсутствии по тем или иным причинам
подходящего профилировщика можно использовать класс-профилировщик [1],
интеграция которого в проектный код даст возможность решить проблему
выявления "узких мест".
public class Profiler {
public static boolean DEBUG_MODE = false;
private static Map profiles = new Hashtable();
public static void TIMING(String pointName){
if (!DEBUG_MODE) return;
long ts = System.currentTimeMillis();
Object profile = profiles.get(pointName);
if (profile==null){
profiles.put(pointName,new Long(ts));
}else{
profiles.remove(pointName);
ts = ts-((Long)profile).longValue();
System.out.println("Profile of [" + pointName + "] is
"+ts+" ms");
}
}
}
В приведенном примере снятие профиля в конкретной точке выполнения
программы является сквозной функциональностью. Факт интеграции
описанного класса в проектный код хоть и решит такую проблему как сбор
профилей, но при этом возникнет другой негативный фактор - код компонентов
будет нагружен "лишним" вызовом профилировочного класса, который не
требуется в релизе системы. Помимо этого код разрабатываемых компонентов
становится привязанным к коду профилировщика, то есть, данное решение
проблемы выявления "узких мест” не всегда является хорошим и применимым
решением.
В случае использования АОП не составляет труда логику, которая
реализует снятие профиля с блока программы, поместить в аспектный модуль,
где будут описаны правила интеграции подобной сквозной функциональности в
код компонентов. В данном случае существенную помощь может оказать
метод, который позволяет окружить требуемую точку выполнения программы
кодом сквозной функциональности — around().
public aspect ProfilerAspect {
public pointcut appMethod() :
call(public * Application.*(..)) ;
void around() : appMethod() {
long ts = System.currentTimeMillis();
proceed();
ts = System.currentTimeMillis()-ts;
Signature sig = thisJoinPointStaticPart.getSignature();
System.out.println("Profile of [" + sig.getName() + "] is
"+ts+" ms");
}
}
При использовании набора инструкций окружающих требуемую точку
выполнения программы достаточно легко встроить логику по вычислению
расхода времени на выполнение данного участка программы, количества
выполнения данного участка кода, определение источников вызова данного
блока и многое другое. При этом основные компоненты системы ничего не
будут знать о том, что с их кодом работает проектный профилировщик,
который в свою очередь может быть легко удален из системы в финальной
версии без модификации кода основных компонентов.
Аспектный подход позволяет максимально упростить процесс
профилирования и увеличить эффективность его применения. При
использовании АОП можно легко все необходимые средства для снятия
профилей поместить в аспектные модули, которые благодаря принципам
данного подхода можно легко изменять и удалять без модификации кода
компонентов. По трудности восприятия исходного кода можно сказать, что
аспектный подход увеличивает модульность, повышается способность
компонентов к повторному использованию и повышается понятность кода,
который не "обременен" логикой профилирования.
Список литературы
1. АОП // [Электронный ресурс] – Режим доступа: http://www.javable.com
Сведения об авторах
Кузнецов Игорь Николаевич
Аспирант кафедры «Персональные компьютеры и сети»
Московский государственный университет приборостроения и информатики, г. Москва
E-mail: anin2002@rambler.ru
Брейман Александр Давидович
к.т.н, доцент кафедры «Персональные компьютеры и сети»
Московский государственный университет приборостроения и информатики, г. Москва
E-mail: adbadb@gmail.com



